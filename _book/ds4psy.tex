% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  11pt,
]{krantz}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmonofont[Scale=0.775]{MesloLGS NF}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Data Science per psicologi},
  pdfauthor={Corrado Caudek},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.14,0.14,0.14}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.43,0.43,0.43}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\defaultfontfeatures{Scale=MatchLowercase}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage[bf,singlelinecheck=off]{caption}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248,248,248}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\renewenvironment{quote}{\begin{VF}}{\end{VF}}
\let\oldhref\href
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}

\ifxetex
  \usepackage{letltxmacro}
  \setlength{\XeTeXLinkMargin}{1pt}
  \LetLtxMacro\SavedIncludeGraphics\includegraphics
  \def\includegraphics#1#{% #1 catches optional stuff (star/opt. arg.)
    \IncludeGraphicsAux{#1}%
  }%
  \newcommand*{\IncludeGraphicsAux}[2]{%
    \XeTeXLinkBox{%
      \SavedIncludeGraphics#1{#2}%
    }%
  }%
\fi

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}

\usepackage{makeidx}
\makeindex

\urlstyle{tt}

\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\newcommand{\E}{\mathbb{E}} % Define expected value operator
\DeclareMathOperator{\Var}{\mathbb{V}} % Define variance operator
\DeclareMathOperator{\SD}{SD} % Define sd operator
\DeclareMathOperator{\Cov}{Cov} % Define covariance operator
\DeclareMathOperator{\Corr}{Corr} % Define correlation operator
\DeclareMathOperator{\Me}{Me} % Define mediane operator
\DeclareMathOperator{\Mo}{Mo} % Define mode operator
\DeclareMathOperator{\Bin}{Bin} % Define binomial operator
\DeclareMathOperator{\Bernoulli}{Bernoulli} % Define Bernoulli operator
\DeclareMathOperator{\Poi}{Poi} % Define Poisson operator
\DeclareMathOperator{\Uniform}{Uniform} % Define Uniform operator
\DeclareMathOperator{\Cauchy}{Cauchy} % Define Cauchy operator
\DeclareMathOperator{\elpd}{elpd} % Define elpd operator
\DeclareMathOperator{\lppd}{lppd} % Define lppd operator
\DeclareMathOperator{\LOO}{LOO} % Define LOO operator
\DeclareMathOperator{\Ber}{\mathscr{B}} % Define Bernoulli operator
\DeclareMathOperator{\B}{B} % beta function
% \mbox{B}(a, b) % beta function
% \mbox{Beta}(a, b) % beta distribution
\newcommand{\R}{\textsf{R}} % Define R programming language symbol
\newcommand{\Real}{\mathbb{R}} % Define real number operator
\newcommand{\Prob}{\mathscr{P}}
\DeclareMathOperator{\argmin}{arg\,min} % thin space, limits on side in displays
\DeclareMathOperator{\argmax}{arg\,max} % no space, limits on side in displays

\raggedbottom % allow variable (ragged) site heights
\frenchspacing

\usepackage[
 labelfont=bf,
 font={small, it}
]{caption}
\usepackage{upquote} % print correct quotes in verbatim-environments
\usepackage{empheq}
\usepackage{xfrac}

\usepackage{polyglossia}
\setmainlanguage{italian}

% \DeclareMathSizes{10}{9}{7}{5}

\frontmatter
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Data Science per psicologi}
\author{Corrado Caudek}
\date{2022-01-18}

\usepackage{amsthm}
\newtheorem{theorem}{Teorema}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{corollary}{Corollario}[chapter]
\newtheorem{proposition}{Proposizione}[chapter]
\newtheorem{conjecture}{Congettura}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definizione}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Esempio}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Esercizio}[chapter]
\theoremstyle{definition}
\newtheorem{hypothesis}{Hypothesis}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Osservazione}
\newtheorem*{solution}{Soluzione}
\begin{document}
\maketitle

\cleardoublepage\newpage\thispagestyle{empty}\null
% \cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage
\thispagestyle{empty}
\begin{center}
\Large{Psicometria -- AA 2021/2022}

\vskip20pt

\includegraphics{images/confounding_variables.png}
\end{center}

\setlength{\abovedisplayskip}{-5pt}
\setlength{\abovedisplayshortskip}{-5pt}

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\listoffigures
\listoftables
\hypertarget{prefazione}{%
\chapter*{Prefazione}\label{prefazione}}


\emph{Data Science per psicologi} contiene il materiale delle lezioni dell'insegnamento di \emph{Psicometria B000286} (A.A. 2021/2022) rivolto agli studenti del primo anno del Corso di Laurea in Scienze e Tecniche Psicologiche dell'Università degli Studi di Firenze. \emph{Psicometria} si propone di fornire agli studenti un'introduzione all'analisi dei dati in psicologia. Le conoscenze/competenze che verranno sviluppate in questo insegnamento sono quelle della Data science, ovvero un insieme di conoscenze/competenze che si pongono all'intersezione tra statistica (ovvero, richiedono la capacità di comprendere teoremi statistici) e informatica (ovvero, richiedono la capacità di sapere utilizzare un software).

\hypertarget{la-psicologia-e-la-data-science}{%
\section*{La psicologia e la Data science}\label{la-psicologia-e-la-data-science}}


Sembra sensato spendere due parole su un tema che è importante per gli studenti: quello indicato dal titolo di questo Capitolo. È ovvio che agli studenti di psicologia la statistica non piace. Se piacesse, forse studierebbero Data science e non psicologia; ma non lo fanno. Di conseguenza, gli studenti di psicologia si chiedono: ``perché dobbiamo perdere tanto tempo a studiare queste cose quando in realtà quello che ci interessa è tutt'altro?'' Questa è una bella domanda.

C'è una ragione molto semplice che dovrebbe farci capire perché la Data science è così importante per la psicologia. Infatti, a ben pensarci, la psicologia è una disciplina intrinsecamente statistica, se per statistica intendiamo quella disciplina che studia la variazione delle caratteristiche degli individui nella popolazione. La psicologia studia \emph{gli individui} ed è proprio la variabilità inter- e intra-individuale ciò che vogliamo descrivere e, in certi casi, predire. In questo senso, la psicologia è molto diversa dall'ingegneria, per esempio. Le proprietà di un determinato ponte sotto certe condizioni, ad esempio, sono molto simili a quelle di un altro ponte, sotto le medesime condizioni. Quindi, per un ingegnere la statistica è poco importante: le proprietà dei materiali sono unicamente dipendenti dalla loro composizione e restano costanti. Ma lo stesso non può dirsi degli individui: ogni individuo è unico e cambia nel tempo. E le variazioni tra gli individui, e di un individuo nel tempo, sono l'oggetto di studio proprio della psicologia: è dunque chiaro che i problemi che la psicologia si pone sono molto diversi da quelli affrontati, per esempio, dagli ingegneri. Questa è la ragione per cui abbiamo tanto bisogno della Data science in psicologia: perché la Data science ci consente di descrivere la variazione e il cambiamento. E queste sono appunto le caratteristiche di base dei fenomeni psicologici.

Sono sicuro che, leggendo queste righe, a molti studenti sarà venuta in mente la seguente domanda: perché non chiediamo a qualche esperto di fare il ``lavoro sporco'' (ovvero le analisi statistiche) per noi, mentre noi (gli psicologi) ci occupiamo solo di ciò che ci interessa, ovvero dei problemi psicologici slegati dai dettagli ``tecnici'' della Data science? La risposta a questa domanda è che non è possibile progettare uno studio psicologico sensato senza avere almeno una comprensione rudimentale della Data science. Le tematiche della Data science non possono essere ignorate né dai ricercatori in psicologia né da coloro che svolgono la professione di psicologo al di fuori dell'Università. Infatti, anche i professionisti al di fuori dall'università non possono fare a meno di leggere la letteratura psicologica più recente: il continuo aggiornamento delle conoscenze è infatti richiesto dalla deontologia della professione. Ma per potere fare questo è necessario conoscere un bel po' di Data science! Basta aprire a caso una rivista specialistica di psicologia per rendersi conto di quanto ciò sia vero: gli articoli che riportano i risultati delle ricerche psicologiche sono zeppi di analisi statistiche e di modelli formali. E la comprensione della letteratura psicologica rappresenta un requisito minimo nel bagaglio professionale dello psicologo.

Le considerazioni precedenti cercano di chiarire il seguente punto: la Data science non è qualcosa da studiare a malincuore, in un singolo insegnamento universitario, per poi poterla tranquillamente dimenticare. Nel bene e nel male, gli psicologi usano gli strumenti della Data science in tantissimi ambiti della loro attività professionale: in particolare quando costruiscono, somministrano e interpretano i test psicometrici. È dunque chiaro che possedere delle solide basi di Data science è un tassello imprescindibile del bagaglio professionale dello psicologo. In questo insegnamento verrano trattati i temi base della Data science e verrà adottato un punto di vista bayesiano, che corrisponde all'approccio più recente e sempre più diffuso in psicologia.

\hypertarget{come-studiare}{%
\section*{Come studiare}\label{come-studiare}}


Il giusto metodo di studio per prepararsi all'esame di Psicometria è quello di seguire attivamente le lezioni, assimilare i concetti via via che essi vengono presentati e verificare in autonomia le procedure presentate a lezione. Incoraggio gli studenti a farmi domande per chiarire ciò che non è stato capito appieno. Incoraggio gli studenti a utilizzare i forum attivi su Moodle e, soprattutto, a svolgere gli esercizi proposti su Moodle. I problemi forniti su Moodle rappresentano il livello di difficoltà richiesto per superare l'esame e consentono allo studente di comprendere se le competenze sviluppate fino a quel punto sono sufficienti rispetto alle richieste dell'esame.

La prima fase dello studio, che è sicuramente individuale, è quella in cui è necessario acquisire le conoscenze teoriche relative ai problemi che saranno presentati all'esame. La seconda fase di studio, che può essere facilitata da scambi con altri e da incontri di gruppo, porta ad acquisire la capacità di applicare le conoscenze: è necessario capire come usare un software (\(\textsf{R}\)) per applicare i concetti statistici alla specifica situazione del problema che si vuole risolvere. Le due fasi non sono però separate: il saper fare molto spesso ci aiuta a capire meglio.

\hypertarget{sviluppare-un-metodo-di-studio-efficace}{%
\section*{Sviluppare un metodo di studio efficace}\label{sviluppare-un-metodo-di-studio-efficace}}


Avendo insegnato molte volte in passato un corso introduttivo di analisi dei dati ho notato nel corso degli anni che gli studenti con l'atteggiamento mentale che descriverò qui sotto generalmente ottengono ottimi risultati. Alcuni studenti sviluppano naturalmente questo approccio allo studio, ma altri hanno bisogno di fare uno sforzo per maturarlo. Fornisco qui sotto una breve descrizione del ``metodo di studio'' che, nella mia esperienza, è il più efficace per affrontare le richieste di questo insegnamento.

\begin{itemize}
\tightlist
\item
  Dedicate un tempo sufficiente al materiale di base, apparentemente facile; assicuratevi di averlo capito bene. Cercate le lacune nella vostra comprensione. Leggere presentazioni diverse dello stesso materiale (in libri o articoli diversi) può fornire nuove intuizioni.
\item
  Gli errori che facciamo sono i nostri migliori maestri. Istintivamente cerchiamo di dimenticare subito i nostri errori. Ma il miglior modo di imparare è apprendere dagli errori che commettiamo. In questo senso, una soluzione corretta è meno utile di una soluzione sbagliata. Quando commettiamo un errore questo ci fornisce un'informazione importante: ci fa capire qual è il materiale di studio sul quale dobbiamo ritornare e che dobbiamo capire meglio.
\item
  C'è ovviamente un aspetto ``psicologico'' nello studio. Quando un esercizio o problema ci sembra incomprensibile, la cosa migliore da fare è dire: ``mi arrendo'', ``non ho idea di cosa fare!''. Questo ci rilassa: ci siamo già arresi, quindi non abbiamo niente da perdere, non dobbiamo più preoccuparci. Ma non dobbiamo fermarci qui. Le cose ``migliori'' che faccio (se ci sono) le faccio quando non ho voglia di lavorare. Alle volte, quando c'è qualcosa che non so fare e non ho idea di come affontare, mi dico: ``oggi non ho proprio voglia di fare fatica'', non ho voglia di mettermi nello stato mentale per cui ``in 10 minuti devo risolvere il problema perché dopo devo fare altre cose''. Però ho voglia di \emph{divertirmi} con quel problema e allora mi dedico a qualche aspetto ``marginale'' del problema, che so come affrontare, oppure considero l'aspetto più difficile del problema, quello che non so come risolvere, ma invece di cercare di risolverlo, guardo come altre persone hanno affrontato problemi simili, opppure lo stesso problema in un altro contesto. Non mi pongo l'obiettivo ``risolvi il problema in 10 minuti'', ma invece quello di farmi un'idea ``generale'' del problema, o quello di capire un caso più specifico e più semplice del problema. Senza nessuna pressione. Infatti, in quel momento ho deciso di non lavorare (ovvero, di non fare fatica). Va benissimo se ``parto per la tangente'', ovvero se mi metto a leggere del materiale che sembra avere poco a che fare con il problema centrale (le nostre intuizioni e la nostra curiosità solitamente ci indirizzano sulla strada giusta). Quando faccio così, molto spesso trovo la soluzione del problema che mi ero posto e, paradossalmente, la trovo in un tempo minore di quello che, in precedenza, avevo dedicato a ``lavorare'' al problema. Allora perché non faccio sempre così? C'è ovviamente l'aspetto dei ``10 minuti'' che non è sempre facile da dimenticare. Sotto pressione, possiamo solo agire in maniera automatica, ovvero possiamo solo applicare qualcosa che già sappiamo fare. Ma se dobbiamo imparare qualcosa di nuovo, la pressione è un impedimento.
\item
  È utile farsi da soli delle domande sugli argomenti trattati, senza limitarsi a cercare di risolvere gli esercizi che vengono assegnati. Quando studio qualcosa mi viene in mente: ``se questo è vero, allora deve succedere quest'altra cosa''. Allora verifico se questo è vero, di solito con una simulazione. Se i risultati della simulazione sono quelli che mi aspetto, allora vuol dire che ho capito. Se i risultati sono diversi da quelli che mi aspettavo, allora mi rendo conto di non avere capito e ritorno indietro a studiare con più attenzione la teoria che pensavo di avere capito -- e ovviamente mi rendo conto che c'era un aspetto che avevo frainteso. Questo tipo di verifica è qualcosa che dobbiamo fare da soli, in prima persona: nessun altro può fare questo al posto nostro.
\item
  Non aspettatevi di capire tutto la prima volta che incontrate un argomento nuovo.\footnote{Ricordatevi inoltre che gli individui tendono a sottostimare la propria capacità di apprendere \citep{horn2021underestimating}.} È utile farsi una nota mentalmente delle lacune nella vostra comprensione e tornare su di esse in seguito per carcare di colmarle. L'atteggiamento naturale, quando non capiamo i dettagli di qualcosa, è quello di pensare: ``non importa, ho capito in maniera approssimativa questo punto, non devo preoccuparmi del resto''. Ma in realtà non è vero: se la nostra comprensione è superficiale, quando il problema verrà presentato in una nuova forma, non riusciremo a risolverlo. Per cui i dubbi che ci vengono quando studiamo qualcosa sono il nostro alleato più prezioso: ci dicono esattamente quali sono gli aspetti che dobbiamo approfondire per potere migliorare la nostra preparazione.
\item
  È utile sviluppare una visione d'insieme degli argomenti trattati, capire l'obiettivo generale che si vuole raggiungere e avere chiaro il contributo che i vari pezzi di informazione forniscono al raggiungimento di tale obiettivo. Questa organizzazione mentale del materiale di studio facilita la comprensione. È estremamente utile creare degli schemi di ciò che si sta studiando. Non aspettate che sia io a fornirvi un riepilogo di ciò che dovete imparare: sviluppate da soli tali schemi e tali riassunti.
\item
  Tutti noi dobbiamo imparare l'arte di trovare le informazioni, non solo nel caso di questo insegnamento. Quando vi trovate di fronte a qualcosa che non capite, o ottenete un oscuro messaggio di errore da un software, ricordatevi: ``Google is your friend''!
\end{itemize}

\begin{flushright}
Corrado Caudek\\
Marzo 2022 \end{flushright}

\mainmatter

\hypertarget{part-nozioni-preliminari}{%
\part{Nozioni preliminari}\label{part-nozioni-preliminari}}

\hypertarget{concetti-chiave}{%
\chapter{Concetti chiave}\label{concetti-chiave}}

La \emph{data science} si pone all'intersezione tra statistica e informatica. La statistica è un insieme di metodi ugilizzati per estrarre informazioni dai dati; l'informatica implementa tali procedure in un software. In questo Capitolo vengono introdotti i concetti fondamentali.

\hypertarget{popolazioni-e-campioni}{%
\section{Popolazioni e campioni}\label{popolazioni-e-campioni}}

\emph{Popolazione.} L'analisi dei dati inizia con l'individuazione delle unità portatrici di informazioni circa il fenomeno di interesse. Si dice popolazione (o universo) l'insieme \(\Omega\) delle entità capaci di fornire informazioni sul fenomeno oggetto dell'indagine statistica. Possiamo scrivere \(\Omega = \{\omega_i\}_{i=1, \dots, n}= \{\omega_1, \omega_2, \dots, \omega_n\}\), oppure \(\Omega = \{\omega_1, \omega_2, \dots \}\) nel caso di popolazioni finite o infinite, rispettivamente.

L'obiettivo principale della ricerca psicologica è conoscere gli esiti psicologici e i loro fattori trainanti nella popolazione. Questo è l'obiettivo delle sperimentazioni psicologiche e della maggior parte degli studi osservazionali in psicologia. È quindi necessario essere molto chiari sulla popolazione a cui si applicano i risultati della ricerca. La popolazione può essere ben definita, ad esempio, tutte le persone che si trovavano nella città di Hiroshima al momento dei bombardamenti atomici e sono sopravvissute al primo anno, o può essere ipotetica, ad esempio, tutte le persone depresse che hanno subito o saranno sottoporsi ad un intervento di psicoterapia. Il ricercatore deve sempre essere in grado di determinare se un soggetto appartiene alla popolazione oggetto di interesse.

Una \emph{sottopopolazione} è una popolazione in sé e per sé che soddisfa proprietà ben definite. Negli esempi precedenti, potremmo essere interessati alla sottopopolazione di uomini di età inferiore ai 20 anni o di pazienti depressi sottoposti ad uno specifico intervento psicologico. Molte questioni scientifiche riguardano le differenze tra sottopopolazioni; ad esempio, confrontando i gruppi con o senza psicoterapia per determinare se il trattamento è vantaggioso. I modelli di regressione, introdotti nel Capitolo \ref{regr-models-intro} riguardano le sottopopolazioni, in quanto stimano il risultato medio per diversi gruppi (sottopopolazioni) definiti dalle covariate.

\emph{Campione.} Gli elementi \(\omega_i\) dell'insieme \(\Omega\) sono detti \emph{unità statistiche}. Un sottoinsieme della popolazione, ovvero un insieme di elementi \(\omega_i\), viene chiamato \emph{campione}. Ciascuna unità statistica \(\omega_i\) (abbreviata con u.s.) è portatrice dell'informazione che verrà rilevata mediante un'operazione di misurazione.

Un campione è dunque un sottoinsieme della popolazione utilizzato per conoscere tale popolazione. A differenza di una sottopopolazione definita in base a chiari criteri, un campione viene generalmente selezionato tramite un procedura casuale. Il \emph{campionamento casuale} consente allo scienziato di trarre conclusioni sulla popolazione e, soprattutto, di quantificare l'incertezza sui risultati. I campioni di un sondaggio sono esempi di campioni casuali, ma molti studi osservazionali non sono campionati casualmente. Possono essere \emph{campioni di convenienza}, come coorti di studenti in un unico istituto, che consistono di tutti gli studenti sottoposti ad un certo intervento psicologico in quell'istituto. Indipendentemente da come vengono ottenuti i campioni, il loro uso al fine di conoscere una popolazione target significa che i problemi di rappresentatività sono inevitabili e devono essere affrontati.

\hypertarget{variabili-e-costanti}{%
\section{Variabili e costanti}\label{variabili-e-costanti}}

Definiamo \emph{variabile statistica} la proprietà (o grandezza) che è oggetto di studio nell'analisi dei dati. Una variabile è una proprietà di un fenomeno che può essere espressa in più valori sia numerici sia categoriali. Il termine ``variabile'' si contrappone al termine ``costante'' che descrive una proprietà invariante di tutte le unità statistiche.

Si dice \emph{modalità} ciascuna delle varianti con cui una variabile statistica può presentarsi. Definiamo \emph{insieme delle modalità} di una variabile statistica l'insieme \(M\) di tutte le possibili espressioni con cui la variabile può manifestarsi. Le modalità osservate e facenti parte del campione si chiamano \emph{dati} (si veda la Tabella~\protect\hyperlink{tab:term_st_desc}{1.1}).

\begin{example}
Supponiamo che il fenomeno studiato sia l'intelligenza. In uno studio, la popolazione potrebbe corrispondere all'insieme di tutti gli italiani adulti. La variabile considerata potrebbe essere il punteggio del test standardizzato WAIS-IV. Le modalità di tale variabile potrebbero essere \(112, 92, 121, \dots\). Tale variabile è di tipo quantitativo discreto.
\end{example}

\begin{example}
Supponiamo che il fenomeno studiato sia il compito Stroop. La popolazione potrebbe corrispondere all'insieme dei bambini dai 6 agli 8 anni. La variabile considerata potrebbe essere il reciproco dei tempi di reazione in secondi. Le modalità di tale variabile potrebbero essere \(1 / 2.35, 1/ 1.49, 1/2.93, \dots\). La variabile è di tipo quantitativo continuo.
\end{example}

\begin{example}
Supponiamo che il fenomeno studiato sia il disturbo di personalità. La popolazione potrebbe corrispondere all'insieme dei detenuti nelle carceri italiane. La variabile considerata potrebbe essere l'assessment del disturbo di personalità tramite interviste cliniche strutturate. Le modalità di tale variabile potrebbero essere i Cluster A, Cluster B, Cluster C descritti dal DSM-V. Tale variabile è di tipo qualitativo.
\end{example}

\hypertarget{variabili-casuali}{%
\subsection{Variabili casuali}\label{variabili-casuali}}

Il termine \emph{variabile} usato nella statistica è equivalente al termine \emph{variabile casuale} usato nella teoria delle probabilità. Lo studio dei risultati degli interventi psicologici è lo studio delle variabili casuali che misurano questi risultati. Una variabile casuale cattura una caratteristica specifica degli individui nella popolazione e i suoi valori variano tipicamente tra gli individui. Ogni variabile casuale può assumere in teoria una gamma di valori sebbene, in pratica, osserviamo un valore specifico per ogni individuo. Quando faremo riferiremo alle variabili casuali considerate in termini generali useremo lettere maiuscole come \(X\) e \(Y\); quando faremo riferimento ai valori che una variabile casuale assume in determinate circostanze useremo lettere minuscole come \(x\) e \(y\).

\hypertarget{variabili-indipendenti-e-variabili-dipendenti}{%
\subsection{Variabili indipendenti e variabili dipendenti}\label{variabili-indipendenti-e-variabili-dipendenti}}

Un primo compito fondamentale in qualsiasi analisi dei dati è l'identificazione delle variabili dipendenti (\(Y\)) e delle variabili indipendenti (\(X\)). Le variabili dipendenti sono anche chiamate variabili di esito o di risposta e le variabili indipendenti sono anche chiamate predittori o covariate. Ad esempio, nell'analisi di regressione, che esamineremo in seguito, la domanda centrale è quella di capire come \(Y\) cambia al variare di \(X\). Più precisamente, la domanda che viene posta è: se il valore della variabile indipendente \(X\) cambia, qual è la conseguenza per la variabile dipendente \(Y\)? In parole povere, le variabili indipendenti e dipendenti sono analoghe a ``cause'' ed ``effetti'', laddove le virgolette usate qui sottolineano che questa è solo un'analogia e che la determinazione delle cause può avvenire soltanto mediante l'utilizzo di un appropriato disegno sperimentale e di un'adeguata analisi statistica.

Se una variabile è una variabile indipendente o dipendente dipende dalla domanda di ricerca. A volte può essere difficile decidere quale variabile è dipendente e quale è indipendente, in particolare quando siamo specificamente interessati ai rapporti di causa/effetto. Ad esempio, supponiamo di indagare l'associazione tra esercizio fisico e insonnia. Vi sono evidenze che l'esercizio fisico (fatto al momento giusto della giornata) può ridurre l'insonnia. Ma l'insonnia può anche ridurre la capacità di una persona di fare esercizio fisico. In questo caso, dunque, non è facile capire quale sia la causa e quale l'effetto, quale sia la variabile dipendente e quale la variabile indipendente. La possibilità di identificare il ruolo delle variabili (dipendente/indipendente) dipende dalla nostra comprensione del fenomeno in esame.

\begin{example}
Uno psicologo convoca 120 studenti universitari per un test di memoria. Prima di iniziare l'esperimento, a metà dei soggetti viene detto che si tratta di un compito particolarmente difficile; agli altri soggetti non viene data alcuna indicazione. Lo psicologo misura il punteggio nella prova di memoria di ciascun soggetto.

In questo esperimento, la variabile indipendente è l'informazione sulla difficoltà della prova. La variabile indipendente viene manipolata dallo sperimentatore assegnando i soggetti (di solito in maniera causale) o alla condizione (modalità) ``informazione assegnata'' o ``informazione non data''. La variabile dipendente è ciò che viene misurato nell'esperimento, ovvero il punteggio nella prova di memoria di ciascun soggetto.
\end{example}

\hypertarget{la-matrice-dei-dati}{%
\subsection{La matrice dei dati}\label{la-matrice-dei-dati}}

Le realizzazioni delle variabili esaminate in una rilevazione statistica vengono organizzate in una \emph{matrice dei dati}. Le colonne della matrice dei dati contengono gli insiemi dei dati individuali di ciascuna variabile statistica considerata. Ogni riga della matrice contiene tutte le informazioni relative alla stessa unità statistica. Una generica matrice dei dati ha l'aspetto seguente:

\[
D_{m,n} = 
 \begin{pmatrix}
  \omega_1 & a_{1}   & b_{1}   & \cdots & x_{1} & y_{1}\\
  \omega_2 & a_{2}   & b_{2}   & \cdots & x_{2} & y_{2}\\
  \vdots   & \vdots  & \vdots  & \ddots & \vdots & \vdots  \\
 \omega_n  & a_{n}   & b_{n}   & \cdots & x_{n} & y_{n}
 \end{pmatrix}
 \]

\noindent dove, nel caso presente, la prima colonna contiene il nome delle unità statistiche, la seconda e la terza colonna si riferiscono a due mutabili statistiche (variabili categoriali; \(A\) e \(B\)) e ne presentano le modalità osservate nel campione mentre le ultime due colonne si riferiscono a due variabili statistiche (\(X\) e \(Y\)) e ne presentano le modalità osservate nel campione. Generalmente, tra le unità statistiche \(\omega_i\) non esiste un ordine progressivo; l'indice attribuito alle unità statistiche nella matrice dei dati si riferisce semplicemente alla riga che esse occupano.

\hypertarget{parametri-e-modelli}{%
\section{Parametri e modelli}\label{parametri-e-modelli}}

Ogni variabile casuale ha una \emph{distribuzione} che descrive la probabilità che la variabile assuma qualsiasi valore in un dato intervallo.\footnote{In questo e nei successivi Paragrafi di questo Capitolo introduco gli obiettivi della \emph{data science} utilizzando una serie di concetti che saranno chiariti solo in seguito. Questa breve panoramica risulterà dunque solo in parte comprensibile ad una prima lettura e serve solo per definire la \emph{big picture} dei temi trattati in questo insegnamento. Il significato dei termini qui utilizzati sarà chiarito nei Capitoli successivi.} Senza ulteriori specificazioni, una distribuzione può fare riferimento a un'intera famiglia di distribuzioni. I parametri, tipicamente indicati con lettere greche come \(\mu\) e \(\alpha\), ci permettono di specificare di quale membro della famiglia stiamo parlando. Quindi, si può parlare di una variabile casuale con una distribuzione Normale, ma se viene specificata la media \(\mu\) = 100 e la varianza \(\sigma^2\) = 15, viene individuata una specifica distribuzione Normale -- nell'esempio, la distribuzione del quoziente di intelligenza.

I metodi statistici parametrici specificano la famiglia delle distribuzioni e quindi utilizzano i dati per individuare, stimando i parametri, una specifica distribuzione all'interno della famiglia di distribuzioni ipotizzata. Se \(f\) è la PDF di una variabile casuale \(Y\), l'interesse può concentrarsi sulla sua media e varianza. Nell'analisi di regressione, ad esempio, cerchiamo di spiegare come i parametri di \(f\) dipendano dalle covariate \(X\). Nella regressione lineare classica, assumiamo che \(Y\) abbia una distribuzione normale con media \(\mu = \E(Y)\), e stimiamo come \(\E(Y)\) dipenda da \(X\). Poiché molti esiti psicologici non seguono una distribuzione normale, verranno introdotte distribuzioni più appropriate per questi risultati. I metodi non parametrici, invece, non specificano una famiglia di distribuzioni per \(f\). In queste dispense faremo riferimento a metodi non parametrici quando discuteremo della statistica descrittiva.

Il termine \emph{modello} è onnipresente in statistica e nella \emph{data science}. Il modello statistico include le ipotesi e le specifiche matematiche relative alla distribuzione della variabile casuale di interesse. Il modello dipende dai dati e dalla domanda di ricerca, ma raramente è unico; nella maggior parte dei casi, esiste più di un modello che potrebbe ragionevolmente usato per affrontare la stessa domanda di ricerca e avendo a disposizione i dati osservati. Nella previsione delle aspettative future dei pazienti depressi che discuteremo in seguito \citep{zetschefuture2019}, ad esempio, la specifica del modello include l'insieme delle covariate candidate, l'espressione matematica che collega i predittori con le aspattative future e qualsiasi ipotesi sulla distribuzione della variabile dipendente. La domanda di cosa costituisca un buon modello è una domanda su cui torneremo ripetutamente in questo insegnamento.

\hypertarget{effetto}{%
\section{Effetto}\label{effetto}}

L'\emph{effetto} è una qualche misura dei dati. Dipende dal tipo di dati e dal tipo di test statistico che si vuole utilizzare. Ad esempio, se viene lanciata una moneta 100 volte e esce testa 66 volte, l'effetto sarà 66/100. Diventa poi possibile confrontare l'effetto ottenuto con l'effetto nullo che ci si aspetterebbe da una moneta bilanciata (50/100), o con qualsiasi altro effetto che può essere scelto. La \emph{dimensione dell'effetto} si riferisce alla differenza tra l'effetto misurato nei dati e l'effetto nullo (di solito un valore che ci si aspetta di ottenere in base al caso soltanto).

\hypertarget{stima-e-inferenza}{%
\section{Stima e inferenza}\label{stima-e-inferenza}}

La stima è il processo mediante il quale il campione viene utilizzato per conoscere le proprietà di interesse della popolazione. La media campionaria è una stima naturale della media della popolazione e la mediana campionaria è una stima naturale della mediana della popolazione. Quando parliamo di stimare una proprietà della popolazione (a volte indicata come parametro della popolazione) o di stimare la distribuzione di una variabile casuale, stiamo parlando dell'utilizzo dei dati osservati per conoscere le proprietà di interesse della popolazione. L'inferenza statistica è il processo mediante il quale le stime campionarie vengono utilizzate per rispondere a domande di ricerca e per valutare specifiche ipotesi relative alla popolazione. Discuteremo le procedure bayesiane dell'inferenza nell'ultima parte di queste dispense.

\hypertarget{metodi-e-procedure-della-psicologia}{%
\section{Metodi e procedure della psicologia}\label{metodi-e-procedure-della-psicologia}}

Un modello psicologico di un qualche aspetto del comportamento umano o della mente ha le seguenti proprietà:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  descrive le caratteristiche del comportamento in questione,
\item
  formula predizioni sulle caratteristiche future del comportamento,
\item
  è sostenuto da evidenze empiriche,
\item
  deve essere falsificabile (ovvero, in linea di principio, deve potere fare delle predizioni su aspetti del fenomeno considerato che non sono ancora noti e che, se venissero indagati, potrebbero portare a rigettare il modello, se si dimostrassero incompatibili con esso).
\end{enumerate}

\noindent L'analisi dei dati valuta un modello psicologico utilizzando strumenti statistici.

Questa dispensa è strutturata in maniera tale da rispecchiare la suddivisione tra i temi della misurazione, dell'analisi descrittiva e dell'inferenza. Nel prossimo Capitolo sarà affrontato il tema della misurazione e, nell'ultima parte della dispensa verrà discusso l'argomento più difficile, quello dell'inferenza. Prima di affrontare il secondo tema, l'analisi descrittiva dei dati, sarà necessario introdurre il linguaggio di programmazione statistica R (un'introduzione a R è fornita in Appendice). Inoltre, prima di potere discutere l'inferenza, dovranno essere introdotti i concetti di base della teoria delle probabilità, in quanto l'inferenza non è che l'applicazione della teoria delle probabilità all'analisi dei dati.

\hypertarget{normal-normal-mod-stan}{%
\chapter{Modello Normale-Normale}\label{normal-normal-mod-stan}}

\hypertarget{distribuzione-normale-normale-con-varianza-nota}{%
\section{Distribuzione Normale-Normale con varianza nota}\label{distribuzione-normale-normale-con-varianza-nota}}

Per \(\sigma^2\) nota, la v.c. gaussiana è distribuzione a priori coniugata della v.c. gaussiana. Siano \(Y_1, \dots, Y_n\) \(n\) variabili casuali i.i.d. che seguono la distribuzione gaussiana:

\[
Y_1, \dots, Y_n  \stackrel{iid}{\sim} \mathcal{N}(\mu, \sigma).
\]

Si vuole stimare \(\mu\) sulla base di \(n\) osservazioni \(y_1, \dots, y_n\). Considereremo qui solamente il caso in cui \(\sigma^2\) sia supposta perfettamente nota.

Ricordiamo che la densità di una gaussiana è

\[
p(y_i \mid \mu, \sigma) = \frac{1}{{\sigma \sqrt {2\pi}}}\exp\left\{{-\frac{(y_i - \mu)^2}{2\sigma^2}}\right\}.
\]

Essendo le variabili i.i.d., possiamo scrivere la densità congiunta come il prodotto delle singole densità e quindi si ottiene

\[
p(y \mid \mu) = \, \prod_{i=1}^n p(y_i \mid \mu).
\]

Una volta osservati i dati \(y\), la verosimiglianza diventa

\begin{align}
\mathcal{L}(\mu \mid y) =& \, \prod_{i=1}^n p(y_i \mid \mu) = \notag\\
& \frac{1}{{\sigma \sqrt {2\pi}}}\exp\left\{{-\frac{(y_1 - \mu)^2}{2\sigma^2}}\right\} \times \notag\\
 & \frac{1}{{\sigma \sqrt {2\pi}}}\exp\left\{{-\frac{(y_2 - \mu)^2}{2\sigma^2}}\right\} \times  \notag\\
& \vdots \notag\\
 & \frac{1}{{\sigma \sqrt {2\pi}}}\exp\left\{{-\frac{(y_n - \mu)^2}{2\sigma^2}}\right\}.
\end{align}

Se viene scelta una densità a priori gaussiana, ciò fa sì che anche la densità a posteriori sia gaussiana. Supponiamo che

\begin{equation}
p(\mu) = \frac{1}{{\tau_0 \sqrt {2\pi}}}\exp\left\{{-\frac{(\mu - \mu_0)^2}{2\tau_0^2}}\right\},
\label{eq:prior-mu-norm-norm}
\end{equation}

ovvero che la distribuzione a priori di \(\mu\) sia gaussiana con media \(\mu_0\) e varianza \(\tau_0^2\). Possiamo dire che \(\mu_0\) rappresenta il valore ritenuto più probabile per \(\mu\) e \(\tau_0^2\) il grado di incertezza che abbiamo rispetto a tale valore.

Svolgendo una serie di passaggi algebrici, si arriva a

\begin{equation}
p(\mu \mid y) = \frac{1}{{\tau_p \sqrt {2\pi}}}\exp\left\{{-\frac{(\mu - \mu_p)^2}{2\tau_p^2}}\right\},
\label{eq:post-norm-norm}
\end{equation}

dove

\begin{equation}
\mu_p = \frac{\frac{1}{\tau_0^2}\mu_0+ \frac{n}{\sigma^2}\bar{y}}{\frac {1}{\tau_0^2} + \frac{n}{\sigma^2}} 
\label{eq:post-norm-mup}
\end{equation}

e

\begin{equation}
\tau_p^2 = \frac{1}{\frac {1}{\tau_0^2}+ \frac{n}{\sigma^2}}.
\label{eq:post-norm-taup2}
\end{equation}

In altri termini, se la distribuzione a priori per \(\mu\) è gaussiana, la distribuzione a posteriori è anch'essa gaussiana con valore atteso (a posteriori) \(\mu_p\) e varianza (a posteriori) \(\tau_p^2\) date dalle espressioni precedenti.

In conclusione, il risultato trovato indica che:

\begin{itemize}
\tightlist
\item
  il valore atteso a posteriori è una media pesata fra il valore atteso a priori \(\mu_0\) e la media campionaria \(\bar{y}\); il peso della media campionaria è tanto maggiore tanto più è grande \(n\) (il numero di osservazioni) e \(\tau_0^2\) (l'incertezza iniziale);
\item
  l'incertezza (varianza) a posteriori \(\tau_p^2\) è sempre più piccola dell'incertezza a priori \(\tau_0^2\) e diminuisce al crescere di \(n\).
\end{itemize}

\hypertarget{il-modello-normale-con-stan}{%
\section{Il modello Normale con Stan}\label{il-modello-normale-con-stan}}

Per esaminare un esempio pratico, consideriamo i 30 valori BDI-II dei soggetti clinici di \citet{zetschefuture2019}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{y =} \FunctionTok{c}\NormalTok{(}
    \FloatTok{26.0}\NormalTok{, }\FloatTok{35.0}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{44}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{43}\NormalTok{,}
    \DecValTok{24}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{41}\NormalTok{,}
    \DecValTok{36}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{22}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Calcoliamo le statistiche descrittive del campione di dati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{sample\_mean =} \FunctionTok{mean}\NormalTok{(y),}
    \AttributeTok{sample\_sd =} \FunctionTok{sd}\NormalTok{(y)}
\NormalTok{  )}
\CommentTok{\#\textgreater{}   sample\_mean sample\_sd}
\CommentTok{\#\textgreater{} 1       30.93     6.607}
\end{Highlighting}
\end{Shaded}

Nella discussione seguente assumeremo che \(\mu\) e \(\sigma\) siano indipendenti. Assegneremo a \(\mu\) una distribuzione a priori \(\mathcal{N}(25, 2)\) e a \(\sigma\) una distribuzione a priori \(Cauchy(0, 3)\).

Il modello statistico diventa:

\begin{align}
Y_i &\sim \mathcal{N}(\mu, \sigma) \notag\\
\mu &\sim \mathcal{N}(\mu_{\mu} = 25, \sigma_{\mu} = 2) \notag\\
\sigma &\sim \Cauchy(0, 3) \notag
\end{align}

In base al modello definito, la variabile casuale \(Y\) segue la distribuzione Normale di parametri \(\mu\) e \(\sigma\). Il parametro \(\mu\) è sconosciuto e abbiamo deciso di descrivere la nostra incertezza relativa ad esso mediante una distribuzione a priori Normale con media uguale a 25 e deviazione standard pari a 2. L'incertezza relativa a \(\sigma\) è quantificata da una distribuzione a priori half-Cauchy(0, 5), come indicato nella figura seguente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}
    \AttributeTok{fun =}\NormalTok{ dcauchy,}
    \AttributeTok{n =} \FloatTok{1e3}\NormalTok{,}
    \AttributeTok{args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{location =} \DecValTok{0}\NormalTok{, }\AttributeTok{scale =} \DecValTok{3}\NormalTok{)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"P(x)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-4-1} \end{center}

Dato che il modello è Normale-Normale, è possibile una soluzione analitica, come descritto in precedenza per il caso in cui \(\sigma\) è noto. In tali condizioni, la distribuzione a posteriori per \(\mu\) può essere trovata con la funzione \texttt{bayesrules:::summarize\_normal\_normal()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bayesrules}\SpecialCharTok{:::}\FunctionTok{summarize\_normal\_normal}\NormalTok{(}
  \AttributeTok{mean =} \DecValTok{25}\NormalTok{, }
  \AttributeTok{sd =} \DecValTok{2}\NormalTok{, }
  \AttributeTok{sigma =} \FunctionTok{sd}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{y),}
  \AttributeTok{y\_bar =} \FunctionTok{mean}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{y), }
  \AttributeTok{n =} \DecValTok{30}
\NormalTok{)}
\CommentTok{\#\textgreater{}       model  mean  mode   var    sd}
\CommentTok{\#\textgreater{} 1     prior 25.00 25.00 4.000 2.000}
\CommentTok{\#\textgreater{} 2 posterior 29.35 29.35 1.067 1.033}
\end{Highlighting}
\end{Shaded}

La rappresentazione grafica della funzione a priori, della verosimiglianza e della distribuzione a posteriori per \(\mu\) è fornita da:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bayesrules}\SpecialCharTok{:::}\FunctionTok{plot\_normal\_normal}\NormalTok{(}
  \AttributeTok{mean =} \DecValTok{25}\NormalTok{, }
  \AttributeTok{sd =} \DecValTok{2}\NormalTok{, }
  \AttributeTok{sigma =} \FunctionTok{sd}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{y), }
  \AttributeTok{y\_bar =} \FunctionTok{mean}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{y), }
  \AttributeTok{n =} \DecValTok{30}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-6-1} \end{center}

La procedura MCMC utilizzata da Stan è basata su un campionamento Monte Carlo Hamiltoniano che non richiede l'uso di distribuzioni a priori coniugate. Pertanto per i parametri è possibile scegliere una qualunque distribuzione a priori arbitraria.

Per continuare con l'esempio, poniamoci il problema di trovare le distribuzioni a posteriori dei parametri \(\mu\) e \(\sigma\) usando le funzioni del pacchetto \texttt{cmdstanr}. Il modello statistico descritto sopra si può scrivere in Stan nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{modelString }\OtherTok{=} \StringTok{"}
\StringTok{data \{}
\StringTok{  int\textless{}lower=0\textgreater{} N;}
\StringTok{  vector[N] y;}
\StringTok{\}}
\StringTok{parameters \{}
\StringTok{  real mu;}
\StringTok{  real\textless{}lower=0\textgreater{} sigma;}
\StringTok{\}}
\StringTok{model \{}
\StringTok{  mu \textasciitilde{} normal(25, 2);}
\StringTok{  sigma \textasciitilde{} normal(0, 5);}
\StringTok{  y \textasciitilde{} normal(mu, sigma);}
\StringTok{\}}
\StringTok{"}
\FunctionTok{writeLines}\NormalTok{(modelString, }\AttributeTok{con =} \StringTok{"code/normalmodel.stan"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si noti che, nel modello, il parametro \(\sigma\) è considerato incognito.

Sistemiamo i dati nel formato appropriato per potere essere letti da Stan:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_list }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}
  \AttributeTok{N =} \FunctionTok{length}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{y),}
  \AttributeTok{y =}\NormalTok{ df}\SpecialCharTok{$}\NormalTok{y}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Leggiamo il file in cui abbiamo salvato il codice Stan

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{file }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(}\StringTok{"code"}\NormalTok{, }\StringTok{"normalmodel.stan"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

compiliamo il modello

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod }\OtherTok{\textless{}{-}} \FunctionTok{cmdstan\_model}\NormalTok{(file)}
\end{Highlighting}
\end{Shaded}

ed eseguiamo il campionamento MCMC:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ mod}\SpecialCharTok{$}\FunctionTok{sample}\NormalTok{(}
  \AttributeTok{data =}\NormalTok{ data\_list,}
  \AttributeTok{iter\_sampling =}\NormalTok{ 4000L,}
  \AttributeTok{iter\_warmup =}\NormalTok{ 2000L,}
  \AttributeTok{seed =}\NormalTok{ SEED,}
  \AttributeTok{chains =}\NormalTok{ 4L,}
  \AttributeTok{parallel\_chains =}\NormalTok{ 2L,}
  \AttributeTok{refresh =} \DecValTok{0}\NormalTok{,}
  \AttributeTok{thin =} \DecValTok{1}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le stime a posteriori dei parametri si ottengono con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit}\SpecialCharTok{$}\FunctionTok{summary}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"mu"}\NormalTok{, }\StringTok{"sigma"}\NormalTok{))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 10}
\CommentTok{\#\textgreater{}   variable  mean median    sd   mad    q5   q95  rhat}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}    \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 mu       29.3   29.3  1.11  1.10  27.4  31.0   1.00}
\CommentTok{\#\textgreater{} 2 sigma     6.86   6.77 0.911 0.886  5.54  8.47  1.00}
\CommentTok{\#\textgreater{} \# ... with 2 more variables: ess\_bulk \textless{}dbl\textgreater{},}
\CommentTok{\#\textgreater{} \#   ess\_tail \textless{}dbl\textgreater{}}
\end{Highlighting}
\end{Shaded}

oppure, dopo avere trasformato l'oggetto \texttt{fit} nel formato \texttt{stanfit},

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stanfit }\OtherTok{\textless{}{-}}\NormalTok{ rstan}\SpecialCharTok{::}\FunctionTok{read\_stan\_csv}\NormalTok{(fit}\SpecialCharTok{$}\FunctionTok{output\_files}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out }\OtherTok{\textless{}{-}}\NormalTok{ rstantools}\SpecialCharTok{::}\FunctionTok{posterior\_interval}\NormalTok{(}
  \FunctionTok{as.matrix}\NormalTok{(stanfit), }
  \AttributeTok{prob =} \FloatTok{0.95}
\NormalTok{)}
\NormalTok{out}
\CommentTok{\#\textgreater{}         2.5\%   97.5\%}
\CommentTok{\#\textgreater{} mu     27.00  31.366}
\CommentTok{\#\textgreater{} sigma   5.32   8.853}
\CommentTok{\#\textgreater{} lp\_\_  {-}77.04 {-}73.384}
\end{Highlighting}
\end{Shaded}

Possiamo dunque concludere, con un grado di certezza soggettiva del 95\%, che siamo sicuri che la media della popolazione da cui abbiamo tratto i dati è compresa nell'intervallo {[}27, 31.37{]}.

\hypertarget{considerazioni-conclusive}{%
\section*{Considerazioni conclusive}\label{considerazioni-conclusive}}


Questo esempio ci mostra come calcolare l'intervallo di credibilità per la media di una v.c. gaussiana. La domanda più ovvia di analisi dei dati, dopo avere visto come creare l'intervallo di credibilità per la media di un gruppo, riguarda il confronto tra le medie di due gruppi. Questo però è un caso speciale di una tecnica di analisi dei dati più generale, chiamate analisi di regressione lineare. Prima di discutere il problema del confronto tra le medie di due gruppi è dunque necessario esaminare il modello statistico di regressione lineare.

\mainmatter

\hypertarget{appendix-appendix}{%
\appendix \addcontentsline{toc}{chapter}{\appendixname}}


\hypertarget{simbologia-di-base}{%
\chapter{Simbologia di base}\label{simbologia-di-base}}

Per una scrittura più sintetica possono essere utilizzati alcuni simboli matematici.

\begin{itemize}
\tightlist
\item
  \(\log(x)\): il logaritmo naturale di \(x\).
\item
  L'operatore logico booleano \(\land\) significa ``e'' (congiunzione forte) mentre il connettivo di disgiunzione \(\lor\) significa ``o'' (oppure) (congiunzione debole).
\item
  Il quantificatore esistenziale \(\exists\) vuol dire ``esiste almeno un'' e indica l'esistenza di almeno una istanza del concetto/oggetto indicato. Il quantificatore esistenziale di unicità \(\exists!\) (``esiste soltanto un'') indica l'esistenza di esattamente una istanza del concetto/oggetto indicato. Il quantificatore esistenziale \(\nexists\) nega l'esistenza del concetto/oggetto indicato.
\item
  Il quantificatore universale \(\forall\) vuol dire ``per ogni.''
\item
  \(\mathcal{A, S}\): insiemi.
\item
  \(x \in A\): \(x\) è un elemento dell'insieme \(A\).
\item
  L'implicazione logica ``\(\Rightarrow\)'' significa ``implica'' (se \ldots allora). \(P \Rightarrow Q\) vuol dire che \(P\) è condizione sufficiente per la verità di \(Q\) e che \(Q\) è condizione necessaria per la verità di \(P\).
\item
  L'equivalenza matematica ``\(\iff\)'' significa ``se e solo se'' e indica una condizione necessaria e sufficiente, o corrispondenza biunivoca.
\item
  Il simbolo \(\vert\) si legge ``tale che.''
\item
  Il simbolo \(\triangleq\) (o \(:=\)) si legge ``uguale per definizione.''
\item
  Il simbolo \(\Delta\) indica la differenza fra due valori della variabile scritta a destra del simbolo.
\item
  Il simbolo \(\propto\) si legge ``proporzionale a.''
\item
  Il simbolo \(\approx\) si legge ``circa.''
\item
  Il simbolo \(\in\) della teoria degli insiemi vuol dire ``appartiene'' e indica l'appartenenza di un elemento ad un insieme. Il simbolo \(\notin\) vuol dire ``non appartiene.''
\item
  Il simbolo \(\subseteq\) si legge ``è un sottoinsieme di'' (può coincidere con l'insieme stesso). Il simbolo \(\subset\) si legge ``è un sottoinsieme proprio di.''
\item
  Il simbolo \(\#\) indica la cardinalità di un insieme.
\item
  Il simbolo \(\cap\) indica l'intersezione di due insiemi. Il simbolo \(\cup\) indica l'unione di due insiemi.
\item
  Il simbolo \(\emptyset\) indica l'insieme vuoto o evento impossibile.
\item
  In matematica, \(\mbox{argmax}\) identifica l'insieme dei punti per i quali una data funzione raggiunge il suo massimo. In altre parole, \(\mbox{argmax}_x f(x)\) è l'insieme dei valori di \(x\) per i quali \(f(x)\) raggiunge il valore più alto.
\item
  \(a, c, \alpha, \gamma\): scalari.
\item
  \(\boldsymbol{x}, \boldsymbol{y}\): vettori.
\item
  \(\boldsymbol{X}, \boldsymbol{Y}\): matrici.
\item
  \(X \sim p\): la variabile casuale \(X\) si distribuisce come \(p\).
\item
  \(p(\cdot)\): distribuzione di massa o di densità di probabilità.
\item
  \(p(y \mid \boldsymbol{x})\): la probabilità o densità di \(y\) dato \(\boldsymbol{x}\), ovvero \(p(y = \boldsymbol{Y} \mid x = \boldsymbol{X})\).
\item
  \(f(x)\): una funzione arbitraria di \(x\).
\item
  \(f(\boldsymbol{X}; \theta, \gamma)\): \(f\) è una funzione di \(\boldsymbol{X}\) con parametri \(\theta, \gamma\). Questa notazione indica che \(\boldsymbol{X}\) sono i dati che vengono passati ad un modello di parametri \(\theta, \gamma\).
\item
  \(\mathcal{N}(\mu, \sigma^2)\): distribuzione gaussiana di media \(\mu\) e varianza \(sigma^2\).
\item
  \(\mbox{Beta}(\alpha, \beta)\): distribuzione Beta di parametri \(\alpha\) e \(\beta\).
\item
  \(\mathcal{U}(a, b)\): distribuzione uniforme con limite inferiore \(a\) e limite superiore \(b\).
\item
  \(\mbox{Cauchy}(\alpha, \beta)\): distribuzione di Cauchy di parametri \(\alpha\) (posizione: media) e \(\beta\) (scala: radice quadrata della varianza).
\item
  \(\mathcal{B}(p)\): distribuzione di Bernoulli di parametro \(p\) (probabilità di successo).
\item
  \(\mbox{Bin}(n, p)\): distribuzione binomiale di parametri \(n\) (numero di prove) e \(p\) (probabilità di successo).
\item
  \(\mathbb{KL} (p \mid\mid q)\): la divergenza di Kullback-Leibler da \(p\) a \(q\).
\end{itemize}

\hypertarget{numeri-binari-interi-razionali-irrazionali-e-reali}{%
\chapter{Numeri binari, interi, razionali, irrazionali e reali}\label{numeri-binari-interi-razionali-irrazionali-e-reali}}

\hypertarget{numeri-binari}{%
\section{Numeri binari}\label{numeri-binari}}

I numeri più semplici sono quelli binari, cioè zero o uno. Useremo spesso numeri binari per indicare se qualcosa è vero o falso, presente o assente. I numeri binari sono molto utili per ottenere facilmente delle statistiche riassuntive in \(\R\).Supponiamo di chiedere a 10 studenti ``Ti piacciono i mirtilli?'' Poniamo che le risposte siano le seguenti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{opinion }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}
  \StringTok{"Yes"}\NormalTok{, }\StringTok{"No"}\NormalTok{, }\StringTok{"Yes"}\NormalTok{, }\StringTok{"No"}\NormalTok{, }\StringTok{"Yes"}\NormalTok{, }\StringTok{"No"}\NormalTok{, }\StringTok{"Yes"}\NormalTok{,}
  \StringTok{"Yes"}\NormalTok{, }\StringTok{"Yes"}\NormalTok{, }\StringTok{"Yes"}
\NormalTok{)}
\NormalTok{opinion}
\CommentTok{\#\textgreater{}  [1] "Yes" "No"  "Yes" "No"  "Yes" "No"  "Yes" "Yes"}
\CommentTok{\#\textgreater{}  [9] "Yes" "Yes"}
\end{Highlighting}
\end{Shaded}

Tali risposte possono essere ricodificate nei termini di valori di verità, ovvero, vero e falso, generalmente denotati rispettivamente come 1 e 0. In \(\R\) tale ricodifica può essere effettuata mediante l'operatore \texttt{==} che è un test per l'uguaglianza e restituisce il valore logico VERO se i due oggetti valutati sono uguali e FALSO se non lo sono:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{opinion }\OtherTok{\textless{}{-}}\NormalTok{ opinion }\SpecialCharTok{==} \StringTok{"Yes"}
\NormalTok{opinion}
\CommentTok{\#\textgreater{}  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE}
\CommentTok{\#\textgreater{}  [9]  TRUE  TRUE}
\end{Highlighting}
\end{Shaded}

R considera i valori di verità e i numeri binari in modo equivalente, con TRUE uguale a 1 e FALSE uguale a zero. Di conseguenza, possiamo effettuare operazioni algebriche sui valori logici VERO e FALSO. Nell'esempio, possiamo sommare i valori di verità e dividere per 10

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(opinion) }\SpecialCharTok{/} \FunctionTok{length}\NormalTok{(opinion)}
\CommentTok{\#\textgreater{} [1] 0.7}
\end{Highlighting}
\end{Shaded}

in modo tale da calcolare una propozione, il che ci consente di concludere che 7 risposte su 10 sono positive.

\hypertarget{numeri-interi}{%
\section{Numeri interi}\label{numeri-interi}}

Un numero intero è un numero senza decimali. Si dicono \textbf{naturali} i numeri che servono a contare, come 1, 2, \ldots{} L'insieme dei numeri naturali si indica con il simbolo \(\mathbb{N}\). È anche necessario introdurre i numeri con il segno per poter trattare grandezze negative. Si ottengono così l'insieme numerico dei numeri interi relativi: \(\mathbb{Z} = \{0, \pm 1, \pm 2, \dots \}\)

\hypertarget{numeri-razionali}{%
\section{Numeri razionali}\label{numeri-razionali}}

I numeri razionali sono i numeri frazionari \(m/n\), dove \(m, n \in N\), con \(n \neq 0\). Si ottengono così i numeri razionali: \(\mathbb{Q} = \{\frac{m}{n} \,\vert\, m, n \in \mathbb{Z}, n \neq 0\}\). È evidente che \(\mathbb{N} \subseteq \mathbb{Z} \subseteq \mathbb{Q}\). Anche in questo caso è necessario poter trattare grandezze negative. I numeri razionali non negativi sono indicati con \(\mathbb{Q^+} = \{q \in \mathbb{Q} \,\vert\, q \geq 0\}\).

\hypertarget{numeri-irrazionali}{%
\section{Numeri irrazionali}\label{numeri-irrazionali}}

Tuttavia, non tutti i punti di una retta \(r\) possono essere rappresentati mediante i numeri interi e razionali. È dunque necessario introdurre un'altra classe di numeri. Si dicono \emph{irrazionali}, e sono denotati con \(\mathbb{R}\), i numeri che possono essere scritti come una frazione \(a / b\), con \(a\) e \(b\) interi e \(b\) diverso da 0. I numeri irrazionali sono i numeri illimitati e non periodici che quindi non possono essere espressi sotto forma di frazione. Per esempio, \(\sqrt{2}\), \(\sqrt{3}\) e \({\displaystyle \pi =3,141592\ldots}\) sono numeri irrazionali.

\hypertarget{numeri-reali}{%
\section{Numeri reali}\label{numeri-reali}}

I punti della retta \(r\) sono quindi ``di più'' dei numeri razionali. Per poter rappresentare tutti i punti della retta abbiamo dunque bisogno dei numeri \emph{reali}. I numeri reali possono essere positivi, negativi o nulli e comprendono, come casi particolari, i numeri interi, i numeri razionali e i numeri irrazionali. Spesso in statisticac il numero dei decimali indica il grado di precisione della misurazione.

\hypertarget{intervalli}{%
\section{Intervalli}\label{intervalli}}

Un intervallo si dice chiuso se gli estremi sono compresi nell'intervallo, aperto se gli estremi non sono compresi. Le caratteristiche degli intervalli sono riportate nella tabella seguente.

\begin{longtable}[]{@{}cll@{}}
\toprule
Intervallo & & \\
\midrule
\endhead
chiuso & \([a, b]\) & \(a \leq x \leq b\) \\
aperto & \((a, b)\) & \(a < x < b\) \\
chiuso a sinistra e aperto a destra & \([a, b)\) & \(a \leq x < b\) \\
aperto a sinistra e chiuso a destra & \((a, b]\) & \(a < x \leq b\) \\
\bottomrule
\end{longtable}

\hypertarget{insiemistica}{%
\chapter{Insiemi}\label{insiemistica}}

Un insieme (o collezione, classe, gruppo, \ldots) è un concetto primitivo, ovvero è un concetto che già possediamo. Georg Cantor l'ha definito nel modo seguente: \emph{un insieme è una collezione di oggetti, determinati e distinti, della nostra percezione o del nostro pensiero, concepiti come un tutto unico; tali oggetti si dicono elementi dell'insieme.}

Mentre non è rilevante la natura degli oggetti che costituiscono l'insieme, ciò che importa è distinguere se un dato oggetto appartenga o meno ad un insieme. Deve essere vera una delle due possibilità: il dato oggetto è un elemento dell'insieme considerato oppure non è elemento dell'insieme considerato. Due insiemi \(A\) e \(B\) si dicono uguali se sono formati dagli stessi elementi, anche se disposti in ordine diverso: \(A=B\). Due insiemi \(A\) e \(B\) si dicono diversi se non contengono gli stessi elementi: \(A \neq B\). Ad esempio, i seguenti insiemi sono uguali:

\[
\{1, 2, 3\} = \{3, 1, 2\} = \{1, 3, 2\}= \{1, 1, 1, 2, 3, 3, 3\}.
\]

Gli insiemi sono denotati da una lettera maiuscola, mentre le lettere minuscole, di solito, designano gli elementi di un insieme. Per esempio, un generico insieme \(A\) si indica con

\[
A = \{a_1, a_2, \dots, a_n\}, \quad \text{con~} n > 0.
\]

La scrittura \(a \in A\) dice che \(a\) è un elemento di \(A\). Per dire che \(b\) non è un elemento di \(A\) si scrive \(b \notin A.\)

Per quegli insiemi i cui elementi soddisfano una certa proprietà che li caratterizza, tale proprietà può essere usata per descrivere più sinteticamente l'insieme:

\[
A = \{x ~\vert~ \text{proprietà posseduta da~} x\},
\]

che si legge come ``\(A\) è l'insieme degli elementi \(x\) per cui è vera la proprietà indicata.'' Per esempio, per indicare l'insieme \(A\) delle coppie di numeri reali \((x,y)\) che appartengono alla parabola \(y = x^2 + 1\) si può scrivere:

\[
A = \{(x,y) ~\vert~ y = x^2 + 1\}.
\]

Dati due insiemi \(A\) e \(B\), diremo che \(A\) è un \emph{sottoinsieme} di \(B\) se e solo se tutti gli elementi di \(A\) sono anche elementi di \(B\):

\[
A \subseteq B \iff (\forall x \in A \Rightarrow x \in B).
\]

Se esiste almeno un elemento di \(B\) che non appartiene ad \(A\) allora diremo che \(A\) è un \emph{sottoinsieme proprio} di \(B\):

\[
A \subset B \iff (A \subseteq B, \exists~ x \in B ~\vert~ x \notin A).
\]

Un altro insieme, detto \emph{insieme delle parti}, o insieme potenza, che si associa all'insieme \(A\) è l'insieme di tutti i sottoinsiemi di \(A\), inclusi l'insieme vuoto e \(A\) stesso. Per esempio, per l'insieme \(A = \{a, b, c\}\), l'insieme delle parti è:

\[
\mathcal{P}(A) = \{
\emptyset, \{a\}, \{b\}, \{c\},
 \{a, b\}, \{a, c\}, \{c, b\},
 \{a, b, c\}
\}.
\]

\hypertarget{operazioni-tra-insiemi}{%
\section{Operazioni tra insiemi}\label{operazioni-tra-insiemi}}

Si definisce \emph{intersezione} di \(A\) e \(B\) l'insieme \(A \cap B\) di tutti gli elementi \(x\) che appartengono ad \(A\) e contemporaneamente a \(B\):

\[
A \cap B = \{x ~\vert~ x \in A \land x \in B\}.
\]

Si definisce \emph{unione} di \(A\) e \(B\) l'insieme \(A \cup B\) di tutti gli elementi \(x\) che appartengono ad \(A\) o a \(B\), cioè

\[
A \cup B = \{x ~\vert~ x \in A \lor x \in B\}.
\]

\emph{Differenza}. Si indica con \(A \setminus B\) l'insieme degli elementi di \(A\) che non appartengono a \(B\):

\[
A \setminus B = \{x ~\vert~ x \in A \land x \notin B\}.
\]

\emph{Insieme complementare}. Nel caso che sia \(B \subseteq A\), l'insieme differenza \(A \setminus B\) è detto insieme complementare di \(B\) in \(A\) e si indica con \(B^C\).

Dato un insieme \(S\), una \emph{partizione} di \(S\) è una collezione di sottoinsiemi di \(S\), \(S_1, \dots, S_k\), tali che

\[
S = S_1 \cup S_2 \cup \dots S_k
\]

e

\[
S_i \cap S_j, \quad \text{con~} i \neq j.
\]

La relazione tra unione, intersezione e insieme complementare è data dalle leggi di DeMorgan:

\[
(A \cup B)^c = A^c \cap B^c,
\] \[
(A \cap B)^c = A^c \cup B^c.
\]

\hypertarget{diagrammi-di-eulero-venn}{%
\section{Diagrammi di Eulero-Venn}\label{diagrammi-di-eulero-venn}}

In molte situazioni è utile servirsi dei cosiddetti diagrammi di Eulero-Venn per rappresentare gli insiemi e verificare le proprietà delle operazioni tra insiemi (si veda la figura \ref{fig:sets-venn-diagrams}. I diagrammi di Venn sono così nominati in onore del matematico inglese del diciannovesimo secolo John Venn anche se Leibnitz e Eulero avevano già in precedenza utilizzato rappresentazioni simili. In tale rappresentazione, gli insiemi sono individuati da regioni del piano delimitate da una curva chiusa. Nel caso di insiemi finiti, è possibile evidenziare esplicitamente alcuni elementi di un insieme mediante punti, quando si possono anche evidenziare tutti gli elementi degli insiemi considerati.

\begin{figure}[h]

{\centering \includegraphics[width=1\linewidth]{images/sets-venn-diagrams} 

}

\caption{In tutte le figure $S$ è la regione delimitata dal rettangolo, $L$ è la regione all'interno del cerchio di sinistra e $R$ è la regione all'interno del cerchio di destra. La regione evidenziata mostra l'insieme indicato sotto ciascuna figura.}\label{fig:sets-venn-diagrams}
\end{figure}

I diagrammi di Eulero-Venn che forniscono una dimostrazione delle leggi di DeMorgan sono forniti nella figura \ref{fig:demorgan}.

\begin{figure}[h]

{\centering \includegraphics[width=1\linewidth]{images/demorgan} 

}

\caption{Dimostrazione delle leggi di DeMorgan.}\label{fig:demorgan}
\end{figure}

\hypertarget{coppie-ordinate-e-prodotto-cartesiano}{%
\section{Coppie ordinate e prodotto cartesiano}\label{coppie-ordinate-e-prodotto-cartesiano}}

Una coppia ordinata \((x,y)\) è l'insieme i cui elementi sono \(x \in A\) e \(y \in B\) e nella quale \(x\) è la prima componente (o prima coordinata), \(y\) la seconda. L'insieme di tutte le coppie ordinate costruite a partire dagli insiemi \(A\) e \(B\) viene detto \textbf{prodotto cartesiano}:

\[
A \times B = \{(x, y) ~\vert~ x \in A \land y \in B\}.
\]

Ad esempio, sia \(A = \{1, 2, 3\}\) e \(B = \{a, b\}\). Allora,

\[
\{1, 2\} \times \{a, b, c\} = \{(1, a), (1, b), (1, c), (2, a), (2, b), (2, c)\}.
\]

\hypertarget{cardinalituxe0}{%
\section{Cardinalità}\label{cardinalituxe0}}

Si definisce \emph{cardinalità} (o potenza) di un insieme finito il numero degli elementi dell'insieme. Viene indicata con \(\vert A\vert, \#(A)\) o \(\text{c}(A)\).

\hypertarget{sommatorie}{%
\chapter{Simbolo di somma (sommatorie)}\label{sommatorie}}

Le somme si incontrano costantemente in svariati contesti matematici e statistici quindi abbiamo bisogno di una notazione adeguata che ci consenta di gestirle. La somma dei primi \(n\) numeri interi può essere scritta come \(1+2+\dots+(n-1)+n\), dove `\(\dots\)' ci dice di completare la sequenza definita dai termini che vengono prima e dopo. Ovviamente, una notazione come \(1+7+\dots+73.6\) non avrebbe alcun senso senza qualche altro tipo di precisazione. In generale, nel seguito incontreremo delle somme nella forma

\begin{equation}
x_1+x_2+\dots+x_n,\notag
\end{equation}

dove \(x_i\) è un numero che è stato definito altrove. La notazione precedente, che fa uso dei tre puntini di sospensione, è utile in alcuni contesti ma in altri risulta ambigua. Pertanto la notazione di uso corrente è del tipo

\begin{equation}
  \sum_{i=1}^n x_i\notag
\end{equation}

e si legge ``sommatoria per \(i\) che va da \(1\) a \(n\) di \(x_i\)''. Il simbolo \(\sum\) (lettera sigma maiuscola dell'alfabeto greco) indica l'operazione di somma, il simbolo \(x_i\) indica il generico addendo della sommatoria, le lettere \(1\) ed \(n\) indicano i cosiddetti \emph{estremi della sommatoria}, ovvero l'intervallo (da \(1\) fino a \(n\) estremi inclusi) in cui deve variare l'indice \(i\) allorché si sommano gli addendi \(x_i\). Solitamente l'estremo inferiore è \(1\) ma potrebbe essere qualsiasi altri numero \(m < n\). Quindi

\[
  \sum_{i=1}^n x_i = x_1 + x_{2} + \dots + x_{n}.
\]

Per esempio, se i valori \(x\) sono \(\{3, 11, 4, 7\}\), si avrà

\[
  \sum_{i=1}^4 x_i = 3+11+4+7 = 25 
\]

laddove \(x_1 = 3\), \(x_2 = 11\), eccetera. La quantità \(x_i\) nella formula precedente si dice l'\emph{argomento} della sommatoria, mentre la variabile \(i\), che prende i valori naturali successivi indicati nel simbolo, si dice \emph{indice} della sommatoria.

La notazione di sommatoria può anche essere fornita nella forma seguente

\begin{equation}
  \sum_{P(i)} x_i\notag
\end{equation}

dove \(P(i)\) è qualsiasi proposizione riguardante \(i\) che può essere vera o falsa. Quando è ovvio che si vogliono sommare tutti i valori di \(n\) osservazioni, la notazione può essere semplificata nel modo seguente: \(\sum_{i} x_i\) oppure \(\sum x_i\). Al posto di \(i\) si possono trovare altre lettere: \(k, j, l, \dots\),.

\hypertarget{manipolazione-di-somme}{%
\section{Manipolazione di somme}\label{manipolazione-di-somme}}

È conveniente utilizzare le seguenti regole per semplificare i calcoli che coinvolgono l'operatore della sommatoria.

\hypertarget{proprietuxe0-1}{%
\subsection{Proprietà 1}\label{proprietuxe0-1}}

La sommatoria di \(n\) valori tutti pari alla stessa costante \(a\) è pari a \(n\) volte la costante stessa:

\[
  \sum_{i=1}^{n} a =  \underbrace{a + a + \dots + a}_{n~\text{volte}} = n a.
  \]

\hypertarget{proprietuxe0-2-proprietuxe0-distributiva}{%
\subsection{Proprietà 2 (proprietà distributiva)}\label{proprietuxe0-2-proprietuxe0-distributiva}}

Nel caso in cui l'argomento contenga una costante, è possibile riscrivere la sommatoria. Ad esempio con

\[
  \sum_{i=1}^{n} a x_i =  a x_1 + a x_2 + \dots + a x_n
  \]

è possibile raccogliere la costante \(a\) e fare \(a(x_1 +x_2 + \dots + x_n)\). Quindi possiamo scrivere

\[
  \sum_{i=1}^{n} a x_i =  a  \sum_{i=1}^{n} x_i.
  \]

\hypertarget{proprietuxe0-3-proprietuxe0-associativa}{%
\subsection{Proprietà 3 (proprietà associativa)}\label{proprietuxe0-3-proprietuxe0-associativa}}

Nel caso in cui

\[
  \sum_{i=1}^{n} (a + x_i) =  (a + x_1) +  (a + x_1) + \dots  (a + x_n)
  \]

si ha che

\[
  \sum_{i=1}^{n} (a + x_i) =  n a + \sum_{i=1}^{n} x_i.
  \]

È dunque chiaro che in generale possiamo scrivere

\[
  \sum_{i=1}^{n} (x_i + y_i) =  \sum_{i=1}^{n} x_i + \sum_{i=1}^{n} y_i.
  \]

\hypertarget{proprietuxe0-4}{%
\subsection{Proprietà 4}\label{proprietuxe0-4}}

Se deve essere eseguita un'operazione algebrica (innalzamento a potenza, logaritmo, ecc.) sull'argomento della sommatoria, allora tale operazione algebrica deve essere eseguita prima della somma. Per esempio,

\[
\sum_{i=1}^{n} x_i^2 = x_1^2 + x_2^2 + \dots + x_n^2 \neq \left(\sum_{i=1}^{n} x_i \right)^2.
\]

\hypertarget{proprietuxe0-5}{%
\subsection{Proprietà 5}\label{proprietuxe0-5}}

Nel caso si voglia calcolare \(\sum_{i=1}^{n} x_i y_i\), il prodotto tra i punteggi appaiati deve essere eseguito prima e la somma dopo:

\[
\sum_{i=1}^{n} x_i y_i = x_1 y_1 + x_2 y_2 + \dots + x_n y_n,
\]

infatti, \(a_1 b_1 + a_2 b_2 \neq (a_1 + a_2)(b_1 + b_2)\).

\hypertarget{doppia-sommatoria}{%
\section{Doppia sommatoria}\label{doppia-sommatoria}}

È possibile incontrare la seguente espressione in cui figurano una doppia sommatoria e un doppio indice:

\[
\sum_{i=1}^{n}\sum_{j=1}^{m} x_{ij}.
\]

La doppia sommatoria comporta che per ogni valore dell'indice esterno, \(i\) da \(1\) ad \(n\), occorre sviluppare la seconda sommatoria per \(j\) da \(1\) ad \(m\). Quindi,

\[
\sum_{i=1}^{3}\sum_{j=4}^{6} x_{ij} = (x_{1, 4} + x_{1, 5} + x_{1, 6}) + (x_{2, 4} + x_{2, 5} + x_{2, 6}) + (x_{3, 4} + x_{3, 5} + x_{3, 6}).
\]

Un caso particolare interessante di doppia sommatoria è il seguente:

\[
\sum_{i=1}^{n}\sum_{j=1}^{n} x_i y_j
\]

Si può osservare che nella sommatoria interna (quella che dipende dall'indice \(j\)), la quantità \(x_i\) è costante, ovvero non dipende dall'indice (che è \(j\)). Allora possiamo estrarre \(x_i\) dall'operatore di sommatoria interna e scrivere

\[
\sum_{i=1}^{n} \left( x_i \sum_{j=1}^{n} y_j \right).
\]

Allo stesso modo si può osservare che nell'argomento della sommatoria esterna la quantità costituita dalla sommatoria in \(j\) non dipende dall'indice \(i\) e quindi questa quantità può essere estratta dalla sommatoria esterna. Si ottiene quindi

\[
\sum_{i=1}^{n}\sum_{j=1}^{n} x_i y_j = \sum_{i=1}^{n} \left( x_i \sum_{j=1}^{n} y_j \right) = \sum_{i=1}^{n}\ x_i \sum_{j=1}^{n} y_j.
\]

\begin{exercise}
Si verifichi quanto detto sopra nel caso particolare di \(x = \{2, 3, 1\}\) e \(y = \{1, 4, 9\}\), svolgendo prima la doppia sommatoria per poi verificare che quanto così ottenuto sia uguale al prodotto delle due sommatorie.

\begin{align}
\sum_{i=1}^3 \sum_{j=1}^3 x_i y_j &= x_1y_1 + x_1y_2 + x_1y_3 + 
x_2y_1 + x_2y_2 + x_2y_3 + 
x_3y_1 + x_3y_2 + x_3y_3 \notag\\
&= 2 \times (1+4+9) + 3 \times (1+4+9) + 2 \times (1+4+9) = 84,\notag
\end{align}

ovvero

\[
(2 + 3 + 1) \times (1+4+9) = 84.
\]
\end{exercise}

\hypertarget{sommatorie-e-produttorie-e-operazioni-vettoriali-in-r}{%
\section{\texorpdfstring{Sommatorie (e produttorie) e operazioni vettoriali in \texttt{R}}{Sommatorie (e produttorie) e operazioni vettoriali in R}}\label{sommatorie-e-produttorie-e-operazioni-vettoriali-in-r}}

Si noti che la notazione

\[
\sum_{n=0}^4 3n
\]

non è altro che un ciclo \texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (n }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) \{}
\NormalTok{  sum }\OtherTok{=}\NormalTok{ sum }\SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ n}
\NormalTok{\}}
\NormalTok{sum}
\CommentTok{\#\textgreater{} [1] 30}
\end{Highlighting}
\end{Shaded}

In maniera equivalente, e più semplice, possiamo scrivere

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\DecValTok{3} \SpecialCharTok{*}\NormalTok{ (}\DecValTok{0}\SpecialCharTok{:}\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 30}
\end{Highlighting}
\end{Shaded}

Allo stesso modo, la notazione

\[
\prod_{n=1}^{4} 2n
\] è anch'essa equivalente al ciclo \texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prod }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{ (n }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) \{}
\NormalTok{  prod }\OtherTok{\textless{}{-}}\NormalTok{ prod }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*}\NormalTok{ n}
\NormalTok{\}}
\NormalTok{prod}
\CommentTok{\#\textgreater{} [1] 384}
\end{Highlighting}
\end{Shaded}

che si può scrivere, più semplicemente, come

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prod}\NormalTok{(}\DecValTok{2} \SpecialCharTok{*}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 384}
\end{Highlighting}
\end{Shaded}

In entrambi i casi precedenti, abbiamo sostituito le operazioni aritmetiche eseguite all'interno di un ciclo \texttt{for} con le stesse operazioni aritmetiche eseguite sui vettori elemento per elemento.

\hypertarget{derivazione-coef-binom}{%
\chapter{Cenni di calcolo combinatorio}\label{derivazione-coef-binom}}

La derivazione del coefficiente binomiale richiede l'uso di alcune nozioni di calcolo combinatorio. Iniziamo con il definire il concetto di permutazione.

\hypertarget{permutazioni-semplici}{%
\section{Permutazioni semplici}\label{permutazioni-semplici}}

Una \emph{permutazione semplice} di un insieme di oggetti è un allineamento di \(n\) oggetti su \(n\) posti nel quale ogni oggetto viene presentato una ed una sola volta. Le permutazioni semplici si indicano con il simbolo \(P_{n}\).

Il numero delle permutazioni semplici di \(n\) elementi distinti è uguale a

\begin{equation}
P_n = n!
\label{eq:permsem}
\end{equation}

Per esempio, nel caso dell'insieme \(A = \{a, b, c\}\), le permutazioni possibili sono:

\begin{center}
$\{a, b, c\}$, $\{a, c, b\}$, $\{b, c, a\}$, $\{b, a, c\}$, $\{c, a, b\}$, $\{c, b, a\}$,
\end{center}

Il numero di permutazioni di \(A\) è

\[
P_n = P_3 = 3! = 3 \cdot 2 \cdot 1 = 6.
\]

\hypertarget{disposizioni-semplici}{%
\section{Disposizioni semplici}\label{disposizioni-semplici}}

Supponiamo ora di voler selezionare una sequenza di \(k\) oggetti da un insieme di \(n\) e che l'ordine degli oggetti abbia importanza. Si chiamano \emph{disposizioni semplici} di \(n\) elementi distinti presi a \(k\) a \(k\) (o disposizioni della classe \(k\)) tutti i raggruppamenti che si possono formare con gli oggetti dati in modo che qualsiasi raggruppamento ne contenga \(k\) tutti distinti tra loro (ovvero, senza ripetizione) e che due raggruppamenti differiscano tra loro per qualche oggetto oppure per l'ordine secondo il quale gli oggetti si susseguono. Le disposizioni semplici della classe \(k\) si indicano con \(D_{n,k}\).

Il numero delle disposizioni semplici di \(n\) elementi distinti della classe \(k\) è uguale a

\begin{equation}
D_{n,k} = \frac{n!}{(n-k)!}.
\label{eq:dispsemp}
\end{equation}

Per esempio, nel caso dell'insieme: \(A = \{a, b, c\}\), le disposizioni semplici di classe 2 sono:

\begin{center}
$\{a, b\}$, $\{b, a\}$, $\{a, c\}$, $\{c, a\}$, $\{b, c\}$, $\{c, b\}$
\end{center}

Il numero di disposizioni semplici di classe 2 è

\[
D_{n,k} = \frac{n!}{(n-k)!} = 3 \cdot 2 = 6.
\]

\hypertarget{combinazioni-semplici}{%
\section{Combinazioni semplici}\label{combinazioni-semplici}}

Avendo trovato il modo per contare il numero delle disposizioni semplici di \(n\) elementi distinti della classe \(k\), dobbiamo ora trasformare la \eqref{eq:dispsemp} in modo da ignorare l'ordine degli elementi di ciascun sottoinsieme. Le \emph{combinazioni semplici} di \(n\) elementi a \(k\) a \(k\) (\(k \leq n\)) sono tutti i sottoinsiemi di \(k\) elementi di un dato insieme di \(n\) elementi, tutti distinti tra loro. Le combinazioni semplici differiscono dalle disposizioni semplici per il fatto che le disposizioni semplici tengono conto dell'ordine di estrazione mentre nelle combinazioni semplici si considerano distinti solo i raggruppamenti che differiscono almeno per un elemento.

Gli elementi di ciascuna combinazione di \(k\) oggetti possono essere ordinati tra loro in \(k!\) modi diversi, per cui il numero delle combinazioni semplici è dato dal numero di disposizioni semplici \(D_{n,k}\) diviso per il numero di permutazioni semplici \(P_k\) dei \(k\) elementi. Il numero delle combinazioni semplici di \(n\) elementi distinti della classe \(k\) è dunque uguale a

\begin{equation}
C_{n,k} = \frac{D_{n,k}}{P_k} = \frac{n!}{k!(n-k)!}.
\label{eq:combsemp}
\end{equation}

Il numero delle combinazioni semplici \(C_{n,k}\) è spesso detto coefficiente binomiale e indicato con il simbolo \(\binom{n}{k}\) che si legge ``\(n\) su \(k\)''.

Per l'insieme \(A = \{a, b, c\}\), le combinazioni semplici di classe 2 sono

\begin{center}
$\{a, b\}$, $\{a, c\}$, $\{b, c\}$,
\end{center}

Il numero di combinazioni semplici di classe 2 è dunque uguale a tre: \[
C_{n,k} = \binom{n}{k} = \binom{3}{2} = 3.
\]

\hypertarget{funs-exp-log}{%
\chapter{Esponenziali e logaritmi}\label{funs-exp-log}}

\hypertarget{potenze-ad-esponente-reale}{%
\section*{Potenze ad esponente reale}\label{potenze-ad-esponente-reale}}


Per un qualsiasi numero razionale \(\frac{m}{n}\) (in cui \(n > 0\)) si ha

\[
a^{\frac{m}{n}} = \sqrt[n]{a^m}
\] per numeri \(a\) reali positivi.

\hypertarget{proprietuxe0}{%
\subsection*{Proprietà}\label{proprietuxe0}}


Se \(a\), \(b\) sono reali positivi ed \(x\), \(y\) reali qualsiasi, si ha

\begin{itemize}
\tightlist
\item
  \(a^0 = 1\) e \(a^{-x} = \frac{1}{a^x}\),
\item
  \(a^x a^y = a^{x+y}\) e \(\frac{a^x}{a^y} = a^{x-y}\),
\item
  \(a^x b^x = (ab)^{x}\) e \(\frac{a^x}{b^x} = \left(\frac{a}{b}\right)^x\),
\item
  \((a^x)^y = a^{xy}\).
\end{itemize}

\hypertarget{funzione-esponenziale}{%
\section{Funzione esponenziale}\label{funzione-esponenziale}}

\begin{definition}
La funzione esponenziale con base \(a\) è \begin{equation}
f(x) = a^x
\end{equation}

dove \(a > 0\), \(a \neq 1\) e \(x\) è qualsiasi numero reale.
\end{definition}

La base \(a = 1\) è esclusa perché produce \(f(x) = 1^x = 1\), la quale è una costante, non una funzione esponenziale.

Per esempio, un grafico della funzione esponenziale di base 2 si trova con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base2 }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(x)\{}\DecValTok{2}\SpecialCharTok{\^{}}\NormalTok{x\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base2)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-23-1} \end{center}

Se usiamo la base 4 troviamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base4 }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(x)\{}\DecValTok{4}\SpecialCharTok{\^{}}\NormalTok{x\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base4)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-24-1} \end{center}

Oppure

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base4 }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(x)\{}\DecValTok{4}\SpecialCharTok{\^{}{-}}\NormalTok{\{x\}\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base4)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-25-1} \end{center}

In molte applicazioni la scelta più conveniente per la base è il numero irrazionale \(e = 2.718281828\dots\). Questo numero è chiamato la \emph{base naturale}. La funzione \(f(x) = e^x\) è chiamata \emph{funzione esponenziale naturale}.

Per esempio, abbiamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base\_e}\OtherTok{=} \ControlFlowTok{function}\NormalTok{(x)\{}\FunctionTok{exp}\NormalTok{(x)\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{, }\FloatTok{1.5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base\_e)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-26-1} \end{center}

\hypertarget{logaritmi}{%
\section*{Logaritmi}\label{logaritmi}}


Dati due numeri reali \(b > 0\) e \(a > 0\) con \(a \neq 1\), l'equazione esponenziale \(a^x = b\) ammette sempre una ed una sola soluzione. Tale soluzione è detta \emph{logaritmo in base \(a\) di \(b\)} ed è indicata con la scrittura \(\log_a b\), dove \(b\) è detto \emph{argomento} del logaritmo. In altri termini, per definizione si ha

\[
x = \log_a b \Longleftrightarrow a^x = b
\]

\[
\text{dove deve essere } a > 0, \ a \neq 1,\ b > 0.
\]

Quando valutiamo i logaritmi, dobbiamo ricordare che un logaritmo è un esponente: il logaritmo in base \(a\) di \(b\), \(\log_a b\), è l'esponente da attribuire alla base \(a\) per ottenere l'argomento \(b\). Le seguenti equazioni sono dunque equivalenti:

\begin{equation}
y = \log_a x \qquad x = a^y.\notag
\end{equation}

La prima equazione è in forma logaritmica e la seconda è in forma esponenziale. Ad esempio, l'equazione logaritmica \(2 = \log_3 9\) può essere riscritta in forma esponenziale come \(9 = 3^2\).

\begin{example}

Scrivendo l'argomento come potenza della base si ottiene

\begin{itemize}
\tightlist
\item
  \(\log_2 8 = \log_2 2^3 = 3\)
\item
  \(\log_3 \sqrt[7]{3^{20}} = \log_3 3^{\frac{20}{7}} = \frac{20}{7}\)
\item
  \(\log_{0.1} 0.01 = \log_{\frac{1}{10}}\frac{1}{100} = \log_{\frac{1}{10}}\left(\frac{1}{10}\right)^2 = 2\)
\end{itemize}

\end{example}

\hypertarget{proprietuxe0-2}{%
\subsection*{Proprietà}\label{proprietuxe0-2}}


Nell'operare con i logaritmi si procede spesso mediante le loro proprietà, che costituiscono una rilettura in termini di logaritmi delle proprietà delle potenze: se \(a\), \(b\) sono numeri reali positivi diversi da 1 ed \(x\), \(y\) reali positivi qualunque, allora

\begin{itemize}
\tightlist
\item
  \(\log_a (xy) = \log_a x + \log_a y\),
\item
  \(\log_a \left(\frac{x}{y}\right) = \log_a x - \log_a y\),
\item
  \(\log_a \left(x^{\alpha}\right) = \alpha \log_a x, \quad \forall \alpha \ \text{reale}\),
\item
  \(\log_a x = \frac{\log_b x}{\log_b a}\) (cambiamento di base).
\end{itemize}

\begin{example}
\begin{align}
\log_a (x+1) -\log_a x - 2 \log_a 2 &= \log_a (x+1) - (\log_a x+ \log_a 2^2)\notag\\
&= \log_a (x+1) - \log_a 4x\notag\\
&= \log_a \frac{x+1}{4x}.\notag
\end{align}
\end{example}

\hypertarget{funzione-logaritmica}{%
\section{Funzione logaritmica}\label{funzione-logaritmica}}

La funzione logaritmica è la funzione inversa della funzione esponenziale.

\begin{definition}
Siano \(a > 0\), \(a \neq 1\). Per \(x > 0\)

\begin{equation}
y = \log_a x \quad \text{se e solo se } x = a^y.
\end{equation}

La funzione data da

\begin{equation}
f(x) = \log_a x
\end{equation}

è chiamata funzione logaritmica.
\end{definition}

Per esempio, abbiamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log\_funct }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
  \FunctionTok{log}\NormalTok{(x)}
\NormalTok{\}}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.5}\NormalTok{, }\DecValTok{4}\NormalTok{)), }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ log\_funct) }\SpecialCharTok{+} 
  \FunctionTok{xlim}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)) }\SpecialCharTok{+} 
  \FunctionTok{ylim}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{x =} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ x"}\NormalTok{, }\AttributeTok{y =} \StringTok{"y }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{annotate}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\AttributeTok{x =} \DecValTok{3}\NormalTok{, }\AttributeTok{y =} \DecValTok{3}\NormalTok{, }\AttributeTok{parse =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{size =} \DecValTok{5}\NormalTok{, }\AttributeTok{fontface =} \StringTok{"bold"}\NormalTok{,}
           \AttributeTok{label=}\StringTok{"y == log(x)"}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{geom\_hline}\NormalTok{(}\AttributeTok{yintercept =} \DecValTok{0}\NormalTok{, }\AttributeTok{colour =} \StringTok{"gray"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_vline}\NormalTok{(}\AttributeTok{xintercept =} \DecValTok{0}\NormalTok{, }\AttributeTok{colour =} \StringTok{"gray"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-27-1} \end{center}

\hypertarget{gauss-normale}{%
\chapter{La Normale motivata dal metodo dei minimi quadrati}\label{gauss-normale}}

La distribuzione Normale fu scoperta da Gauss nel 1809 e, nella derivazione di Gauss, è intimamente legata al metodo dei minimi quadrati. Vediamo come Gauss arrivò alla definizione della densità Normale.

Tra il 1735 e il 1754 l'Accademia di Francia effettuò quattro misurazioni della lunghezza di un arco di meridiano a latitudini diverse con lo scopo di determinare la figura della Terra.\footnote{L'espressione ``figura della Terra'' è utilizzata in geodesia per indicare la precisione con cui sono definite la dimensione e la forma della Terra.} Papa Benedetto XIV volle contribuire a questo progetto e nel 1750 incaricò Roger Joseph Boscovich (1711---1787) e il gesuita inglese Christopher Maire di misurare un arco di meridiana nei pressi di Roma e contemporaneamente di costruire una nuova mappa dello Stato Pontificio. Il loro rapporto fu pubblicato nel 1755.

La relazione tra lunghezza d'arco e latitudine per archi piccoli è approssimativamente \(y = \alpha + \beta x\), dove \(y\) è la lunghezza dell'arco e \(x = sin^2L\), dove \(L\) è la latitudine del punto medio dell'arco. Il problema di Boscovich era quello di stimare \(\alpha\) e \(\beta\) da cinque osservazioni di \((x, y)\).

Nel 1757 pubblicò una sintesi del rapporto del 1755 in cui proponeva di risolvere il problema di riconciliare le relazioni lineari inconsistenti mediante la minimizzazione della somma dei valori assoluti dei residui, sotto il vincolo che la somma dei residui fosse uguale a zero. In altre parole, Boscovich propose di minimizzare la quantità \(\sum \mid y_i - a - b x_i \mid\) rispetto ad \(a\) e \(b\) sotto il vincolo \((y_i - a - b x_i) = 0\). Boscovich fu il primo a formulare un metodo per adattare una retta ai dati descritti da un diagramma a dispersione, laddove l'orientamento della retta dipende dalla minimizzazione di una funzione dei residui. La formulazione e la soluzione di Boscovich erano puramente verbali ed era accompagnata da un diagramma che spiegava il metodo di minimizzazione.

Nella \emph{Mécanique Céleste}, Laplace (1749, 1827) ritornò sul problema di Boscovich e mostrò in maniera formale come sia possibile minimizzare la quantità \(\sum w_i \mid y_i - a - b x_i \mid\). Il metodo della minimizzazione del valore assoluto degli scarti presentava degli svantaggi rispetto al metodo dei minimi quadrati: (1) la stima della pendenza della retta era complicata da calcolare e (2) il metodo era limitato a una sola variabile indipendente. Il metodo scomparve quindi dalla pratica statistica fino alla seconda metà del XX secolo quando venne riproposto nel contesto della discussione della robustezza delle stime.

In seguito, tale problema venne ripreso da Legendre. Il suo \emph{Nouvelle methods pour la determinazione des orbites des comètes} contiene un'appendice (pp.~72-80) intitolata \emph{Sur la méthode des moindres carrés}, in cui per la prima volta il metodo dei minimi quadrati viene presentato come un metodo algebrico per l'adattamento di un modello lineare ai dati. Legendre scrive \emph{``Tra tutti i princìpi che si possono proporre a questo scopo, credo che non ce ne sia uno più generale, più esatto e più facile da applicare di quello di cui ci siamo serviti nelle precedenti ricerche, e che consiste nel minimizzare la somma dei quadrati degli errori. In questo modo si stabilisce una sorta di equilibrio tra gli errori, che impedisce agli estremi di prevalere e ben si presta a farci conoscere lo stato del sistema più vicino alla verità.''}

La somma dei quadrati degli errori è

\[
\sum_{i=1}^n e_i^2 = (y_i - a - b_1x_{i1} - \dots - b_m x_{im})^2.
\]

Per trovare il minimo di tale funzione, Legendre pone a zero le derivate della funzione rispetto ad \(a, b_1, \dots, b_m\), il che conduce a quelle che in seguito sono state chiamate le ``equazioni normali''. Risolvendo il sistema di equazioni normali rispetto \(a, b_1, \dots, b_m\), si determinano le stime dei minimi quadrati dei parametri del modello di regressione.

Tutto questo è rilevante per la derivazione della Normale perché, in questo contesto, Legendre osservò che la media aritmetica, quale caso speciale dei minimi quadrati, si ottiene minimizzando \(\sum(y_i - b)^2\). In precedenza, Laplace si era posto il problema di mostrare che la media aritmetica è la migliore stima possibile della tendenza centrale di una distribuzione di errori di misurazione, ma non ci era riuscito perché aveva minimizzato il valore assoluto degli scarti, il che portava ad identificare la mediana quale migliore stimatore della tendenza centrale della distribuzione degli errori, non la media.

Nel 1809, Gauss riformulò il problema ponendosi le seguenti domande. Che forma deve avere la densità della distribuzione degli errori? Quale quantità deve essere minimizzata per fare in modo che la media aritmetica risulti la miglior stima possibile della tendenza centrale della distribuzione degli errori? \emph{``Si è soliti considerare come un assioma l'ipotesi che se una qualsiasi grandezza è stata determinata da più osservazioni dirette, fatte nelle stesse circostanze e con uguale cura, la media aritmetica dei valori osservati dà il valore più probabile, se non rigorosamente, eppure con una grade approssimazione, così che è sempre più sicuro utilizzare tale valore.''}

Basandosi sul risultato di Legendre (ovvero, che è necessario minimizzare il quadrato degli scarti dalla tendenza centrale, non il valore assoluto degli scarti), Gauss derivò la formula della densità Normale quale modello teorico della distribuzione degli errori di misurazione. La Normale ha infatti la proprietà desiderata: il valore atteso della distribuzione corrisponde alla media aritmetica.

La scoperta della distribuzione normale segna l'inizio di una nuova era nella statistica. La distribuzione Normale è importante, in primo luogo, perché molti fenomeni naturali hanno approssimativamente le caratteristiche descritte dall'esempio precedente. In secondo luogo, è importante perché molti modelli statistici assumono che il fenomeno aleatorio di interesse abbia una distribuzione Normale.

Nella derivazione della Normale, Gauss fornì una giustificazione probabilistica al metodo dei minimi quadrati basata sull'ipotesi che le osservazioni siano distribuite normalmente e che la distribuzione a priori del parametro di tendenza centrale sia uniforme. Si noti come la discussione sia formulata in termini bayesiani.

La derivazione formale della Normale è troppo complessa per gli scopi presenti. Il Paragrafo \ref{normal-random-walk} illustra invece come si possa giungere alla Normale mediante una simulazione. La motivazione del presente escursus storico è stata quella di mostrare come la Normale sia fortemente legata, in un contesto storico, al modello lineare e al metodo dei minimi quadrati.

\hypertarget{appendix:max-like}{%
\chapter{La stima di massima verosimiglianza}\label{appendix:max-like}}

\hypertarget{derivation-smv-prop}{%
\section{La s.m.v. per una proporzione}\label{derivation-smv-prop}}

La s.m.v. della proporzione di successi \(\theta\) in una sequenza di prove Bernoulliane è uguale data dalla proporzione di successi campionari. Questo risultato può essere dimostrato come segue.

\begin{proof}
Per \(n\) prove Bernoulliane indipendenti, le quali producono \(y\) successi e (\(n-y\)) insuccessi, la funzione nucleo (ovvero, la funzione di verosimiglianza da cui sono state escluse tutte le costanti moltiplicative che non hanno alcun effetto su \(\hat{\theta}\)) è

\[
\mathcal{L}(p \mid y) = \theta^y (1-\theta)^{n - y}.\notag
\] La funzione nucleo di log-verosimiglianza è

\[
\begin{aligned}
\ell(\theta \mid y) &= \log \mathcal{L}(\theta \mid y) \notag\\
          &= \log \left(\theta^y (1-\theta)^{n - y} \right) \notag\\
          &= \log \theta^y + \log \left( (1-\theta)^{n - y} \right) \notag\\
          &= y \log \theta + (n - y) \log (1-\theta).\notag
\end{aligned}
\]

Per calcolare il massimo della funzione di log-verosimiglianza è necessario differenziare \(\ell(\theta \mid y)\) rispetto a \(\theta\), porre la derivata a zero e risolvere. La derivata di \(\ell(\theta \mid y)\) è:

\[
\ell'(\theta \mid y) = \frac{y}{\theta} -\frac{n-y}{1-\theta}.
\]

Ponendo l'equazione uguale a zero e risolvendo otteniamo la s.m.v.:

\begin{equation}
  \hat{\theta} = \frac{y}{n},
  \label{eq:mlprop}
\end{equation}

ovvero la frequenza relativa dei successi nel campione.
\end{proof}

\hypertarget{calcolo-numerico}{%
\subsection*{Calcolo numerico}\label{calcolo-numerico}}


In maniera più semplice, il risultato descritto nel Paragrafo \ref{derivation-smv-prop} può essere ottenuto mediante una simulazione in \R. Iniziamo a definire un insieme di valori possibili per il parametro incognito \(\theta\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{theta }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length.out =} \FloatTok{1e3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Sappiamo che la funzione di verosimiglianza è la funzione di massa di probabilità espressa in funzione del parametro sconosciuto \(\theta\) assumendo come noti i dati. Questo si può esprimere in \(\R\) nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{like }\OtherTok{\textless{}{-}} \FunctionTok{dbinom}\NormalTok{(}\AttributeTok{x =} \DecValTok{23}\NormalTok{, }\AttributeTok{size =} \DecValTok{30}\NormalTok{, }\AttributeTok{prob =}\NormalTok{ theta)}
\end{Highlighting}
\end{Shaded}

Si noti che, nell'istruzione precedente, abbiamo passato alla funzione \texttt{dbinom()} i dati, ovvero \texttt{x\ =\ 23} successi in \texttt{size\ =\ 30} prove. Inoltre, abbiamo passato alla funzione il vettore \texttt{prob\ =\ theta} che contiene 1000 valori possibili per il parametro \(\theta \in [0, 1]\). Per ciascuno dei valori \(\theta\), la funzione \texttt{dbinom()} ritorna un valore che corrisopnde all'ordinata della funzione di verosimiglianza, tenendo sempre costanti i dati (ovvero, 6 successi in 9 prove). Un grafico della funzione di verosimiglianza è dato da:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(theta, like) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ theta, }\AttributeTok{y =}\NormalTok{ like)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{y =} \FunctionTok{expression}\NormalTok{(}\FunctionTok{L}\NormalTok{(theta)),}
    \AttributeTok{x =} \FunctionTok{expression}\NormalTok{(}\StringTok{\textquotesingle{}Valori possibili di\textquotesingle{}} \SpecialCharTok{\textasciitilde{}}\NormalTok{ theta)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-31-1} \end{center}

Nella simulazione, il valore \(\theta\) che massimizza la funzione di verosimiglianza può essere trovato nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{theta[}\FunctionTok{which.max}\NormalTok{(like)]}
\CommentTok{\#\textgreater{} [1] 0.7668}
\end{Highlighting}
\end{Shaded}

Il valore così trovato è uguale al valore definito dalla \eqref{eq:mlprop}.

\hypertarget{derivation-smv-norm}{%
\section{La s.m.v. del modello Normale}\label{derivation-smv-norm}}

Ora che abbiamo capito come costruire la funzione verosimiglianza di una binomiale è relativamente semplice fare un passo ulteriore e considerare la verosimiglianza del caso di una funzione di densità, ovvero nel caso di una variabile casuale continua. Consideriamo qui il caso della Normale.

\begin{proof}
La densità di una distribuzione Normale di parametri \(\mu\) e \(\sigma\) è

\[
f(y \mid \mu, \sigma) = \frac{1}{\sigma \sqrt{2\pi}} \exp\left\{-\frac{1}{2\sigma^2}(y-\mu)^2\right\}.
\label{eq:gausslike}
\]

Poniamoci il problema di trovare la s.m.v. dei parametri sconosciuti \(\mu\) e \(\sigma\) nel caso in cui le \(n\) osservazioni \(y = (y_1, \dots, y_n)\) sono realizzazioni indipendenti ed identicamente distribuite (di seguito, i.i.d.) della medesima variabile casuale \(Y \sim \mathcal{N}(\mu, \sigma)\). Per semplicità, scriveremo \(\theta = \{\mu, \sigma\}.\)

Il campione osservato è un insieme di eventi, ciascuno dei quali corrisponde alla realizzazione di una variabile casuale --- possiamo pensare ad uno di tali eventi come all'estrazione casuale di un valore dalla ``popolazione'' \(\mathcal{N}(\mu, \sigma)\). Se le variabili casuali sono i.i.d., la loro densità congiunta è data da:

\begin{align}
f(y \mid \theta) &= f(y_1 \mid \theta) \cdot f(y_2 \mid \theta) \cdot \; \dots \; \cdot f(y_n \mid \theta)\notag\\
                 &= \prod_{i=1}^n f(y_i \mid \theta),
\label{eq:gauss-prob-cong}
\end{align}

laddove la funzione \(f(\cdot)\) è la \eqref{eq:gausslike}. Tenendo costanti i dati \(y\), la funzione di verosimiglianza è:

\begin{equation}
\mathcal{L}(\theta \mid y) = \prod_{i=1}^n f(y_i \mid \theta).
\label{eq:gausslike2}
\end{equation}

L'obiettivo è quello di massimizzare la funzione di verosimiglianza per trovare i valori \(\theta\) ottimali. Usando la notazione matematica questo si esprime dicendo che cerchiamo l'argmax della \eqref{eq:gausslike2} rispetto a \(\theta\), ovvero

\[
\hat{\theta} = \text{argmax}_{\theta} \prod_{i=1}^n f(y_i \mid \theta).
\]

Questo problema si risolve calcolando le derivate della funzione rispetto a \(\theta\), ponendo le derivate uguali a zero e risolvendo. Saltando tutti i passaggi algebrici di questo procedimento, per \(\mu\) troviamo

\begin{equation}
\hat{\mu} = \frac{1}{n} \sum_{i=1}^n y_i
\label{eq:maxlikemu}
\end{equation}

e per \(\sigma\) abbiamo

\begin{equation}
\hat{\sigma} = \sqrt{\sum_{i=1}^n\frac{1}{n}(y_i- \mu)^2}.
\label{eq:maxlikesigma}
\end{equation}

In altri termini, la s.m.v. del parametro \(\mu\) è la media del campione e la s.m.v. del parametro \(\sigma\) è la deviazione standard del campione.
\end{proof}

\hypertarget{calcolo-numerico-1}{%
\section*{Calcolo numerico}\label{calcolo-numerico-1}}


Consideriamo ora un esempio che utilizza dei dati reali. I dati corrispondono ai valori BDI-II dei trenta soggetti del campione clinico di \citet{zetschefuture2019}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{y =} \FunctionTok{c}\NormalTok{(}
    \DecValTok{26}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{44}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{30}\NormalTok{, }
    \DecValTok{26}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{41}\NormalTok{, }\DecValTok{36}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{22}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ci poniamo l'obiettivo di creare la funzione di verosimiglianza per questi dati, supponendo, in base ai risultati di ricerche precedenti, di sapere che i punteggi BDI-II si distribuiscono secondo una legge Normale.

Per semplificare il problema, assumeremo di conoscere \(\sigma\) (lo porremo uguale alla deviazione standard del campione) in modo da avere un solo parametro sconosciuto, cioè \(\mu\). Il problema è dunque quello di trovare la funzione di verosimiglianza per il parametro \(\mu\), date le 30 osservazioni del campione e dato \(\sigma = s = 6.61\).

Per una singola osservazione, la funzione di verosimiglianza è la densità Normale espressa in funzione dei parametri. Per un campione di osservazioni i.i.d., ovvero \(y = (y_1, y_2, \dots, y_n)\), la verosimiglianza è la funzione di densità congiunta \(f(y \mid \mu, \sigma)\) espressa in funzione dei parametri, ovvero \(\mathcal{L}(\mu, \sigma \mid y)\). Dato che le osservazioni sono i.i.d., la densità congiunta è data dal prodotto delle densità delle singole osservazioni. Per semplicità, assumiamo \(\sigma\) noto e uguale alla deviazione standard del campione:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{true\_sigma }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y)}
\NormalTok{true\_sigma }
\CommentTok{\#\textgreater{} [1] 6.607}
\end{Highlighting}
\end{Shaded}

Avendo posto \(\sigma = 6.61\), per una singola osservazione \(y_i\) abbiamo

\[
f(y_i \mid \mu, \sigma) = \frac{1}{{6.61 \sqrt {2\pi}}}\exp\left\{{-\frac{(y_i - \mu)^2}{2\cdot 6.61^2}}\right\},\notag
\]

dove il pedice \(i\) specifica l'osservazione \(y_i\) tra le molteplici osservazioni \(y\), e \(\mu\) è il parametro sconosciuto che deve essere determinato (nell'esempio, \(\sigma = s\)). La densità congiunta è dunque

\[
f(y \mid \mu, \sigma) = \, \prod_{i=1}^n f(y_i \mid \mu, \sigma)\notag
\] e, alla luce dei dati osservati, la verosimiglianza diventa

\[
\begin{aligned}
\mathcal{L}(\mu, \sigma \mid y) =& \, \prod_{i=1}^n f(y_i \mid \mu, \sigma) = \notag\\
& \frac{1}{{6.61 \sqrt {2\pi}}}\exp\left\{{-\frac{(26 - \mu)^2}{2\cdot 6.61^2}}\right\} \times \notag\\
 & \frac{1}{{6.61 \sqrt {2\pi}}}\exp\left\{{-\frac{(35 - \mu)^2}{2\cdot 6.61^2}}\right\} \times  \notag\\
& \vdots \notag\\
 & \frac{1}{{6.61 \sqrt {2\pi}}}\exp\left\{{-\frac{(22 - \mu)^2}{2\cdot 6.61^2}}\right\}.
\end{aligned}
\label{eq:lldepression}
\]

Poniamoci ora il problema di rappresentare graficamente la funzione di verosimiglianza per il parametro \(\mu\). Avendo un solo parametro sconosciuto, possiamo rappresentare la verosimiglianza con una curva. In \R, definiamo la funzione di log-verosimiglianza nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log\_likelihood }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(y, mu, }\AttributeTok{sigma =}\NormalTok{ true\_sigma) \{}
  \FunctionTok{sum}\NormalTok{(}\FunctionTok{dnorm}\NormalTok{(y, mu, sigma, }\AttributeTok{log =} \ConstantTok{TRUE}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Nella funzione \texttt{log\_likelihood()}, \texttt{y} è un vettore che, nel caso presente contiene \(n = 30\) valori. Per ciascuno di questi valori, la funzione \texttt{dnorm()} trova la densità Normale utilizzando il valore \(\mu\) che passato a \texttt{log\_likelihood()} e il valore \(\sigma\) uguale a 6.61 --- nell'esempio, questo parametro viene assunto come noto. L'argomento \texttt{log\ =\ TRUE} specifica che deve essere preso il logaritmo. La funzione \texttt{dnorm()} è un argomento della funzione \texttt{sum()}. Ciò significa che i 30 valori così trovati, espressi su scala logaritmica, verranno sommati --- sommare logaritmi è equivalente a fare il prodotto dei valori sulla scala originaria.

Se applichiamo questa funzione ad un solo valore \(\mu\) otteniamo l'ordinata della funzione di log-verosimiglianza in corrispondenza del valore \(\mu\) (si veda la figura \eqref{eq:lldepression}). Si noti che, per trovare un tale valore, abbiamo utilizzato le seguenti informazioni:

\begin{itemize}
\tightlist
\item
  i 30 dati del campione,
\item
  il valore \(\sigma = s\) fissato a 6.61,
\item
  il singolo valore \(\mu\) passato alla funzione \texttt{log\_likelihood()}.
\end{itemize}

Avendo trovato un singolo punto della funzione di log-verosimiglianza, dobbiamo ripetere i calcoli precedenti per tutti i possibili valori che \(\mu\) può assumere. Nel seguente ciclo \texttt{for()} viene calcolata la log-verosimiglianza di 100,000 valori possibili del parametro \(\mu\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nrep }\OtherTok{\textless{}{-}} \FloatTok{1e5}
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}
  \FunctionTok{mean}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y) }\SpecialCharTok{{-}} \FunctionTok{sd}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y), }
  \FunctionTok{mean}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y) }\SpecialCharTok{+} \FunctionTok{sd}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y), }
  \AttributeTok{length.out =}\NormalTok{ nrep}
\NormalTok{)}

\NormalTok{ll }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\ConstantTok{NA}\NormalTok{, nrep)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nrep) \{}
\NormalTok{  ll[i] }\OtherTok{\textless{}{-}} \FunctionTok{log\_likelihood}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y, mu[i], true\_sigma)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Il vettore \texttt{mu} contiene 100,000 possibili valori del parametro \(\mu\); tali valori sono stati scelti nell'intervallo \(\bar{y} \pm s\). Per ciascuno di questi valori la funzione \texttt{log\_likelihood()} calcola il valore di log-verosimiglianza. I 100,000 risultati vengono salvati nel vettore \texttt{ll}.

I vettori \texttt{mu} e \texttt{ll} possono dunque essere usati per disegnare il grafico della funzione di log-verosimiglianza per il parametro \(\mu\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(mu, ll) }\SpecialCharTok{\%\textgreater{}\%} 
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ mu, }\AttributeTok{y =}\NormalTok{ ll)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{vline\_at}\NormalTok{(}\FunctionTok{mean}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{y), }\AttributeTok{color =} \StringTok{"gray"}\NormalTok{, }\AttributeTok{linetype =} \StringTok{"dashed"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{y =} \StringTok{"Log{-}verosimiglianza"}\NormalTok{,}
    \AttributeTok{x =} \FunctionTok{expression}\NormalTok{(}\StringTok{"Parametro"}\SpecialCharTok{\textasciitilde{}}\NormalTok{mu)}
\NormalTok{  ) }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-37-1} \end{center}

Dalla figura notiamo che, per i dati osservati, il massimo della funzione di log-verosimiglianza calcolata per via numerica, ovvero 30.93, è identico alla media dei dati campionari e corrisponde al risultato teorico della \eqref{eq:maxlikemu}.

\hypertarget{considerazioni-conclusive-1}{%
\section*{Considerazioni conclusive}\label{considerazioni-conclusive-1}}


La verosimiglianza viene utilizzata sia nell'inferenza bayesiana che in quella frequentista. In entrambi i paradigmi di inferenza, il suo ruolo è quantificare la forza con la quale i dati osservati supportano i possibili valori dei parametri sconosciuti.

Nella funzione di verosimiglianza i dati (osservati) vengono trattati come fissi, mentre i valori del parametro (o dei parametri) \(\theta\) vengono variati: la verosimiglianza è una funzione di \(\theta\) per il dato fisso \(y\). Pertanto, la funzione di verosimiglianza riassume i seguenti elementi: un modello statistico che genera stocasticamente i dati (in questo capitolo abbiamo esaminato due modelli statistici: quello binomiale e quello Normale), un intervallo di valori possibili per \(\theta\) e i dati osservati \(y\).

Nella statistica frequentista l'inferenza si basa solo sui dati a disposizione e qualunque informazione fornita dalle conoscenze precedenti non viene presa in considerazione. Nello specifico, nella statistica frequentista l'inferenza viene condotta massimizzando la funzione di (log) verosimiglianza, condizionatamente ai valori assunti dalle variabili casuali campionarie. Nella statistica bayesiana, invece, l'inferenza statistica viene condotta combinando la funzione di verosimiglianza con le distribuzioni a priori dei parametri incogniti \(\theta\).

La differenza fondamentale tra inferenza bayesiana e frequentista è dunque che i frequentisti non ritengono utile descrivere in termini probabilistici i parametri: i parametri dei modelli statistici vengono concepiti come fissi ma sconosciuti. Nell'inferenza bayesiana, invece, i parametri sconosciuti sono intesi come delle variabili casuali e ciò consente di quantificare in termini probabilistici il nostro grado di intertezza relativamente al loro valore.

\hypertarget{appendix:const-norm-bino23}{%
\chapter{Verosimiglianza marginale}\label{appendix:const-norm-bino23}}

\hypertarget{derivazione-analitica-della-costante-di-normalizzazione}{%
\section{Derivazione analitica della costante di normalizzazione}\label{derivazione-analitica-della-costante-di-normalizzazione}}

Riportiamo di seguito la derivazione analitica per la costante di normalizzazione discussa nella Sezione \ref{sec:const-normaliz-bino23}, ovvero dell'integrale \eqref{eq:likebino23}.

\begin{proof}
Sia la distribuzione a priori \(\theta \sim \mbox{Beta}(a, b)\) e sia \(y = \{y_1, \dots, y_n\} \sim \Bin(\theta, n)\). Scrivendo la \emph{funzione beta} come

\[
\B(a, b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)},
\] la verosimiglianza marginale diventa

\begin{align}
p(y) &= \int p(y \mid \theta) p(\theta) \,\operatorname {d}\!\theta \notag\\
&= \int_0^1 \binom{n}{y}\theta^{y} (1 - \theta)^{n- y} \frac{1}{\B(a,b)} \theta^{a-1} (1-\theta)^{b-1} \,\operatorname {d}\!\theta \notag\\
&= \binom{n}{y}\frac{1}{\B(a,b)} \int_0^1 \theta^{y + a - 1} (1-\theta)^{n- y + b-1}  \,\operatorname {d}\!\theta \notag\\
&= \binom{n}{y}\frac{\Beta(y + a, n- y + b)}{\Beta(a,b)},
\label{eq:constant-norm-beta-binom}
\end{align}

in quanto

\begin{align}
\int_0^1 \frac{1}{\Beta(a,b)} \theta^{a-1} (1-\theta)^{b-1} \,\operatorname {d}\! \theta &= 1\notag\\
\frac{1}{\Beta(a,b)} \int_0^1  \theta^{a-1} (1-\theta)^{b-1} \,\operatorname {d}\! \theta &= 1\notag\\
\int_0^1  \theta^{a-1} (1-\theta)^{b-1} \,\operatorname {d}\!\theta &= \Beta(a,b). \notag
\end{align}

In conclusione, nel caso di una verosimiglianza binomiale \(y = \sim \Bin(\theta, n)\) e di una distribuzione a priori \(\theta \sim \mbox{Beta}(a, b)\), la verosimiglianza marginale diventa uguale alla \eqref{eq:constant-norm-beta-binom}.
\end{proof}

\begin{exercise}

Si verifichi la \eqref{eq:constant-norm-beta-binom} mediante di dati di \citet{zetschefuture2019}.

Per replicare mediante la \eqref{eq:constant-norm-beta-binom} il risultato trovato per via numerica nella Sezione \ref{sec:const-normaliz-bino23} assumiamo una distribuzione a priori uniforme, ovvero \(\mbox{Beta}(1, 1)\). I valori del problema dunque diventano i seguenti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{23}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{30}
\end{Highlighting}
\end{Shaded}

Definiamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(a, b) \{}
\NormalTok{  (}\FunctionTok{gamma}\NormalTok{(a) }\SpecialCharTok{*} \FunctionTok{gamma}\NormalTok{(b)) }\SpecialCharTok{/} \FunctionTok{gamma}\NormalTok{(a }\SpecialCharTok{+}\NormalTok{ b)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Il risultato cercato è

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{choose}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{23}\NormalTok{) }\SpecialCharTok{*} \FunctionTok{B}\NormalTok{(y }\SpecialCharTok{+}\NormalTok{ a, n }\SpecialCharTok{{-}}\NormalTok{ y }\SpecialCharTok{+}\NormalTok{ b) }\SpecialCharTok{/} \FunctionTok{B}\NormalTok{(a, b)}
\CommentTok{\#\textgreater{} [1] 0.03226}
\end{Highlighting}
\end{Shaded}

\end{exercise}

\hypertarget{es-pratico-zetsche}{%
\chapter{Aspettative degli individui depressi}\label{es-pratico-zetsche}}

Per fare pratica, applichiamo il metodo basato su griglia ad un campione di dati reali. \citet{zetschefuture2019} si sono chiesti se gli individui depressi manifestino delle aspettative accurate circa il loro umore futuro, oppure se tali aspettative siano distorte negativamente. Esamineremo qui i 30 partecipanti dello studio di \citet{zetschefuture2019} che hanno riportato la presenza di un episodio di depressione maggiore in atto. All'inizio della settimana di test, a questi pazienti è stato chiesto di valutare l'umore che si aspettavano di esperire nei giorni seguenti della settimana. Mediante una app, i partecipanti dovevano poi valutare il proprio umore in cinque momenti diversi di ciascuno dei cinque giorni successivi. Lo studio considera diverse emozioni, ma qui ci concentriamo solo sulla tristezza.

Sulla base dei dati forniti dagli autori, abbiamo calcolato la media dei giudizi relativi al livello di tristezza raccolti da ciascun partecipante tramite la app. Tale media è stata poi sottratta dall'aspettativa del livello di tristezza fornita all'inizio della settimana. La discrepanza tra aspettative e realtà è stata considerata come un evento dicotomico: valori positivi di tale differenza indicano che le aspettative circa il livello di tristezza erano maggiori del livello di tristezza effettivamente esperito --- ciò significa che le aspettative future risultano negativamente distorte (evento codificato con ``1''). Viceversa, si ha che le aspettative risultano positivamente distorte se la differenza descritta in precedenza assume un valore negativo (evento codificato con ``0'').

Nel campione dei 30 partecipanti clinici di \citet{zetschefuture2019}, le aspettative future di 23 partecipanti risultano distorte negativamente e quelle di 7 partecipanti risultano distorte positivamente. Chiameremo \(\theta\) la probabilità dell'evento ``le aspettative del partecipante sono distorte negativamente''. Ci poniamo il problema di ottenere una stima a posteriori di \(\theta\) usando il metodo basato su griglia.

\hypertarget{la-griglia}{%
\section{La griglia}\label{la-griglia}}

Fissiamo una griglia di \(n = 50\) valori equispaziati nell'intervallo {[}0, 1{]} per il parametro \(\theta\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_points }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{p\_grid }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{0}\NormalTok{, }\AttributeTok{to =} \DecValTok{1}\NormalTok{, }\AttributeTok{length.out =}\NormalTok{ n\_points)}
\NormalTok{p\_grid}
\CommentTok{\#\textgreater{}  [1] 0.00000 0.02041 0.04082 0.06122 0.08163 0.10204}
\CommentTok{\#\textgreater{}  [7] 0.12245 0.14286 0.16327 0.18367 0.20408 0.22449}
\CommentTok{\#\textgreater{} [13] 0.24490 0.26531 0.28571 0.30612 0.32653 0.34694}
\CommentTok{\#\textgreater{} [19] 0.36735 0.38776 0.40816 0.42857 0.44898 0.46939}
\CommentTok{\#\textgreater{} [25] 0.48980 0.51020 0.53061 0.55102 0.57143 0.59184}
\CommentTok{\#\textgreater{} [31] 0.61224 0.63265 0.65306 0.67347 0.69388 0.71429}
\CommentTok{\#\textgreater{} [37] 0.73469 0.75510 0.77551 0.79592 0.81633 0.83673}
\CommentTok{\#\textgreater{} [43] 0.85714 0.87755 0.89796 0.91837 0.93878 0.95918}
\CommentTok{\#\textgreater{} [49] 0.97959 1.00000}
\end{Highlighting}
\end{Shaded}

\hypertarget{distribuzione-a-priori}{%
\section{Distribuzione a priori}\label{distribuzione-a-priori}}

Supponiamo di avere scarse credenze a priori sulla tendenza di un individuo clinicamente depresso a manifestare delle aspettative distorte negativamente circa il suo umore futuro. Imponiamo quindi una distribuzione non informativa sulla distribuzione a priori di \(\theta\) --- ovvero, una distribuzione uniforme nell'intervallo {[}0, 1{]}. Dato che consideriamo soltanto \(n = 50\) valori possibili per il parametro \(\theta\), creiamo un vettore di 50 elementi che conterrà i valori della distribuzione a priori scalando ciascun valore del vettore per \(n\) in modo tale che la somma di tutti i valori sia uguale a 1.0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prior1 }\OtherTok{\textless{}{-}} \FunctionTok{dbeta}\NormalTok{(p\_grid, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(}\FunctionTok{dbeta}\NormalTok{(p\_grid, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\NormalTok{prior1}
\CommentTok{\#\textgreater{}  [1] 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02}
\CommentTok{\#\textgreater{} [11] 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02}
\CommentTok{\#\textgreater{} [21] 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02}
\CommentTok{\#\textgreater{} [31] 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02}
\CommentTok{\#\textgreater{} [41] 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02}
\end{Highlighting}
\end{Shaded}

Verifichiamo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(prior1)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

\noindent La distribuzione a priori così costruita è rappresentata nella figura \ref{fig:gridappr1}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(p\_grid, prior1) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{p\_grid, }\AttributeTok{xend=}\NormalTok{p\_grid, }\AttributeTok{y=}\DecValTok{0}\NormalTok{, }\AttributeTok{yend=}\NormalTok{prior1)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_segment}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.17}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Parametro \textbackslash{}U03B8"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Probabilità a priori"}\NormalTok{,}
    \AttributeTok{title =} \StringTok{"50 punti"}
\NormalTok{  )}
\NormalTok{p1}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/gridappr1-1} 

}

\caption{Rappresentazione grafica della distribuzione a priori per il parametro $   heta$, ovvero la probabilità di aspettative future distorte negativamente.}\label{fig:gridappr1}
\end{figure}

\hypertarget{funzione-di-verosimiglianza}{%
\section{Funzione di verosimiglianza}\label{funzione-di-verosimiglianza}}

Calcoliamo ora la funzione di verosimiglianza utilizzando i 50 valori \(\theta\) definiti in precedenza. A ciascuno dei valori della griglia applichiamo la formula binomiale, tendendo costanti i dati (ovvero 23 ``successi'' in 30 prove). Ad esempio, in corrispondenza del valore \(\theta = 0.816\), l'ordinata della funzione di verosimiglianza diventa

\begin{equation}
\binom{30}{23} \cdot 0.816^{23} \cdot (1 - 0.816)^{7} = 0.135.\notag
\end{equation}

Per \(\theta = 0.837\), l'ordinata della funzione di verosimiglianza sarà

\begin{equation}
\binom{30}{23} \cdot 0.837^{23} \cdot (1 - 0.837)^{7} = 0.104.\notag
\end{equation}

Dobbiamo svolgere questo calcolo per tutti gli elementi della griglia. Usando \(\R\), tale risultato si trova nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{likelihood }\OtherTok{\textless{}{-}} \FunctionTok{dbinom}\NormalTok{(}\AttributeTok{x =} \DecValTok{23}\NormalTok{, }\AttributeTok{size =} \DecValTok{30}\NormalTok{, }\AttributeTok{prob =}\NormalTok{ p\_grid)}
\NormalTok{likelihood}
\CommentTok{\#\textgreater{}  [1] 0.000e+00 2.353e{-}33 1.703e{-}26 1.644e{-}22 1.054e{-}19}
\CommentTok{\#\textgreater{}  [6] 1.525e{-}17 8.602e{-}16 2.528e{-}14 4.607e{-}13 5.819e{-}12}
\CommentTok{\#\textgreater{} [11] 5.499e{-}11 4.106e{-}10 2.520e{-}09 1.311e{-}08 5.919e{-}08}
\CommentTok{\#\textgreater{} [16] 2.362e{-}07 8.457e{-}07 2.749e{-}06 8.197e{-}06 2.260e{-}05}
\CommentTok{\#\textgreater{} [21] 5.799e{-}05 1.393e{-}04 3.149e{-}04 6.721e{-}04 1.359e{-}03}
\CommentTok{\#\textgreater{} [26] 2.612e{-}03 4.779e{-}03 8.340e{-}03 1.390e{-}02 2.214e{-}02}
\CommentTok{\#\textgreater{} [31] 3.372e{-}02 4.910e{-}02 6.830e{-}02 9.068e{-}02 1.147e{-}01}
\CommentTok{\#\textgreater{} [36] 1.378e{-}01 1.568e{-}01 1.682e{-}01 1.689e{-}01 1.575e{-}01}
\CommentTok{\#\textgreater{} [41] 1.349e{-}01 1.044e{-}01 7.133e{-}02 4.166e{-}02 1.973e{-}02}
\CommentTok{\#\textgreater{} [46] 6.937e{-}03 1.535e{-}03 1.473e{-}04 1.868e{-}06 0.000e+00}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{dbinom(x,\ size,\ prob)} richiede che vengano specificati tre parametri: il numero di ``successi'', il numero di prove e la probabilità di successo. Nella chiamata precedente, \texttt{x} (numero di successi) e \texttt{size} (numero di prove bernoulliane) sono degli scalari e \texttt{prob} è il vettore \texttt{p\_grid}. In tali circostanze, l'output di \texttt{dbinom()} è il vettore che abbiamo chiamato \texttt{likelihood}. Gli elementi di tale vettore sono stati calcolati applicando la formula della distribuzione binomiale a ciascuno dei 50 elementi della griglia, tenendo sempre costanti i dati {[}ovvero, \texttt{x} (il numero di successi) e \texttt{size} (numero di prove bernoulliane){]}; ciò che varia è il valore \texttt{prob}, che assume valori diversi (\texttt{p\_grid}) in ciascuna cella della griglia.

La chiamata a \texttt{dbinom()} produce dunque un vettore i cui valori corrispondono all'ordinata della funzione di verosimiglianza per per ciascun valore \(\theta\) specificato in \texttt{p\_grid}. La verosimiglianza discretizzata così ottenuta è riportata nella figura \ref{fig:gridappr2}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(p\_grid, likelihood) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{p\_grid, }\AttributeTok{xend=}\NormalTok{p\_grid, }\AttributeTok{y=}\DecValTok{0}\NormalTok{, }\AttributeTok{yend=}\NormalTok{likelihood)) }\SpecialCharTok{+}
  \FunctionTok{geom\_segment}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.17}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Parametro \textbackslash{}U03B8"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Verosimiglianza"}
\NormalTok{  )}
\NormalTok{p2}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/gridappr2-1} 

}

\caption{Rappresentazione della funzione di verosimiglianza per il parametro $\theta$, ovvero la probabilità di aspettative future distorte negativamente.}\label{fig:gridappr2}
\end{figure}

\hypertarget{distribuzione-a-posteriori}{%
\section{Distribuzione a posteriori}\label{distribuzione-a-posteriori}}

L'approssimazione discretizzata della distribuzione a posteriori \(p(\theta \mid y)\) si ottiene facendo il prodotto della verosimiglianza e della distribuzione a priori per poi scalare tale prodotto per una costante di normalizzazione. Il prodotto \(p(\theta)\mathcal{L}(y \mid \theta)\) produce la distribuzione a posteriori \emph{non standardizzata}.

Nel caso di una distribuzione a priori non informativa (ovvero una distribuzione uniforme), per ottenere la funzione a posteriori non standardizzata è sufficiente moltiplicare ciascun valore della funzione di verosimiglianza per 0.02. Per esempio, per il primo valore della funzione di verosimiglianza usato quale esempio poco sopra, abbiamo \(0.135 \cdot 0.02\); per il secondo valore dell'esempio abbiamo \(0.104 \cdot 0.02\); e così via. Possiamo svolgere tutti i calcoli usando \(\R\) nel modo seguente:\footnote{Ricordiamo il principio dell'aritmetica vettorializzata: i vettori \texttt{likelihood} e \texttt{prior1} sono entrambi costituiti da 50 elementi. Se facciamo il prodotto tra i due vettori otteniamo un vettore di 50 elementi, ciascuno dei quali uguale al prodotto dei corrispondenti elementi dei vettori \texttt{likelihood} e \texttt{prior1}.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unstd\_posterior }\OtherTok{\textless{}{-}}\NormalTok{ likelihood }\SpecialCharTok{*}\NormalTok{ prior1}
\NormalTok{unstd\_posterior}
\CommentTok{\#\textgreater{}  [1] 0.000e+00 4.705e{-}35 3.406e{-}28 3.288e{-}24 2.107e{-}21}
\CommentTok{\#\textgreater{}  [6] 3.050e{-}19 1.720e{-}17 5.057e{-}16 9.214e{-}15 1.164e{-}13}
\CommentTok{\#\textgreater{} [11] 1.100e{-}12 8.211e{-}12 5.040e{-}11 2.622e{-}10 1.184e{-}09}
\CommentTok{\#\textgreater{} [16] 4.724e{-}09 1.691e{-}08 5.499e{-}08 1.639e{-}07 4.519e{-}07}
\CommentTok{\#\textgreater{} [21] 1.160e{-}06 2.786e{-}06 6.297e{-}06 1.344e{-}05 2.718e{-}05}
\CommentTok{\#\textgreater{} [26] 5.224e{-}05 9.558e{-}05 1.668e{-}04 2.780e{-}04 4.428e{-}04}
\CommentTok{\#\textgreater{} [31] 6.744e{-}04 9.820e{-}04 1.366e{-}03 1.814e{-}03 2.294e{-}03}
\CommentTok{\#\textgreater{} [36] 2.756e{-}03 3.136e{-}03 3.363e{-}03 3.378e{-}03 3.150e{-}03}
\CommentTok{\#\textgreater{} [41] 2.697e{-}03 2.087e{-}03 1.427e{-}03 8.331e{-}04 3.945e{-}04}
\CommentTok{\#\textgreater{} [46] 1.387e{-}04 3.070e{-}05 2.947e{-}06 3.736e{-}08 0.000e+00}
\end{Highlighting}
\end{Shaded}

Avendo calcolato i valori della funzione a posteriori non standardizzata è poi necessario dividere per una costante di normalizzazione. Nel caso discreto, trovare il denominatore del teorema di Bayes è facile: esso è uguale alla somma di tutti i valori della distribuzione a posteriori non normalizzata. Per i dati presenti, tale costante di normalizzazione è uguale a 0.032:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(unstd\_posterior)}
\CommentTok{\#\textgreater{} [1] 0.03161}
\end{Highlighting}
\end{Shaded}

La standardizzazione dei due valori usati come esempio è data da: \(0.135 \cdot 0.02 / 0.032\) e da \(0.104 \cdot 0.02 / 0.032\). Usiamo \(\R\) per svolgere questo calcolo su tutti i 50 valori di \texttt{unstd\_posterior} così che la somma dei 50 i valori di \texttt{posterior} sia uguale a 1.0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{posterior }\OtherTok{\textless{}{-}}\NormalTok{ unstd\_posterior }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(unstd\_posterior)}
\NormalTok{posterior}
\CommentTok{\#\textgreater{}  [1] 0.000e+00 1.488e{-}33 1.077e{-}26 1.040e{-}22 6.666e{-}20}
\CommentTok{\#\textgreater{}  [6] 9.649e{-}18 5.442e{-}16 1.600e{-}14 2.915e{-}13 3.681e{-}12}
\CommentTok{\#\textgreater{} [11] 3.479e{-}11 2.597e{-}10 1.594e{-}09 8.295e{-}09 3.745e{-}08}
\CommentTok{\#\textgreater{} [16] 1.494e{-}07 5.350e{-}07 1.739e{-}06 5.186e{-}06 1.430e{-}05}
\CommentTok{\#\textgreater{} [21] 3.669e{-}05 8.814e{-}05 1.992e{-}04 4.252e{-}04 8.599e{-}04}
\CommentTok{\#\textgreater{} [26] 1.652e{-}03 3.023e{-}03 5.276e{-}03 8.794e{-}03 1.401e{-}02}
\CommentTok{\#\textgreater{} [31] 2.133e{-}02 3.106e{-}02 4.321e{-}02 5.737e{-}02 7.256e{-}02}
\CommentTok{\#\textgreater{} [36] 8.719e{-}02 9.922e{-}02 1.064e{-}01 1.069e{-}01 9.966e{-}02}
\CommentTok{\#\textgreater{} [41] 8.533e{-}02 6.602e{-}02 4.513e{-}02 2.635e{-}02 1.248e{-}02}
\CommentTok{\#\textgreater{} [46] 4.389e{-}03 9.712e{-}04 9.321e{-}05 1.182e{-}06 0.000e+00}
\end{Highlighting}
\end{Shaded}

Verifichiamo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(posterior)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

La distribuzione a posteriori così trovata non è altro che la versione normalizzata della funzione di verosimiglianza: questo avviene perché la distribuzione a priori uniforme non ha aggiunto altre informazioni oltre a quelle che erano già fornite dalla funzione di verosimiglianza. L'approssimazione discretizzata di \(p(\theta \mid y)\) che abbiamo appena trovato è riportata nella figura \ref{fig:gridappr3}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p3 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(p\_grid, posterior) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{p\_grid, }\AttributeTok{xend=}\NormalTok{p\_grid, }\AttributeTok{y=}\DecValTok{0}\NormalTok{, }\AttributeTok{yend=}\NormalTok{posterior)) }\SpecialCharTok{+}
  \FunctionTok{geom\_segment}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.17}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Parametro \textbackslash{}U03B8"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Probabilità a posteriori"}
\NormalTok{  )}
\NormalTok{p3}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/gridappr3-1} 

}

\caption{Rappresentazione della distribuzione a posteriori per il parametro $\theta$, ovvero la probabilità di aspettative future distorte negativamente.}\label{fig:gridappr3}
\end{figure}

I grafici delle figure \ref{fig:gridappr1}, \ref{fig:gridappr2} e \ref{fig:gridappr3} sono state calcolati utilizzando una griglia di 50 valori equi-spaziati per il parametro \(\theta\). I segmenti verticali rappresentano l'intensità della funzione in corrispondenza di ciascuna modalità parametro \(\theta\). Nella figura \ref{fig:gridappr1} e nella figura \ref{fig:gridappr3} la somma delle lunghezze dei segmenti verticali è uguale a 1.0; ciò non si verifica, invece, nel caso della figura \ref{fig:gridappr3} (la funzione di verosimiglianza non è mai una funzione di probabilità, né nel caso discreto né in quello continuo).

\hypertarget{es-depression-beta-2-10}{%
\section{La stima della distribuzione a posteriori (versione 2)}\label{es-depression-beta-2-10}}

Continuiamo l'analisi di questi dati esaminiamo l'impatto di una distribuzione a priori informativa sulla distribuzione a posteriori. Una distribuzione a priori informativa riflette un alto grado di certezza a priori sui valori dei parametri del modello. Un ricercatore utilizza una distribuzione a priori informativa per introdurre nel processo di stima informazioni pre-esistenti alla raccolta dei dati, introducendo così delle restrizioni sulla possibile gamma di valori del parametro.

Nel caso presente, supponiamo che la letteratura psicologica fornisca delle informazioni su \(\theta\) (la probabilità che le aspettative future di un individuo clinicamente depresso siano distorte negativamente). Per fare un esempio, supponiamo (irrealisticamente) che tali conoscenze pregresse possano essere rappresentate da una Beta di parametri \(\alpha = 2\) e \(\beta = 10\). Tali ipotetiche conoscenze pregresse ritengono molto plausibili valori \(\theta\) bassi e considerano implausibili valori \(\theta > 0.5\). Questo è equivalente a dire che ci aspettiamo che le aspettative relative all'umore futuro siano distorte negativamente solo per pochissimi individui clinicamente depressi --- ovvero, ci aspettiamo che la maggioranza degli individui clinicamente depressi sia inguaribilmente ottimista. Questa è, ovviamente, una credenza a priori del tutto irrealistica. La esamino qui, non perché abbia alcun senso nel contesto dei dati di \citet{zetschefuture2019}, ma soltanto per fare un esempio nel quale risulta chiaro come la distribuzione a posteriori sia una sorta di ``compromesso'' tra la distribuzione a priori e la verosimiglianza.

Con calcoli del tutto simili a quelli descritti sopra si giunge alla distribuzione a posteriori rappresentata nella figura \ref{fig:gridappr4}. Useremo ora una griglia di 100 valori per il parametro \(\theta\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_points }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{p\_grid }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{0}\NormalTok{, }\AttributeTok{to =} \DecValTok{1}\NormalTok{, }\AttributeTok{length.out =}\NormalTok{ n\_points)}
\end{Highlighting}
\end{Shaded}

Per la distribuzione a priori scegliamo una Beta(2, 10):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alpha }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{beta }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{prior2 }\OtherTok{\textless{}{-}} \FunctionTok{dbeta}\NormalTok{(p\_grid, alpha, beta) }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(}\FunctionTok{dbeta}\NormalTok{(p\_grid, alpha, beta))}
\FunctionTok{sum}\NormalTok{(prior2)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

Tale distribuzione a priori è rappresentata nella figura \ref{fig:gridappr4}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plot\_df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(p\_grid, prior2)}
\NormalTok{p4 }\OtherTok{\textless{}{-}}\NormalTok{ plot\_df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{p\_grid, }\AttributeTok{xend=}\NormalTok{p\_grid, }\AttributeTok{y=}\DecValTok{0}\NormalTok{, }\AttributeTok{yend=}\NormalTok{prior2)) }\SpecialCharTok{+}
  \FunctionTok{geom\_segment}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.17}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{""}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Probabilità a priori"}
\NormalTok{  )}
\NormalTok{p4}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/gridappr4-1} 

}

\caption{Rappresentazione di una funzione a priori informativa per il parametro $\theta$.}\label{fig:gridappr4}
\end{figure}

Calcoliamo il valore di verosimiglianza per ciascun punto della griglia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{likelihood }\OtherTok{\textless{}{-}} \FunctionTok{dbinom}\NormalTok{(}\DecValTok{23}\NormalTok{, }\AttributeTok{size =} \DecValTok{30}\NormalTok{, }\AttributeTok{prob =}\NormalTok{ p\_grid)}
\end{Highlighting}
\end{Shaded}

\noindent Per ciascun punto della griglia, il prodotto tra la verosimiglianza e distribuzione a priori è dato da:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unstd\_posterior2 }\OtherTok{\textless{}{-}}\NormalTok{ likelihood }\SpecialCharTok{*}\NormalTok{ prior2}
\end{Highlighting}
\end{Shaded}

\noindent È necessario normalizzare la distribuzione a posteriori discretizzata:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{posterior2 }\OtherTok{\textless{}{-}}\NormalTok{ unstd\_posterior2 }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(unstd\_posterior2)}
\end{Highlighting}
\end{Shaded}

\noindent Verifichiamo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(posterior2)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

\noindent La nuova funzione a posteriori discretizzata è rappresentata nella figura \ref{fig:gridappr5}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plot\_df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(p\_grid, posterior2)}
\NormalTok{p5 }\OtherTok{\textless{}{-}}\NormalTok{ plot\_df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ p\_grid, }\AttributeTok{xend =}\NormalTok{ p\_grid, }\AttributeTok{y =} \DecValTok{0}\NormalTok{, }\AttributeTok{yend =}\NormalTok{ posterior2)) }\SpecialCharTok{+}
  \FunctionTok{geom\_segment}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.17}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Parametro \textbackslash{}U03B8"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Probabilità a posteriori"}
\NormalTok{  )}
\NormalTok{p5}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/gridappr5-1} 

}

\caption{Rappresentazione della funzione a posteriori per il parametro $\theta$ calcolata utilizzando una distribuzione a priori informativa.}\label{fig:gridappr5}
\end{figure}

Facendo un confronto tra le figure \ref{fig:gridappr4} e \ref{fig:gridappr5} notiamo una notevole differenza tra la distribuzione a priori e la distribuzione a posteriori. In particolare, la distribuzione a posteriori risulta spostata verso destra su posizioni più vicine a quelle della verosimiglianza {[}figura \ref{fig:gridappr2}{]}. Si noti inoltre che, a causa dell'effetto della distribuzione a priori, le distribuzioni a posteriori delle figure \ref{fig:gridappr3} e \ref{fig:gridappr5} sono molto diverse tra loro.

Campioniamo ora 10,000 punti dall'approssimazione discretizzata della distribuzione a posteriori:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Set the seed}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{84735}\NormalTok{)}

\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
\NormalTok{  p\_grid,}
\NormalTok{  posterior2}
\NormalTok{)}
\CommentTok{\# Step 4: sample from the discretized posterior}
\NormalTok{post\_samples }\OtherTok{\textless{}{-}}\NormalTok{ df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice\_sample}\NormalTok{(}
  \AttributeTok{n =} \FloatTok{1e5}\NormalTok{,}
  \AttributeTok{weight\_by =}\NormalTok{ posterior2,}
  \AttributeTok{replace =} \ConstantTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\noindent Una rappresentazione grafica del campione casuale estratto dalla distribuzione a posteriori \(p(\theta \mid y)\) è data da:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{post\_samples }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ p\_grid)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..), }
    \AttributeTok{color =} \StringTok{"white"}\NormalTok{, }
    \AttributeTok{binwidth =} \FloatTok{0.05}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ dbeta, }\AttributeTok{args =} \FunctionTok{list}\NormalTok{(}\DecValTok{25}\NormalTok{, }\DecValTok{17}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{lims}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-57-1} \end{center}

\noindent All'istogramma è stata sovrapposta la corretta distribuzione a posteriori, ovvero una Beta di parametri 25 (\(y + \alpha\) = 23 + 2) e 17 (\(n - y + \beta\) = 30 - 23 + 10).

La stima della moda a posteriori si ottiene con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{p\_grid[}\FunctionTok{which.max}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{posterior2)]}
\CommentTok{\#\textgreater{} [1] 0.596}
\end{Highlighting}
\end{Shaded}

e corrisponde a

\[
\Mo = \frac{\alpha -1}{\alpha + \beta - 2} = \frac{25 - 1}{25 + 17 - 2} = 0.6.
\]

La stima della media a posteriori si ottiene con

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(post\_samples}\SpecialCharTok{$}\NormalTok{p\_grid)}
\CommentTok{\#\textgreater{} [1] 0.5953}
\end{Highlighting}
\end{Shaded}

e corrisponde a

\[
\bar{\theta} = \frac{\alpha}{\alpha + \beta} = \frac{25}{25 + 17} \approx 0.5952.
\]

La stima della mediana a posteriori si ottiene con

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{median}\NormalTok{(post\_samples}\SpecialCharTok{$}\NormalTok{p\_grid)}
\CommentTok{\#\textgreater{} [1] 0.596}
\end{Highlighting}
\end{Shaded}

e corrisponde a

\[
\Me = \frac{\alpha - \frac{1}{3}}{\alpha + \beta - \frac{2}{3}} \approx 0.5968.
\]

\hypertarget{es-pratico-zetsche-funzioni}{%
\section{Versione 2}\label{es-pratico-zetsche-funzioni}}

Possiamo semplificare i calcoli precedenti definendo le funzioni \texttt{likelihood()}, \texttt{prior()} e \texttt{posterior()}.

Per calcolare la funzione di verosimiglianza per i 30 valori di \citet{zetschefuture2019} useremo la funzione \texttt{likelihood()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{23}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{30}
\NormalTok{param }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{100}\NormalTok{)}

\NormalTok{likelihood }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(param, }\AttributeTok{x =} \DecValTok{23}\NormalTok{, }\AttributeTok{N =} \DecValTok{30}\NormalTok{) \{}
  \FunctionTok{dbinom}\NormalTok{(x, N, param)}
\NormalTok{\}}

\FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{x =}\NormalTok{ param, }
  \AttributeTok{y =} \FunctionTok{likelihood}\NormalTok{(param)}
\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \FunctionTok{expression}\NormalTok{(theta),}
    \AttributeTok{y =} \StringTok{"Verosimiglianza"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-61-1} \end{center}

La funzione \texttt{likelihood()} ritorna l'ordinata della verosimiglianza binomiale per ciascun valore del vettore \texttt{param} in input.

Quale distribuzione a priori utilizzeremo una \(\mbox{Beta}(2, 10)\) che è implementata nella funzione \texttt{prior()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prior }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(param, }\AttributeTok{alpha =} \DecValTok{2}\NormalTok{, }\AttributeTok{beta =} \DecValTok{10}\NormalTok{) \{}
\NormalTok{  param\_vals }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{100}\NormalTok{)}
  \FunctionTok{dbeta}\NormalTok{(param, alpha, beta) }\CommentTok{\# / sum(dbeta(param\_vals, alpha, beta))}
\NormalTok{\}}

\FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{x =}\NormalTok{ param, }
  \AttributeTok{y =} \FunctionTok{prior}\NormalTok{(param)}
\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \FunctionTok{expression}\NormalTok{(theta),}
    \AttributeTok{y =} \StringTok{"Densità"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-62-1} \end{center}

La funzione \texttt{posterior()} ritorna il prodotto della densità a priori e della verosimiglianza:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{posterior }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(param) \{}
  \FunctionTok{likelihood}\NormalTok{(param) }\SpecialCharTok{*} \FunctionTok{prior}\NormalTok{(param)}
\NormalTok{\}}

\FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{x =}\NormalTok{ param, }
  \AttributeTok{y =} \FunctionTok{posterior}\NormalTok{(param)}
\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \FunctionTok{expression}\NormalTok{(theta),}
    \AttributeTok{y =} \StringTok{"Densità"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-63-1} \end{center}

La distribuzione a posteriori non normalizzata mostrata nella figura replica il risultato ottenuto con il codice utilizzato nella prima parte di questo Capitolo. Per l'implementazione dell'algoritmo di Metropolis non è necessaria la normalizzazione della distribuzione a posteriori.

\hypertarget{integration-mc}{%
\chapter{Integrazione di Monte Carlo}\label{integration-mc}}

Il termine Monte Carlo si riferisce al fatto che la computazione fa ricorso ad un ripetuto campionamento casuale attraverso la generazione di sequenze di numeri casuali. Una delle sue applicazioni più potenti è il calcolo degli integrali mediante simulazione numerica. Sia l'integrale da calcolare

\[
\int_a^b h(y) dy.
\] Se decomponiamo \(h(y)\) nel prodotto di una funzione \(f(y)\) e una funzione di densità di probabilità \(p(y)\) definita nell'intervallo \((a, b)\) avremo:

\[
\int_a^b h(y) dy = \int_a^b f(y) p(y) dy = \E[f(y)],
\] così che l'integrale può essere espresso come una funzione di aspettazione \(f(y)\) sulla densità \(p(y)\). Se definiamo un gran numero di variabili casuali \(y_1, y_2, \dots, y_n\) appartenenti alla densità di probabilità \(p(y)\) allora avremo

\[
\int_a^b h(y) dy = \int_a^b f(y) p(y) dy = \E[f(y)] \approx \frac{1}{n}\sum_{i=1}^n f(y)
\] che è l'integrale di Monte Carlo.

L'integrazione con metodo Monte Carlo trova la sua giustificazione nella \emph{Legge forte dei grandi numeri}. Data una successione di variabili casuali \(Y_{1}, Y_{2},\dots, Y_{n},\dots\) indipendenti e identicamente distribuite con media \(\mu\), ne segue che

\[
P\left( \lim_{n \rightarrow \infty} \frac{1}{n} \sum_{i=1}^n Y_i = \mu \right) = 1.
\] Ciò significa che, al crescere di \(n\), la media delle realizzazioni di \(Y_{1}, Y_{2},\dots, Y_{n},\dots\) converge con probabilità 1 al vero valore \(\mu\).

Possiamo fornire un esempio intuitivo della legge forte dei grandi numeri facendo riferimento ad una serie di lanci di una moneta dove \(Y=1\) significa ``testa'' e \(Y=0\) significa ``croce''. Per la legge forte dei grandi numeri, nel caso di una moneta equilibrata la proporzione di eventi ``testa'' converge alla vera probabilità dell'evento ``testa''

\[
  \frac{1}{n} \sum_{i=1}^n Y_i \rightarrow \frac{1}{2}
\] con probabilità di uno.

Quello che è stato detto sopra non è che un modo sofisticato per dire che, se vogliamo calcolare un'approssimazione del valore atteso di una variabile casuale, non dobbiamo fare altro che la media aritmetica di un grande numero di realizzazioni della variabile casuale. Come è facile intuire, l'approssimazione migliora al crescere del numero di dati che abbiamo a disposizione.

L'integrazione di Monte Carlo può essere usata per approssimare la distribuzione a posteriori richiesta da una analisi Bayesiana: una stima di \(p(\theta \mid y)\) può essere ottenuta mediante un grande numero di campioni casuali della distribuzionea a posteriori.

\hypertarget{markov-chains}{%
\chapter{Le catene di Markov}\label{markov-chains}}

Per introdurre il concetto di catena di Markov, supponiamo che una persona esegua una passeggiata casuale sulla retta dei numeri naturali considerando solo i valori 1, 2, 3, 4, 5, 6.\footnote{Seguiamo qui la presentazione fornita da \href{https://github.com/bob-carpenter/prob-stats}{Bob Carpenter}.} Se la persona è collocata su un valore interno dei valori possibili (ovvero, 2, 3, 4 o 5), nel passo successivo è altrettanto probabile che rimanga su quel numero o si sposti su un numero adiacente. Se si muove, è ugualmente probabile che si muova a sinistra o a destra. Se la persona si trova su uno dei valori estremi (ovvero, 1 o 6), nel passo successivo è altrettanto probabile che rimanga rimanga su quel numero o si sposti nella posizione adiacente.

Questo è un esempio di una catena di Markov discreta. Una catena di Markov descrive il movimento probabilistico tra un numero di stati. Nell'esempio ci sono sei possibili stati, da 1 a 6, i quali corrispondono alle possibili posizioni della passeggiata casuale. Data la sua posizione corrente, la persona si sposterà nelle altre posizioni possibili con delle specifiche probabilità. La probabilità che si sposti in un'altra posizione dipende solo dalla sua posizione attuale e non dalle posizioni visitate in precedenza.

È possibile descrivere il movimento tra gli stati nei termini delle cosiddette \emph{probabilità di transizione}, ovvero le probabilità di movimento tra tutti i possibili stati in un unico passaggio di una catena di Markov. Le probabilità di transizione sono riassunte in una \emph{matrice di transizione} \(P\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{)}

\NormalTok{P }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(.}\DecValTok{5}\NormalTok{, .}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{,}
\NormalTok{    .}\DecValTok{25}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{25}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{,}
    \DecValTok{0}\NormalTok{, .}\DecValTok{25}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{25}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{,}
    \DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, .}\DecValTok{25}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{25}\NormalTok{, }\DecValTok{0}\NormalTok{,}
    \DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, .}\DecValTok{25}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{25}\NormalTok{,}
    \DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{5}
\NormalTok{    ),}
  \AttributeTok{nrow =} \DecValTok{6}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{6}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{kableExtra}\SpecialCharTok{::}\FunctionTok{kable}\NormalTok{(P)}
\end{Highlighting}
\end{Shaded}

\begin{tabular}{r|r|r|r|r|r}
\hline
0.50 & 0.50 & 0.00 & 0.00 & 0.00 & 0.00\\
\hline
0.25 & 0.50 & 0.25 & 0.00 & 0.00 & 0.00\\
\hline
0.00 & 0.25 & 0.50 & 0.25 & 0.00 & 0.00\\
\hline
0.00 & 0.00 & 0.25 & 0.50 & 0.25 & 0.00\\
\hline
0.00 & 0.00 & 0.00 & 0.25 & 0.50 & 0.25\\
\hline
0.00 & 0.00 & 0.00 & 0.00 & 0.50 & 0.50\\
\hline
\end{tabular}

\hfill\break

La prima riga della matrice di transizione \(P\) fornisce le probabilità di passare a ciascuno degli stati da 1 a 6 in un unico passaggio a partire dalla posizione 1; la seconda riga fornisce le probabilità di transizione in un unico passaggio dalla posizione 2 e così via. Per esempio, il valore \(P[1, 1]\) ci dice che, se la persona è nello stato 1, avrà una probabilità di 0.5 di rimanere in quello stato; \(P[1, 2]\) ci dice che c'è una probabilità di 0.5 di passare dallo stato 1 allo stato 2. Gli altri elementi della prima riga sono 0 perché, in un unico passaggio, non è possibile passare dallo stato 1 agli stati 3, 4, 5 e 6. Il valore \(P[2, 1]\) ci dice che, se la persona è nello stato 1 (seconda riga), avrà una probabilità di 0.25 di passare allo stato 1; avra una probabilità di 0.5 di rimanere in quello stato, \(P[2, 2]\); e avrà una probabilità di 0.25 di passare allo stato 3, \(P[2, 3]\); eccetera.

Si notino alcune importanti proprietà di questa particolare catena di Markov.

\begin{itemize}
\tightlist
\item
  È possibile passare da ogni stato a qualunque altro stato in uno o più passaggi: una catena di Markov con questa proprietà si dice \emph{irriducibile}.
\item
  Dato che la persona si trova in un particolare stato, se può tornare a questo stato solo a intervalli regolari, si dice che la catena di Markov è \emph{periodica}. In questo esempio la catena è \emph{aperiodica} poiché la passeggiata casuale non può eitornare allo stato attuale a intervalli regolari.
\end{itemize}

Un'importante proprietà di una catena di Markov irriducibile e aperiodica è che il passaggio ad uno stato del sistema dipende unicamente dallo stato immediatamente precedente e non dal come si è giunti a tale stato (dalla storia). Per questo motivo si dice che un processo markoviano è senza memoria. Tale ``assenza di memoria'' può essere interpretata come la proprietà mediante cui è possibile ottenere un insieme di campioni casuali da una distribuzione di interesse. Nel caso dell'inferenza bayesiana, la distribuzione di interesse è la distribuzione a posteriori, \(p(\theta \mid y)\). Le catene di Markov consentono di stimare i valori di aspettazione di variabili rispetto alla distribuzione a posteriori.

La matrice di transizione che si ottiene dopo un enorme numero di passi di una passeggiata casuale markoviana si chiama \emph{distribuzione stazionaria}. Se una catena di Markov è irriducibile e aperiodica, allora ha un'unica distribuzione stazionaria \(w\). La distribuzione limite di una tale catena di Markov, quando il numero di passi tende all'infinito, è uguale alla distribuzione stazionaria \(w\).

\hypertarget{simulare-una-catena-di-markov}{%
\section{Simulare una catena di Markov}\label{simulare-una-catena-di-markov}}

Un metodo per dimostrare l'esistenza della distribuzione stazionaria di una catena di Markov è quello di eseguire un esperimento di simulazione. Iniziamo una passeggiata casuale partendo da un particolare stato, diciamo la posizione 3, e quindi simuliamo molti passaggi della catena di Markov usando la matrice di transizione \(P\). Al crescere del numero di passi della catena, le frequenze relative che descrivono il passaggio a ciascuno dei sei possibili nodi della catena approssimano sempre meglio la distribuzione stazionaria \(w\).

Senza entrare nei dettagli della simulazione, la figura \ref{fig:markovsim} mostra i risultati ottenuti in 10,000 passi di una passeggiata casuale markoviana. Si noti che, all'aumentare del numero di iterazioni, le frequenze relative approssimano sempre meglio le probabilità nella distribuzione stazionaria \(w = (0.1, 0.2, 0.2, 0.2, 0.2, 0.1)\).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\StringTok{"numeric"}\NormalTok{, }\DecValTok{10000}\NormalTok{)}
\NormalTok{s[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{3}
\ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\DecValTok{10000}\NormalTok{) \{}
\NormalTok{  s[j] }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{size =} \DecValTok{1}\NormalTok{, }\AttributeTok{prob =}\NormalTok{ P[s[j }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{], ])}
\NormalTok{\}}
\NormalTok{S }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{Iterazione =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10000}\NormalTok{,}
  \AttributeTok{Location =}\NormalTok{ s}
\NormalTok{)}

\NormalTok{S }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}
    \AttributeTok{L1 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{1}\NormalTok{),}
    \AttributeTok{L2 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{2}\NormalTok{),}
    \AttributeTok{L3 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{3}\NormalTok{),}
    \AttributeTok{L4 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{4}\NormalTok{),}
    \AttributeTok{L5 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{5}\NormalTok{),}
    \AttributeTok{L6 =}\NormalTok{ (Location }\SpecialCharTok{==} \DecValTok{6}\NormalTok{)}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}
    \AttributeTok{Proporzione\_1 =} \FunctionTok{cumsum}\NormalTok{(L1) }\SpecialCharTok{/}\NormalTok{ Iterazione,}
    \AttributeTok{Proporzione\_2 =} \FunctionTok{cumsum}\NormalTok{(L2) }\SpecialCharTok{/}\NormalTok{ Iterazione,}
    \AttributeTok{Proporzione\_3 =} \FunctionTok{cumsum}\NormalTok{(L3) }\SpecialCharTok{/}\NormalTok{ Iterazione,}
    \AttributeTok{Proporzione\_4 =} \FunctionTok{cumsum}\NormalTok{(L4) }\SpecialCharTok{/}\NormalTok{ Iterazione,}
    \AttributeTok{Proporzione\_5 =} \FunctionTok{cumsum}\NormalTok{(L5) }\SpecialCharTok{/}\NormalTok{ Iterazione,}
    \AttributeTok{Proporzione\_6 =} \FunctionTok{cumsum}\NormalTok{(L6) }\SpecialCharTok{/}\NormalTok{ Iterazione}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}
\NormalTok{    Iterazione, Proporzione\_1, Proporzione\_2, Proporzione\_3,}
\NormalTok{    Proporzione\_4, Proporzione\_5, Proporzione\_6}
\NormalTok{  ) }\OtherTok{{-}\textgreater{}}\NormalTok{ S1}

\FunctionTok{gather}\NormalTok{(S1, Outcome, Probability, }\SpecialCharTok{{-}}\NormalTok{Iterazione) }\OtherTok{{-}\textgreater{}}\NormalTok{ S2}

\FunctionTok{ggplot}\NormalTok{(S2, }\FunctionTok{aes}\NormalTok{(Iterazione, Probability)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{Outcome, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylim}\NormalTok{(}\DecValTok{0}\NormalTok{, .}\DecValTok{4}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Frequenza relativa"}\NormalTok{) }\SpecialCharTok{+}
  \CommentTok{\# theme(text=element\_text(size=14))  +}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{breaks =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3000}\NormalTok{, }\DecValTok{6000}\NormalTok{, }\DecValTok{9000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[h]

{\centering \includegraphics{ds4psy_files/figure-latex/markovsim-1} 

}

\caption{Frequenze relative degli stati da 1 a 6 in funzione del numero di iterazioni per la simulazione di una catena di Markov.}\label{fig:markovsim}
\end{figure}

Il metodo di campionamento utilizzato dagli algoritmi MCMC consente di creare una catena di Markov irriducibile e aperiodica, la cui distribuzione stazionaria equivale alla distribuzione a posteriori \(p(\theta \mid y)\).

\hypertarget{intro-stan}{%
\chapter{Programmare in Stan}\label{intro-stan}}

\hypertarget{che-cosuxe8-stan}{%
\section{Che cos'è Stan?}\label{che-cosuxe8-stan}}

\href{http://mc-stan.org/}{STAN} è un linguaggio di programmazione probabilistico usato per l'inferenza bayesiana \citep{carpenter2017stan}. Prende il nome da uno dei creatori del metodo Monte Carlo, Stanislaw Ulam \citep{Eckhardt1987stan}. Stan consente di generare campioni da distribuzioni di probabilità basati sulla costruzione di una catena di Markov avente come distribuzione di equilibrio (o stazionaria) la distribuzione desiderata.

È possibile accedere al linguaggio Stan tramite diverse interfacce:

\begin{itemize}
\tightlist
\item
  \texttt{CmdStan}: eseguibile da riga di comando,
\item
  \texttt{RStan} - integrazione con il linguaggio \R;
\item
  \texttt{PyStan} - integrazione con il linguaggio di programmazione Python;
\item
  \texttt{MatlabStan} - integrazione con MATLAB;
\item
  \texttt{Stan.jl} - integrazione con il linguaggio di programmazione Julia;
\item
  \texttt{StataStan} - integrazione con Stata.
\end{itemize}

Inoltre, vengono fornite interfacce di livello superiore con i pacchetti che utilizzano Stan come backend, principalmente in Linguaggio \R:

\begin{itemize}
\tightlist
\item
  \texttt{shinystan}: interfaccia grafica interattiva per l'analisi della distribuzione a posteriori e le diagnostiche MCMC;\\
\item
  \texttt{bayesplot}: insieme di funzioni utilizzabili per creare grafici relativi all'analisi della distribuzione a posteriori, ai test del modello e alle diagnostiche MCMC;\\
\item
  \texttt{brms}: fornisce un'ampia gamma di modelli lineari e non lineari specificando i modelli statistici mediante la sintassi usata in \R;
\item
  \texttt{rstanarm}: fornisce un sostituto per i modelli frequentisti forniti da base \(\R\) e \texttt{lme4} utilizzando la sintassi usata in \(\R\) per la specificazione dei modelli statistici;
\item
  \texttt{edstan}: modelli Stan per la Item Response Theory;
\item
  \texttt{cmdstanr}, un'interfaccia \(\R\) per \texttt{CmdStan}.
\end{itemize}

\hypertarget{interfaccia-cmdstanr}{%
\section{\texorpdfstring{Interfaccia \texttt{cmdstanr}}{Interfaccia cmdstanr}}\label{interfaccia-cmdstanr}}

Negli esempi di questa dispensa verrà usata l'interfaccia \texttt{cmdstanr}. Il pacchetto \texttt{cmdstanr} non è ancora disponibile su CRAN, ma può essere installato come indicato su questo \href{https://mc-stan.org/docs/2_27/cmdstan-guide/cmdstan-installation.html}{link}. Una volta che è stato installato, il pacchetto \texttt{cmdstanr} può essere caricato come un qualsiasi altro pacchetto R.

Si noti che \texttt{cmdstanr} richiede un'installazione funzionante di \texttt{CmdStan}, l'interfaccia shell per Stan. Se \texttt{CmdStan} non è installato, \texttt{cmdstanr} lo installerà automaticamente se il computer dispone di una \emph{Toolchain} adatta. Stan richiede infatti che sul computer su cui viene installato siano presenti alcuni strumenti necessari per gestire i file C++. Tra le altre ragioni, questo è dovuto al fatto che il codice Stan viene tradotto in codice C++ e compilato. Il modo migliore per ottenere il software necessario per un computer Windows o Mac è quello di installare \texttt{RTools}. Per un computer Linux, è necessario installare \texttt{build-essential} e una versione recente dei compilatori g++ o clang++. I requisiti sono descritti nella \href{https://mc-stan.org/docs/cmdstan-guide/cmdstan-installation.html}{Guida di CmdStan}.

Per verificare che la Toolchain sia configurata correttamente è possibile utilizzare la funzione \texttt{check\_cmdstan\_toolchain()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{check\_cmdstan\_toolchain}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Se la toolchain è configurata correttamente, \texttt{CmdStan} può essere installato mediante la funzione \texttt{install\_cmdstan()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# do not run!}
\CommentTok{\# install\_cmdstan(cores = 2)}
\end{Highlighting}
\end{Shaded}

La versione installata di \texttt{CmdStan} si ottiene con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cmdstan\_version}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "2.28.2"}
\end{Highlighting}
\end{Shaded}

\hypertarget{codice-stan}{%
\section{Codice Stan}\label{codice-stan}}

Qualunque sia l'interfaccia che viene usata, i modelli sottostanti sono sempre scritti nel linguaggio Stan, il che significa che lo stesso codice Stan è valido per tutte le interfacce possibili. Il codice Stan è costituito da una serie di blocchi che vengono usati per specificare un modello statistico. In ordine, questi blocchi sono: \texttt{data}, \texttt{transformed\ data}, \texttt{parameters}, \texttt{transformed\ parameters}, \texttt{model}, e \texttt{generated\ quantities}.

\hypertarget{hello-world-stan}{%
\subsection{``Hello, world'' -- Stan}\label{hello-world-stan}}

Quando si studia un nuovo linguaggio di programmazione si utilizza spesso un programma ``Hello, world''. Questo è un modo semplice, spesso minimo, per dimostrare alcune delle sintassi di base del linguaggio. In Python, il programme ``Hello, world'' program è:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, world."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Qui presentiamo Stan e scriviamo un programma ``Hello, world'' per Stan.

Prima di scrivere il nostro primo programma ``Hello, world'' per Stan (che estrarrà campioni dalla distribuzione a posteriori di un modello gaussiano) spendiamo due parole per spiegare cosa fa Stan. Un utente scrive un modello usando il linguaggio Stan. Questo è solitamente memorizzato in un file di testo \texttt{.stan}. Il modello viene compilato in due passaggi. Innanzitutto, Stan traduce il modello nel file \texttt{.stan} in codice C++. Quindi, quel codice C++ viene compilato in codice macchina. Una volta creato il codice macchina, l'utente può, tramite l'interfaccia CmdStan, campionare la distribuzione definita dal modello ed eseguire altri calcoli con il modello. I risultati del campionamento vengono scritti su disco come file CSV e txt. Come mostrato di seguito, l'utente accede a questi file utilizzando varie funzioni \(\R\), senza interagire direttamente con loro.

Per iniziare, possiamo dire che un programma Stan contiene tre ``blocchi'' obbligatori: blocco \texttt{data}, blocco \texttt{parameters}, blocco \texttt{model}.

\hypertarget{blocco-data}{%
\subsection{\texorpdfstring{Blocco \texttt{data}}{Blocco data}}\label{blocco-data}}

Qui vengono dichiarate le variabili che saranno passate a Stan. Devono essere elencati i nomi delle variabili che saranno utilizzate nel programma, il \emph{tipo di dati} da registrare per ciascuna variabile, per esempio:

\begin{itemize}
\tightlist
\item
  \emph{int} = intero,
\item
  \emph{real} = numeri reali (ovvero, numeri con cifre decimali),
\item
  \emph{vector} = sequenze ordinate di numeri reali unidimensionali,
\item
  \emph{matrix} = matrici bidimensionali di numeri reali,
\item
  \emph{array} = sequenze ordinate di dati multidimensionali.
\end{itemize}

Devono anche essere dichiarate le dimensioni delle variabili e le eventuali restrizioni sulle variabili (es. \texttt{upper\ =\ 1} \texttt{lower\ =\ 0}, che fungono da controlli per Stan). Tutti i nomi delle variabili assegnate qui saranno anche usati negli altri blocchi del programma.

Per esempio, l'istruzione seguente dichiaria la variabile \texttt{Y} -- la quale rappresenta, ad esempio, l'altezza di 10 persone -- come una variabile di tipo \texttt{real{[}10{]}}. Ciò significa che specifichiamo un array di lunghezza 10, i cui elementi sono variabili continue definite sull'intervallo dei numeri reali \([-\infty, +\infty]\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data \{}
\NormalTok{  real Y[}\DecValTok{10}\NormalTok{]; }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ heights }\ControlFlowTok{for} \DecValTok{10}\NormalTok{ people}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Invece, con l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data \{}
\NormalTok{  int Y[}\DecValTok{10}\NormalTok{]; }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ qi }\ControlFlowTok{for} \DecValTok{10}\NormalTok{ people}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

dichiariamo la variabile \texttt{Y} -- la quale rappresenta, ad esempio, il QI di 10 persone -- come una variabile di tipo \texttt{int{[}10{]}}, ovvero un array di lunghezza 10, i cui elementi sono numeri naturali, cioè numeri interi non negativi \(\{0, +1, +2, +3, +4, \dots\}\).

Un altro esempio è

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data \{}
\NormalTok{  real}\SpecialCharTok{\textless{}}\NormalTok{lower}\OtherTok{=}\DecValTok{0}\NormalTok{, upper}\OtherTok{=}\DecValTok{1}\SpecialCharTok{\textgreater{}}\NormalTok{ Y[}\DecValTok{10}\NormalTok{]; }\SpecialCharTok{/}\ErrorTok{/} \DecValTok{10}\NormalTok{ proportions}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

nel quale viene specificato un array di lunghezza 10, i cui elementi sono delle variabili continue definite sull'intervallo dei numeri reali \([0, 1]\) --- per esempio, delle proporzioni.

Si noti che i tipi \texttt{vector} e \texttt{matrix} contengono solo elementi di tipo \texttt{real}, ovvero variabili continue, mentre gli \texttt{array} possono contenere dati di qualsiasi tipo. I dati passati a Stan devono essere contenuti in un oggetto del tipo \texttt{list}.

\hypertarget{blocco-parameters}{%
\subsection{\texorpdfstring{Blocco \texttt{parameters}}{Blocco parameters}}\label{blocco-parameters}}

I parametri che vengono stimati sono dichiarati nel blocco \texttt{parameters}. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{parameters \{}
\NormalTok{  real mu; }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ mean height }\ControlFlowTok{in}\NormalTok{ population}
\NormalTok{  real}\SpecialCharTok{\textless{}}\NormalTok{lower}\OtherTok{=}\DecValTok{0}\SpecialCharTok{\textgreater{}}\NormalTok{ sigma; }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ sd of height distribution}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

dichiaria la variabile \texttt{mu} che codifica l'altezza media nella popolazione, che è una variabile continua in un intervallo illimitato di valori, e la deviazione standard \texttt{sigma}, che è una variabile continua non negativa. Avremmo anche potuto specificare un limite inferiore di zero su \texttt{mu} perché deve essere non negativo.

Per una regressione lineare semplice, ad esempio, devono essere dichiarate le variabili corrispondenti all'intercetta (\texttt{alpha}), alla pendenza (\texttt{beta}) e alla deviazione standard degli errori attorno alla linea di regressione (\texttt{sigma}). In altri termini, nel blocco \texttt{parameters} devono essere elencati tutti i parametri che dovranno essere stimati dal modello. Si noti che parametri discreti non sono possibili. Infatti, Stan attualmente non supporta i parametri con valori interi, almeno non direttamente.

\hypertarget{blocco-model}{%
\subsection{\texorpdfstring{Blocco \texttt{model}}{Blocco model}}\label{blocco-model}}

Nel blocco \texttt{model} vengono elencate le dichiarazioni relative alla verosimiglianza dei dati e alle distribuzioni a priori dei parametri, come ad esempio, nelle istruzioni seguenti.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{model \{}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{    Y[i] }\SpecialCharTok{\textasciitilde{}} \FunctionTok{normal}\NormalTok{(mu, sigma);}
\NormalTok{  \}}
\NormalTok{  mu }\SpecialCharTok{\textasciitilde{}} \FunctionTok{normal}\NormalTok{(}\DecValTok{170}\NormalTok{, }\DecValTok{15}\NormalTok{); }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ prior }\ControlFlowTok{for}\NormalTok{ mu}
\NormalTok{  sigma }\SpecialCharTok{\textasciitilde{}} \FunctionTok{cauchy}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20}\NormalTok{); }\SpecialCharTok{/}\ErrorTok{/}\NormalTok{ prior }\ControlFlowTok{for}\NormalTok{ sigma}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Mediante l'istruzione all'interno del ciclo \texttt{for}, ciascun valore dell'altezza viene concepito come una variable casuale proveniente da una distribuzione Normale di parametri \(\mu\) e \(\sigma\) (i parametri di interesse nell'inferenza). Il ciclo \texttt{for} viene ripetuto 10 volte perché i dati sono costituiti da un array di 10 elementi (ovvero, il campione è costituito da 10 osservazioni).

Le due righe che seguno il ciclo \texttt{for} specificano le distribuzioni a priori dei parametri su cui vogliamo effettuare l'inferenza. Per \(\mu\) assumiamo una distribuzione a priori Normale di parametri \(\mu = 170\) e \(\sigma = 15\); per \(\sigma\) assumiamo una distribuzione a priori Cauchy(0, 20).

Se non viene definita alcuna distribuzione a priori, Stan utilizzerà la distribuzione a priori predefinita \(Unif(-\infty, +\infty)\). Raccomandazioni sulle distribuzioni a priori sono fornite in questo \href{https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations}{link}.

La precedente notazione di campionamento può anche essere espressa usando la seguente notazione alternativa:

\begin{Shaded}
\begin{Highlighting}[]
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{    target }\SpecialCharTok{+}\ErrorTok{=} \FunctionTok{normal\_lpdf}\NormalTok{(Y[i] }\SpecialCharTok{|}\NormalTok{ mu, sigma);}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

Questa notazione rende trasparente il fatto che, in pratica, Stan esegue un campionamento nello spazio

\[
\log p(\theta \mid y) \propto \log p(y \mid \theta) + \log p(\theta) = \sum_{i=1}^n \log p(y_i \mid \theta) + \log p(\theta).
\]

Per ogni passo MCMC, viene ottenuto un nuovo valore di \(\mu\) e \(\sigma\) eviene valutata la log densità a posteriori non normalizzata. Ad ogni passo MCMC, Stan calcola un nuovo valore della densità a posteriori su scala logaritmica partendo da un valore di 0 e incrementandola ogni volta che incontra un'istruzione \texttt{\textasciitilde{}}. Quindi, le istruzioni precedenti aumentano la log-densità di una quantità pari a \(\log (p(Y[i])) \propto -\frac{1}{2} \log(\sigma^2) - (Y[i]-\mu)^2 / 2\sigma^2\) per le altezze si ciascuno degli \(i=1 \dots, 10\) individui -- laddove la formula esprime, in termini logaritmici, la densità Normale da cui sono stati esclusi i termini costanti.

Oppure, in termini vettorializzati, il modello descritto sopra può essere espresso come

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{model \{}
\NormalTok{  Y }\SpecialCharTok{\textasciitilde{}} \FunctionTok{normal}\NormalTok{(mu, sigma);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

dove il termine a sinistra di \(\sim\) è un array. Questa notazione più compatta è anche la più efficiente.

\hypertarget{blocchi-opzionali}{%
\subsection{Blocchi opzionali}\label{blocchi-opzionali}}

Ci sono inoltre tre blocchi opzionali:

\begin{itemize}
\tightlist
\item
  Il blocco \texttt{transformed\ data} consente il pre-processing dei dati. È possibile trasformare i parametri del modello; solitamente ciò viene fatto nel caso dei modelli più avanzati per consentire un campionamento MCMC più efficiente.
\item
  Il blocco \texttt{transformed\ parameters} consente la manipolazione dei parametri prima del calcolo della distribuzione a posteriori.
\item
  Il blocco \texttt{generated\ quantities} consente il post-processing riguardante qualsiasi quantità che non fa parte del modello ma può essere calcolata a partire dai parametri del modello, per ogni iterazione dell'algoritmo. Esempi includono la generazione dei campioni a posteriori e le dimensioni degli effetti.
\end{itemize}

\hypertarget{sintassi}{%
\subsection{Sintassi}\label{sintassi}}

Si noti che il codice Stan richiede i punti e virgola (;) alla fine di ogni istruzione di assegnazione. Questo accade per le dichiarazioni dei dati, per le dichiarazioni dei parametri e ovunque si acceda ad un elemento di un tipo \texttt{data} e lo si assegni a qualcos'altro. I punti e virgola non sono invece richiesti all'inizio di un ciclo o di un'istruzione condizionale, dove non viene assegnato nulla.

In STAN, qualsiasi stringa che segue \texttt{//} denota un commento e viene ignorata dal programma.

Stan è un linguaggio estremamente potente e consente di implementare quasi tutti i modelli statistici, ma al prezzo di un certo sforzo di programmazione. Anche l'adattamento di semplici modelli statistici mediante il linguaggio STAN a volte può essere laborioso. Per molti modelli comunemente usati, come i modelli di regressione e multilivello, tale processo può essere semplificato usando le funzioni del pacchetto \texttt{brms}. D'altra parte, per modelli veramente complessi, non ci sono molte alternative all'uso di STAN. Per chi è curioso, il manuale del linguaggio Stan è accessibile al seguente \href{https://mc-stan.org/docs/2_27/stan-users-guide/index.html}{link}.

\hypertarget{workflow}{%
\section{Workflow}\label{workflow}}

Se usiamo \texttt{cmdstanr}, dobbiamo prima scrivere il codice con il modello statistico in un file in formato Stan. È necessario poi ``transpile'' quel file, ovvero tradurre il file in C++ e compilarlo. Ciò viene fatto mediante la funzione \texttt{cmdstan\_model()}. Possiamo poi eseguire il campionamento MCMC con il metodo \texttt{\$sample()}. Infine è possibile creare un sommario dei risultati usando, per esempio, usando il metodo \texttt{\$summary()}.

\hypertarget{ciao-stan}{%
\section{Ciao, Stan}\label{ciao-stan}}

Scriviamo ora il nostro programma Stan ``Hello, world'' per generare campioni da una distribuzione Normale standard (con media zero e varianza unitaria).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{modelString }\OtherTok{=} \StringTok{"}
\StringTok{parameters \{}
\StringTok{  real x;}
\StringTok{\}}
\StringTok{model \{}
\StringTok{  x \textasciitilde{} normal(0, 1);}
\StringTok{\}}
\StringTok{"}
\FunctionTok{writeLines}\NormalTok{(modelString, }\AttributeTok{con =} \StringTok{"code/hello\_world.stan"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si noti che ci sono solo due blocchi in questo particolare codice Stan, il blocco parametri e il blocco modello. Questi sono due dei sette blocchi possibili in un codice Stan. Nel blocco parametri, abbiamo i nomi e i tipi di parametri per i quali vogliamo ottenere i campioni. In questo caso, vogliamo ottenere campioni di numeri reale che chiamiamo \texttt{x}. Nel blocco modello, abbiamo il nostro modello statistico. Specifichiamo che x, il parametro di cui vogliamo ottenere i campioni, è normalmente distribuito con media zero e deviazione standard unitaria. Ora che abbiamo il nostro codice (che è stato memorizzato in un file chiamato \texttt{hello\_world.stan}), possiamo usare CmdStan per compilarlo e ottenere \texttt{mod}, che è un oggetto \(\R\) che fornisce l'accesso all'eseguibile Stan compilato.

Leggiamo il file in cui abbiamo salvato il codice Stan

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{file }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(}\StringTok{"code"}\NormalTok{, }\StringTok{"hello\_world.stan"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

compiliamo il modello

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod }\OtherTok{\textless{}{-}} \FunctionTok{cmdstan\_model}\NormalTok{(file)}
\end{Highlighting}
\end{Shaded}

ed eseguiamo il campionamento MCMC:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ mod}\SpecialCharTok{$}\FunctionTok{sample}\NormalTok{(}
  \AttributeTok{iter\_sampling =}\NormalTok{ 4000L,}
  \AttributeTok{iter\_warmup =}\NormalTok{ 2000L,}
  \AttributeTok{seed =}\NormalTok{ SEED,}
  \AttributeTok{chains =}\NormalTok{ 4L,}
  \AttributeTok{refresh =} \DecValTok{0}\NormalTok{,}
  \AttributeTok{thin =} \DecValTok{1}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Tasformiamo l'oggetto \texttt{fit} nel formato \texttt{stanfit} per manipolarlo più facilmente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stanfit }\OtherTok{\textless{}{-}}\NormalTok{ rstan}\SpecialCharTok{::}\FunctionTok{read\_stan\_csv}\NormalTok{(fit}\SpecialCharTok{$}\FunctionTok{output\_files}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

Lo esaminiamo

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(stanfit}\SpecialCharTok{@}\NormalTok{sim}\SpecialCharTok{$}\NormalTok{samples)}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

Quello che abbiamo ottenuto sono 4 catene di 4000 osservazioni ciascuna, le quali contengono valori casuali estratti dalla gaussiana standardizzata:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(stanfit}\SpecialCharTok{@}\NormalTok{sim}\SpecialCharTok{$}\NormalTok{samples[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

Verifichiamo

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(stanfit}\SpecialCharTok{@}\NormalTok{sim}\SpecialCharTok{$}\NormalTok{samples[[}\DecValTok{1}\NormalTok{]][, }\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-84-1} \end{center}

\hypertarget{inference-one-prop}{%
\chapter{Inferenza su una proporzione con Stan}\label{inference-one-prop}}

Il Capitolo \ref{chapter-ppc} discute il codice Stan necessario per calcolare \(p(y^{rep} \mid y)\) nel caso dell'inferenza su una proporzione. Questa Appendice approfondisce alcuni aspetti di tale analisi statistica.

Assumiamo che il codice Stan descritto nel Capitolo \ref{chapter-ppc} abbia prodotto l'oggetto \texttt{fit}.

Trasformiamo \texttt{fit} in un oggetto di classe \texttt{stanfit}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stanfit }\OtherTok{\textless{}{-}}\NormalTok{ rstan}\SpecialCharTok{::}\FunctionTok{read\_stan\_csv}\NormalTok{(fit}\SpecialCharTok{$}\FunctionTok{output\_files}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

e esaminiamo il risultato ottenuto. Per i dati dell'esempio, l'esatta distribuzione a posteriori è una Beta(25, 17):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarize\_beta\_binomial}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{2}\NormalTok{, }\AttributeTok{beta =} \DecValTok{10}\NormalTok{, }\AttributeTok{y =} \DecValTok{23}\NormalTok{, }\AttributeTok{n =} \DecValTok{30}\NormalTok{)}
\CommentTok{\#\textgreater{}       model alpha beta   mean mode      var      sd}
\CommentTok{\#\textgreater{} 1     prior     2   10 0.1667  0.1 0.010684 0.10336}
\CommentTok{\#\textgreater{} 2 posterior    25   17 0.5952  0.6 0.005603 0.07485}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot\_beta}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{25}\NormalTok{, }\AttributeTok{beta =} \DecValTok{17}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{lims}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-89-1} \end{center}

L'approssimazione della distribuzione a posteriori per \(\theta\) ottenuta mediante la simulazione MCMC è

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mcmc\_dens}\NormalTok{(stanfit, }\AttributeTok{pars =} \StringTok{"theta"}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{lims}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-90-1} \end{center}

La funzione \texttt{tidy()} nel pacchetto \texttt{broom.mixed} fornisce alcune utili statistiche per i 16000 valori della catena Markov memorizzati in \texttt{stanfit}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{broom.mixed}\SpecialCharTok{::}\FunctionTok{tidy}\NormalTok{(}
\NormalTok{  stanfit, }
  \AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{, }
  \AttributeTok{conf.level =} \FloatTok{0.95}\NormalTok{, }
  \AttributeTok{pars =} \StringTok{"theta"}
\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 5}
\CommentTok{\#\textgreater{}   term  estimate std.error conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 theta    0.596    0.0746    0.445     0.734}
\end{Highlighting}
\end{Shaded}

laddove, per esempio, la media esatta della corretta distribuzione a posteriori è

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{25} \SpecialCharTok{/}\NormalTok{ (}\DecValTok{25} \SpecialCharTok{+} \DecValTok{17}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.5952}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{tidy()} non consente di calcolare altre statistiche descrittive, oltre alla media. Ma questo risultato può essere ottenuto direttamente utilizzando i valori delle catene di Markov. Iniziamo ad esaminare il contenuto dell'oggetto \texttt{stanfit}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list\_of\_draws }\OtherTok{\textless{}{-}} \FunctionTok{extract}\NormalTok{(stanfit)}
\FunctionTok{print}\NormalTok{(}\FunctionTok{names}\NormalTok{(list\_of\_draws))}
\CommentTok{\#\textgreater{} [1] "theta"   "y\_rep"   "log\_lik" "lp\_\_"}
\end{Highlighting}
\end{Shaded}

Possiamo estrarre i campioni della distribuzione a posteriori nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(list\_of\_draws}\SpecialCharTok{$}\NormalTok{theta)}
\CommentTok{\#\textgreater{} [1] 0.5841 0.6536 0.7287 0.6072 0.6657 0.6527}
\end{Highlighting}
\end{Shaded}

Creiamo un data.frame con le stime a posteriori \(\hat{\theta}\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{theta =}\NormalTok{ list\_of\_draws}\SpecialCharTok{$}\NormalTok{theta}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le statistiche descrittive della distribuzione a posteriori possono ora essere ottenute usando direttamente i valori \(\hat{\theta}\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarize}\NormalTok{(}
    \AttributeTok{post\_mean =} \FunctionTok{mean}\NormalTok{(theta), }
    \AttributeTok{post\_median =} \FunctionTok{median}\NormalTok{(theta),}
    \AttributeTok{post\_mode =} \FunctionTok{sample\_mode}\NormalTok{(theta),}
    \AttributeTok{lower\_95 =} \FunctionTok{quantile}\NormalTok{(theta, }\FloatTok{0.025}\NormalTok{),}
    \AttributeTok{upper\_95 =} \FunctionTok{quantile}\NormalTok{(theta, }\FloatTok{0.975}\NormalTok{)}
\NormalTok{  )}
\CommentTok{\#\textgreater{}   post\_mean post\_median post\_mode lower\_95 upper\_95}
\CommentTok{\#\textgreater{} 1    0.5946      0.5958    0.5955   0.4451   0.7345}
\end{Highlighting}
\end{Shaded}

È anche possibile calcolare, ad esempio, la probabilità di \(\hat{\theta} > 0.5\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{exceeds =}\NormalTok{ theta }\SpecialCharTok{\textgreater{}} \FloatTok{0.50}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
\NormalTok{  janitor}\SpecialCharTok{::}\FunctionTok{tabyl}\NormalTok{(exceeds)}
\CommentTok{\#\textgreater{}  exceeds     n percent}
\CommentTok{\#\textgreater{}    FALSE  1706  0.1066}
\CommentTok{\#\textgreater{}     TRUE 14294  0.8934}
\end{Highlighting}
\end{Shaded}

\hypertarget{least-squares}{%
\chapter{Minimi quadrati}\label{least-squares}}

Nella trattazione classica del modello di regressione, \(y_i = \alpha + \beta x_i + e_i\), i coefficienti \(a = \hat{\alpha}\) e \(b = \hat{\beta}\) vengono stimati in modo tale da minimizzare i residui

\begin{equation}
e_i = y_i - \hat{\alpha} - \hat{\beta} x_i.
\label{eq:residuals}
\end{equation}

In altri termini, il residuo \(i\)-esimo è la differenza fra l'ordinata del punto (\(x_i\), \(y_i\)) e quella del punto di ascissa \(x_i\) sulla retta di regressione campionaria.

Per determinare i coefficienti \(a\) e \(b\) della retta \(y_i = a + b x_i + e_i\) non è sufficiente minimizzare la somma dei residui \(\sum_{i=1}^{n}e_i\), in quanto i residui possono essere sia positivi che negativi e la loro somma può essere molto prossima allo zero anche per differenze molto grandi tra i valori osservati e la retta di regressione. Infatti, ciascuna retta passante per il punto (\(\bar{x}, \bar{y}\)) ha \(\sum_{i=1}^{n}e_i=0\).

Una retta passante per il punto (\(\bar{x}, \bar{y}\)) soddisfa l'equazione \(\bar{y} = a + b \bar{x}\). Sottraendo tale equazione dall'equazione \(y_i = a + b x_i + e_i\) otteniamo

\[
y_i - \bar{y} =  b (x_i - \bar{x}) + e_i. 
\]

Sommando su tutte le osservazioni, si ha che

\begin{equation}
\sum_{i=1}^n e_i = \sum_{i=1}^n (y_i - \bar{y} ) -  b \sum_{i=1}^n (x_i - \bar{x}) = 0 - b(0) = 0. 
\label{eq:res-sum-zero}
\end{equation}

Questo problema viene risolto scegliendo i coefficienti \(a\) e \(b\) che minimizzano, non tanto la somma dei residui, ma bensì l'\emph{errore quadratico}, cioè la somma dei quadrati degli errori:

\begin{equation}
S(a, b) = \sum_{i=1}^{n} e_i^2 = \sum (y_i - a - b x_i)^2.
\end{equation}

Il metodo più diretto per determinare quelli che vengono chiamati i \emph{coefficienti dei minimi quadrati} è quello di trovare le derivate parziali della funzione \(S(a, b)\) rispetto ai coefficienti \(a\) e \(b\):

\begin{align}
\frac{\partial S(a,b)}{\partial a} &= \sum (-1)(2)(y_i - a - b x_i), \notag \\
\frac{\partial S(a,b)}{\partial b} &= \sum (-x_i)(2)(y_i - a - b x_i).
\end{align}

Ponendo le derivate uguali a zero e dividendo entrambi i membri per \(-2\) si ottengono le \emph{equazioni normali}

\begin{align}
 an + b \sum x_i &= \sum y_i, \notag \\
 a \sum x_i + b \sum x_i^2 &= \sum x_i y_i. 
 \label{eq:form-normali}
\end{align}

I coefficienti dei minimi quadrati \(a\) e \(b\) si trovano risolvendo le \eqref{eq:form-normali} e sono uguali a:

\begin{align}
a &= \bar{y} - b \bar{x},\\
b &= \frac{\sum (x_i - \bar{x}) (y_i - \bar{y})}{\sum (x_i - \bar{x})^2}.
\label{eq:minsq-ab}
\end{align}

\hypertarget{massima-verosimiglianza}{%
\subsection{Massima verosimiglianza}\label{massima-verosimiglianza}}

Se gli errori del modello lineare sono indipendenti e distribuiti secondo una Normale, così che \(y_i \sim \mathcal{N}(\alpha + \beta x, \sigma^2)\) per ciascun \(i\), allora le stime dei minimi quadrati di \(\alpha\) e \(\beta\) corrispondono alla stima di massima verosimiglianza. La funzione di verosimiglianza del modello di regressione è definita come la funzione di densità di probabilità dei dati, dati i parametri e i predittori:

\begin{equation}
p(y \mid \alpha, \beta, \sigma, x) = \prod_{i=1}^n \mathcal{N}(y_i \mid \alpha, \beta x_i, \sigma^2). 
\label{eq:ml-reg}
\end{equation}

Massimizzare la \eqref{eq:ml-reg} conduce alle stime dei minimi quadrati \eqref{eq:minsq-ab}.

\hypertarget{introduzione-al-linguaggio-r}{%
\chapter{Introduzione al linguaggio R}\label{introduzione-al-linguaggio-r}}

In questa sezione della dispensa saranno presentate le caratteristiche di base e la filosofia dell'ambiente \texttt{R}, passando poi a illustrare le strutture dati e le principali strutture di controllo. Verranno introdotte alcune funzioni utili per la gestione dei dati e verranno forniti i rudimenti per realizzare semplici funzioni. Verranno introdotti i tipi di file editabili in RStudio (script, markdown, \ldots). Nello specifico, dopo aver accennato alcune caratteristiche del sistema \texttt{tidyverse}, verranno illustrate le principali funzionalità dell'IDE RStudio e dei pacchetti \texttt{dplyr} e \texttt{ggplot2}. Sul web sono disponibili tantissime introduzioni all'uso di \texttt{R} come, ad esempio, \href{https://rstudio-education.github.io/hopr/}{Hands-On Programming with R}, \href{https://r4ds.had.co.nz}{R for Data Science}, \href{https://bookdown.org/hneth/ds4psy/}{Data Science for Psychologists}, e \href{https://bookdown.org/hneth/i2ds/}{Introduction to Data Science}.

\hypertarget{prerequisiti}{%
\section{Prerequisiti}\label{prerequisiti}}

Al fine di utilizzare \texttt{R} è necessario eseguire le seguenti tre operazioni nell'ordine dato:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Installare \texttt{R};
\item
  Installare RStudio;
\item
  Installare R-Packages (se necessario).
\end{enumerate}

Di seguito viene descritto come installare \texttt{R} e RStudio.

\hypertarget{installare-r-e-rstudio}{%
\subsection{Installare R e RStudio}\label{installare-r-e-rstudio}}

\(\R\) è disponibile gratuitamente ed è scaricabile dal sito \url{http://www.rproject.org/}. Dalla pagina principale del sito \texttt{r-project.org} andiamo sulla sezione \texttt{Download} e scegliamo un server a piacimento per scaricare il software d'installazione. Una volta scaricato l'installer, lo installiamo come un qualsiasi software, cliccando due volte sul file d'istallazione. Esistono versioni di \(\R\) per tutti i più diffusi sistemi operativi (Windows, Mac OS X e Linux).

Il R Core Development Team lavora continuamente per migliorare le prestazioni di \(\R\), per correggere errori e per consentire l'uso di con nuove tecnologie. Di conseguenza, periodicamente vengono rilasciate nuove versioni di \(\R\). Informazioni a questo proposito sono fornite sulla pagina web \url{https://www.r-project.org/}. Per installare una nuova versione di \(\R\) si segue la stessa procedura che è stata seguita per la prima installazione.

Insieme al software si possono scaricare dal sito principale sia manuali d'uso che numerose dispense per approfondire diversi aspetti di \(\R\). In particolare, nel sito \url{http://cran.r-project.org/other-docs.html} si possono trovare anche numerose dispense in italiano (sezione ``Other languages'').

Dopo avere installato \(\R\) è opportuno installare anche RStudio. RStudio si può scaricare da \url{https://www.rstudio.com/}. Anche RStudio è disponibile per tutti i più diffusi sistemi operativi.

\hypertarget{utilizzare-rstudio-per-semplificare-il-lavoro}{%
\subsection{Utilizzare RStudio per semplificare il lavoro}\label{utilizzare-rstudio-per-semplificare-il-lavoro}}

Possiamo pensare ad \(\R\) come al motore di un automobile e a RStudio come al cruscotto di un automobile. Più precisamente, \(\R\) è un linguaggio di programmazione che esegue calcoli mentre RStudio è un ambiente di sviluppo integrato (IDE) che fornisce un'interfaccia grafica aggiungendo una serie di strumenti che facilitano la fase di sviluppo e di esecuzione del codice. Utilizzeremo dunque \(\R\) mediante RStudio. In altre parole,

\textbf{non aprite}

\includegraphics[width=0.15\textwidth,height=\textheight]{images/Rlogo.png}

\textbf{aprite invece}

\includegraphics[width=0.3\textwidth,height=\textheight]{images/RStudio-Logo-Blue-Gradient.png}

L'ambiente di lavoro di RStudio è costituito da quattro finestre: la finestra del codice (scrivere-eseguire script), la finestra della console (riga di comando - output), la finestra degli oggetti (elenco oggetti-cronologia dei comandi) e la finestra dei pacchetti-dei grafici-dell'aiuto in linea.

\begin{figure}
\hypertarget{fig:rstudio_pics}{%
\centering
\includegraphics[width=1\textwidth,height=\textheight]{images/rstudio_pics.png}
\caption{La console di RStudio.}\label{fig:rstudio_pics}
}
\end{figure}

\hypertarget{eseguire-il-codice}{%
\subsection{Eseguire il codice}\label{eseguire-il-codice}}

Mediante il menu a tendina di RStudio, scegliendo il percorso

\begin{verbatim}
File > New File > R Notebook
\end{verbatim}

oppure

\begin{verbatim}
File > New File > R Script
\end{verbatim}

l'utente può aprire nella finestra del codice (in alto a destra) un \(\R\) Notebook o un \(\R\) script dove inserire le istruzioni da eseguire.

In un \(\R\) script, un blocco di codice viene eseguito selezionando un insieme di righe di istruzioni e digitando la sequenza di tasti \texttt{Command} + \texttt{Invio} sul Mac, oppure \texttt{Control} + \texttt{Invio} su Windows. In un R Notebook, un blocco di codice viene eseguito schiacciando il bottone con l'icona \(\color{red}\blacktriangleright\) (``Run current chunk'') posizionata a destra rispetto al codice.

\hypertarget{installare-cmdstan}{%
\section{\texorpdfstring{Installare \texttt{cmdstan}}{Installare cmdstan}}\label{installare-cmdstan}}

È possibile installare \texttt{cmdstan} in almento tre modi. Per informazioni dettagliate, si vedano le istruzioni \href{https://mc-stan.org/docs/2_28/cmdstan-guide/cmdstan-installation.html}{CmdStan Installation}.

Prima di installare \texttt{cmdstan}, tre raccomandazioni generali:

\begin{itemize}
\tightlist
\item
  usare la versione più recente del sistema operativo;
\item
  usare la versione più recente di RStudio;
\item
  usare la versione più recente di \(\R\).
\end{itemize}

Se i tre vincoli precedenti sono soddisfatti, l'installazione di \texttt{cmdstan} dovrebbe procedere senza intoppi. Altrimenti si possono creare dei problemi di non facile soluzione.

Il modo più semplice per installare \texttt{cmdstan} è quello di installare prima \href{https://mc-stan.org/cmdstanr/}{cmdstanr} per poi utilizzare le funzionalità di quel pacchetto per l'installazione di \texttt{cmdstan}.

Un secondo metodo (che è quello che io uso normalmente) è quello di installare dal sorgente, seguendo le istruzioni riportante su \href{https://mc-stan.org/docs/2_28/cmdstan-guide/cmdstan-installation.html}{CmdStan Installation}.

Un terzo metodo (che richiede una minima comprensione delle funzionalità della shell e di Python) richiede, avendo prima installato \href{https://www.anaconda.com/products/individual}{Anaconda}, di digitare sulla console del proprio computer (la shell) le seguenti istruzioni:

\begin{verbatim}
conda create -n stan-env -c conda-forge cmdstan
conda activate stan-env
\end{verbatim}

Su \texttt{macos}, prima di installare \texttt{cmdstan}, è necessario installare la versione più recente di Xcode. Dopo avere installato Xcode, aprire la app. Verrà chiesto all'utente se si vogliono istallare delle componenti aggiuntive. Questo passaggio è cruciale, perché senza queste componenti aggiuntive \texttt{cmdstan} non funzionerà. Dopo avere installato le componenti aggiuntive, aprire Xcode e, in caso, accettare i termini della licenza. A quel punto si può chiudere Xcode. Ogni volta che Xcode viene aggiornato (deve sempre essere aggiornato quando un aggiornamento è disponibile), queste operazioni vanno ripetute.

\hypertarget{chapter-sintassi}{%
\section{Sintassi di base}\label{chapter-sintassi}}

\texttt{R} è un linguaggio di programmazione orientato all'analisi dei dati, il calcolo e la visualizzazione grafica. È disponibile su Internet una vasta gamma di materiali utile per avvicinarsi all'ambiente \texttt{R} e aiutare l'utente nell'apprendimento di questo software statistico. Cercheremo qui di fornire alcune indicazioni e una breve descrizione delle risorse di base di \texttt{R}.

Aggiungo qui sotto alcune considerazioni che ho preso, pari pari, da un testo che tratta di un altro linguaggio di programmazione, ma che si applicano perfettamente anche al caso nostro. \emph{``Come in ogni linguaggio, per parlare in R è necessario seguire un insieme di regole. Come in tutti i linguaggi di programmazione, queste regole sono del tutto inflessibili e inderogabili. In R, un enunciato o è sintatticamente corretto o è incomprensibile all'interprete, che lo segnalerà all'utente. Questo aspetto non è esattamente amichevole per chi non è abituato ai linguaggi di programmazione, e si trova così costretto ad una precisione di scrittura decisamente poco''analogica''. Tuttavia, ci sono due aspetti positivi nello scrivere codice, interrelati tra loro. Il primo è lo sforzo analitico necessario, che allena ad un'analisi precisa del problema che si vuole risolvere in modo da poterlo formalizzare linguisticamente. Il secondo concerne una forma di autoconsapevolezza specifica: salvo ``bachi'' nel linguaggio (rarissimi sebbene possibili), il mantra del programmatore è ``Se qualcosa non ti funziona, è colpa tua''} (testo adattato da Andrea Valle).

A chi preferisce un approccio più ``giocoso'' posso suggerire il seguente \href{https://tinystats.github.io/teacups-giraffes-and-statistics/01_introToR.html}{link}.

\hypertarget{utilizzare-la-console-r-come-calcolatrice}{%
\subsection{\texorpdfstring{Utilizzare la console \texttt{R} come calcolatrice}{Utilizzare la console R come calcolatrice}}\label{utilizzare-la-console-r-come-calcolatrice}}

La console di RStudio contiene un cursore rappresentato dal simbolo ``\textgreater{}'' (linea di comando) dove si possono inserire i comandi e le funzioni -- in realtà è sempre meglio utilizzare un \texttt{R} Notebook anziché la console, ma per ora esaminiamo il funzionamento di quest'ultima.

La console di RStudio può essere utilizzata come semplice calcolatrice. I comandi elementari consistono di espressioni o di assegnazioni. Le operazioni aritmetiche vengono eseguite mediante simboli ``standard:'' +, *, -, /, \texttt{sqrt()}, \texttt{log()}, \texttt{exp()}, \ldots{}

I comandi sono separati da un carattere di nuova linea (si immette un carattere di nuova linea digitando il tasto \texttt{Invio}). Se un comando non è completo alla fine della linea, \texttt{R} darà un prompt differente che per default è il carattere \texttt{+} sulla linea seguente e continuerà a leggere l'input finché il comando non è sintatticamente completo. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{4} \SpecialCharTok{{-}}
\SpecialCharTok{+} 
\SpecialCharTok{+} \DecValTok{1}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

\texttt{R} è un ambiente interattivo, ossia i comandi producono una risposta immediata. Se scriviamo \texttt{2\ +\ 2} e premiamo il tasto di invio, comparirà nella riga successiva il risultato:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{+} \DecValTok{2}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

Il risultato è preceduto da \texttt{{[}1{]}}, il che significa che il risultato dell'operazione che abbiamo appena eseguito è il primo valore di questa linea. Alcune funzioni ritornano più di un singolo numero e, in quel caso, l'informazione fornita da \texttt{R} è più utile. Per esempio, l'istruzione \texttt{100:130} ritorna \(31\) valori, ovvero i numeri da \(100\) a \(130\):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{100}\SpecialCharTok{:}\DecValTok{130}
\CommentTok{\#\textgreater{}  [1] 100 101 102 103 104 105 106 107 108 109 110 111}
\CommentTok{\#\textgreater{} [13] 112 113 114 115 116 117 118 119 120 121 122 123}
\CommentTok{\#\textgreater{} [25] 124 125 126 127 128 129 130}
\end{Highlighting}
\end{Shaded}

In questo caso, sul mio computer, \texttt{{[}24{]}} indica che il valore \(123\) è il ventiquattresimo numero che è stato stampato sulla console -- su un altro computer le cose possono essere diverse in quanto il risultato, credo, dipende dalla grandezza dello schermo.

\hypertarget{espressioni}{%
\subsection{Espressioni}\label{espressioni}}

In questo corso, cercheremo di evitare i numeri nei nomi R, così come le lettere maiuscole e .. Useremo quindi nomi come: my\_data, anova\_results, square\_root, ecc.

Un'espressione in \texttt{R} è un enunciato finito e autonomo del linguaggio: una frase conclusa, si potrebbe dire. Si noti che le espressioni in \texttt{R} non sono delimitate dal \texttt{;} come succede in alcuni linguaggi di programmazione. L'ordine delle espressioni è l'ordine di esecuzione delle stesse.

L'a capo non è rilevante per \texttt{R}. Questo permette di utilizzare l'a capo per migliorare la leggibilità del codice.

\hypertarget{oggetti}{%
\subsection{Oggetti}\label{oggetti}}

\texttt{R} è un linguaggio di programmazione a oggetti, quindi si basa sulla creazione di oggetti e sulla possibilità di salvarli nella memoria del programma. \texttt{R} distingue tra maiuscole e minuscole come la maggior parte dei linguaggi basati su UNIX, quindi \texttt{A} e \texttt{a} sono nomi diversi e fanno riferimento a oggetti diversi.

I comandi elementari di \texttt{R} consistono in espressioni o assegnazioni.

Se un'espressione viene fornita come comando, viene valutata, stampata sullo schermo e il valore viene perso, come succedeva alle operazioni aritmetiche che abbiamo presentato sopra discutendo l'uso della console \texttt{R} come calcolatrice.

Un'assegnazione crea un oggetto oppure valuta un'espressione e passa il valore a un oggetto, ma il risultato non viene stampato automaticamente sullo schermo. Per l'operazione di assegnazione si usa il simbolo \texttt{\textless{}-}. Ad esempio, per creare un oggetto che contiene il risultato dell'operazione \texttt{2\ +\ 2} procediamo nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res\_sum }\OtherTok{\textless{}{-}} \DecValTok{2} \SpecialCharTok{+} \DecValTok{2}
\NormalTok{res\_sum}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

L'operazione di assegnazione (\texttt{\textless{}-}) copia il contenuto dell'operando destro (detto \texttt{r-value}) nell'operando sinistro detto (\texttt{l-value}). Il valore dell'espressione assegnazione è \texttt{r-value}. Nell'esempio precedente, \texttt{res\_sum} (\texttt{l-value}) assume il valore di \(4\).

\hypertarget{variabili}{%
\subsection{Variabili}\label{variabili}}

L'oggetto \texttt{res\_sum} è una \emph{variabile}. Una spiegazione di ciò che questo significa è riportata qui sotto. \emph{``Una variabile è un segnaposto. Tutte le volte che si memorizza un dato lo si assegna ad una variabile. Infatti, se il dato è nella memoria, per potervi accedere, è necessario conoscere il suo indirizzo, la sua ``etichetta'' (come in un grande magazzino in cui si va a cercare un oggetto in base alla sua collocazione). Se il dato è memorizzato ma inaccessibile (come nel caso di un oggetto sperso in un magazzino), allora non si può usare ed è soltanto uno spreco di spazio. La teoria delle variabili è un ambito molto complesso nella scienza della computazione. Ad esempio, una aspetto importante può concernere la tipizzazione delle variabili. Nei linguaggi ``tipizzati'' (ad esempio C), l'utente dichiara che userà quella etichetta (la variabile) per contenere solo ed esclusivamente un certo tipo di oggetto (ad esempio, un numero intero), e la variabile non potrà essere utilizzata per oggetti diversi (ad esempio, una stringa). In questo caso, prima di usare una variabile se ne dichiara l'esistenza e se ne specifica il tipo. I linguaggi non tipizzati non richiedono all'utente di specificare il tipo, che viene inferito in vario modo (ad esempio, in funzione dell'assegnazione del valore alla variabile). Alcuni linguaggi (ad esempio Python) non richiedono neppure la dichiarazione della variabile, che viene semplicemente usata. È l'interprete che inferisce che quella stringa è una variabile. La tipizzazione impone vincoli d'uso sulle variabili e maggiore scrittura del codice, ma assicura una chiara organizzazione dei dati. In assenza di tipizzazione, si lavora in maniera più rapida e snella, ma potenzialmente si può andare incontro a situazioni complicate, come quando si cambia il tipo di una variabile ``in corsa'' senza accorgersene'' (Andrea Valle).}

\texttt{R} è un linguaggio non tipicizzato, come Python. In \texttt{R} non è necessario dichiarare le variabili che si intendono utilizzare, né il loro tipo.

\hypertarget{r-console}{%
\subsection{R console}\label{r-console}}

La console di RStudio fornisce la possibilità di richiamare e rieseguire i comandi. I tasti freccia verticale, \(\uparrow\) e \(\downarrow\), sulla tastiera possono essere utilizzati per scorrere avanti e indietro i comandi già immessi. Appena trovato il comando che interessa, lo si può modificare, ad esempio, con i tasti freccia orizzontali, immettendo nuovi caratteri o cancellandone altri.

Se viene digitato un comando che \texttt{R} non riconosce, sulla console viene visualizzato un messaggio di errore; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\NormalTok{ \% }\DecValTok{9}
\NormalTok{Errore}\SpecialCharTok{:}\NormalTok{ unexpected input }\ControlFlowTok{in} \StringTok{"3 \% 9"}
\end{Highlighting}
\end{Shaded}

\hypertarget{parentesi}{%
\subsection{Parentesi}\label{parentesi}}

Le parentesi in \texttt{R} (come in generale in ogni linguaggio di programmazione) assegnano un significato diverso alle porzioni di codice che delimitano.

\begin{itemize}
\tightlist
\item
  Le parentesi tonde funzionano come nell'algebra. Per esempio
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*} \DecValTok{4}
\CommentTok{\#\textgreater{} [1] 14}
\end{Highlighting}
\end{Shaded}

non è equivalente a

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3}\NormalTok{) }\SpecialCharTok{*} \DecValTok{4}
\CommentTok{\#\textgreater{} [1] 20}
\end{Highlighting}
\end{Shaded}

Le due istruzioni precedenti producono risultati diversi perché, se la sequenza delle operazioni algebriche non viene specificata dalle parentesi, \texttt{R} assegna alle operazioni algebriche il seguente ordine di priorità decrescente: esponenziazione, moltiplicazione / divisione, addizione / sottrazione, confronti logici (\texttt{\textless{},\ \textgreater{},\ \textless{}=,\ \textgreater{}=,\ ==,\ !=}). È sempre una buona idea rendere esplicito l'ordine delle operazioni algebriche che si vuole eseguire mediante l'uso delle parentesi tonde.\\
Le parentesi tonde vengono anche utilizzate per le funzioni, come vedremo nei prossimi paragrafi. Tra le parentesi tonde avremo dunque l'oggetto a cui vogliamo applicare la funzione e gli argomenti passati alla funzione.

\begin{itemize}
\item
  Le parentesi graffe sono destinate alla programmazione. Un blocco tra le parentesi graffe viene letto come un oggetto unico che può contenere una o più istruzioni.
\item
  Le parentesi quadre vengono utilizzate per selezionare degli elementi, per esempio all'interno di un vettore, o di una matrice, o di un data.frame. L'argomento entro le parentesi quadre può essere generato da espressioni logiche.
\end{itemize}

\hypertarget{i-nomi-degli-oggetti}{%
\subsection{I nomi degli oggetti}\label{i-nomi-degli-oggetti}}

Le entità create e manipolate da \texttt{R} si chiamano `oggetti'. Tali oggetti possono essere variabili (come nell'esempio che abbiamo visto sopra), array di numeri, caratteri, stringhe, funzioni, o più in generale strutture costruite a partire da tali componenti. Durante una sessione di R gli oggetti sono creati e memorizzati attraverso opportuni nomi.

I nomi possono contenere un qualunque carattere alfanumerico e come carattere speciale il trattino basso (\texttt{\_}) o il punto. R fornisce i seguenti vincoli per i nomi degli oggetti: i nomi degli oggetti non possono mai iniziare con un carattere numerico e non possono contenere i seguenti simboli: \texttt{\$}, \texttt{@}, \texttt{!}, \texttt{\^{}}, \texttt{+}, \texttt{-}, \texttt{/}, \texttt{*}. È buona pratica usare nomi come \texttt{ratio\_of\_sums}. È fortemente sconsigliato utilizzare nei nomi degli oggetti caratteri accentati o, ancora peggio, apostrofi. Per questa ragione è sensato creare i nomi degli oggetti utilizzando la lingua inglese. È anche bene che i nomi degli oggetti non coincidano con nomi di funzioni. Ricordo nuovamente che \texttt{R} è \emph{case sensitive}, cioè \texttt{A} e \texttt{a} sono due simboli diversi e identificano due oggetti differenti.

In questo corso cercheremo di evitare i numeri nei nomi degli oggetti \texttt{R}, così come le lettere maiuscole e il punto. Useremo quindi nomi come: \texttt{my\_data}, \texttt{regression\_results}, \texttt{square\_root}, ecc.

\hypertarget{permanenza-dei-dati-e-rimozione-di-oggetti}{%
\subsection{Permanenza dei dati e rimozione di oggetti}\label{permanenza-dei-dati-e-rimozione-di-oggetti}}

Gli oggetti vengono salvati nello ``spazio di lavoro'' (\emph{workspace}). Il comando \texttt{ls()} può essere utilizzato per visualizzare i nomi degli oggetti che sono in quel momento memorizzati in \texttt{R}.

Per eliminare oggetti dallo spazio di lavoro è disponibile la funzione \texttt{rm()}; ad esempio

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(x, y, z, ink, junk, temp, foo, bar)}
\end{Highlighting}
\end{Shaded}

cancella tutti gli oggetti indicati entro parentesi. Per eliminare tutti gli oggetti presenti nello spazio di lavoro si può utilizzare la seguente istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(}\AttributeTok{list =} \FunctionTok{ls}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\hypertarget{chiudere-r}{%
\subsection{Chiudere R}\label{chiudere-r}}

Quando si chiude RStudio il programma ci chiederà se si desidera salvare l'area di lavoro sul computer. Tale operazione è da evitare in quanto gli oggetti così salvati andranno ad interferire con gli oggetti creati in un lavoro futuro. Si consiglia dunque di rispondere negativamente a questa domanda.

\begin{itemize}
\item
  In RStudio, selezionare \texttt{Preferences} dal menu a tendina e, in \texttt{R\ General} \texttt{Workspace}, deselezionare l'opzione \texttt{Restore\ .RData\ into\ workspace\ at\ start-} \texttt{up} e scegliere l'opzione \texttt{Never} nella finestra di dialogo \texttt{Save\ workspace\ to} \texttt{.RData\ on\ exit}.
\item
  In R, selezionare \texttt{Preferences} dal menu a tendina e, in \texttt{Startup}, selezionare l'opzione \texttt{No} in corrispondenza dell'item \texttt{Save\ workspace\ on\ exit\ from\ R}.
\end{itemize}

\hypertarget{creare-ed-eseguire-uno-script-r-con-un-editore}{%
\subsection{Creare ed eseguire uno script R con un editore}\label{creare-ed-eseguire-uno-script-r-con-un-editore}}

È molto più facile interagire con R manipolando uno script con un editore piuttosto che inserendo direttamente le istruzioni nella console. \texttt{R} fornisce il Text Editor dove è possibile inserire il codice (File \(\to\) New Script). Per salvare il file basta utilizzare l'apposito menù a tendina (estensione \texttt{.R}). Tale file potrà poi essere riaperto ed utilizzato in un momento successivo.

L'editore comunica con \texttt{R} nel modo seguente: dopo avere selezionato la porzione di codice che si vuole eseguire, si digita un'apposita sequenza di tasti (\texttt{Command\ +\ Enter} su Mac OS X e \texttt{ctrl\ +\ r} in Windows). \texttt{ctrl\ +\ r} significa premere il tasto \texttt{ctrl} e, tenendolo premuto, premere il tasto \texttt{r} della tastiera. Così facendo, \texttt{R} eseguirà le istruzioni selezionate e l'output verrà stampato sulla console. Il Text Editor fornito da \texttt{R} è piuttosto primitivo: è fortemente consigliato utilizzare RStudio.

\hypertarget{commentare-il-codice}{%
\subsection{Commentare il codice}\label{commentare-il-codice}}

Un ``commento'' è una parte di codice che l'interprete non tiene in considerazione. Quando l'interprete arriva ad un segnalatore di commento salta fino al segnalatore di fine commento e di lì riprende il normale processo esecutivo.

I commenti sono parole in linguaggio naturale (nel nostro caso l'italiano), che permettono agli utilizzatori di capire il flusso logico del codice e a chi lo ha scritto di ricordare il perché di determinate istruzioni.

In \texttt{R}, le parole dopo il simbolo \texttt{\#} sono considerate commenti e sono ignorate; ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Questo e\textquotesingle{} un commento}
\end{Highlighting}
\end{Shaded}

\hypertarget{cambiare-la-cartella-di-lavoro}{%
\subsection{Cambiare la cartella di lavoro}\label{cambiare-la-cartella-di-lavoro}}

Quando si inizia una sessione di lavoro, \texttt{R} sceglie una cartella quale ``working directory''. Sarà in tale cartella che andrà a cercare gli script definiti dall'utilizzatore e i file dei dati. È possibile determinare quale sia la corrente ``working directory'' digitando sulla console di RStudio l'istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Per cambiare la cartella di lavoro (in maniera tale che corrisponda alla cartella nella quale sono stati salvati i dati e gli script da eseguire) si sceglie la voce \texttt{Set\ Working\ Directory} sul menù a tendina di RStudio e si selezione la voce \texttt{Choose\ Directory…} Nella finestra che compare, si cambia la cartella con quella che si vuole.

\hypertarget{loggetto-base-di-r-il-vettore}{%
\subsection{L'oggetto base di R: il vettore}\label{loggetto-base-di-r-il-vettore}}

\texttt{R} opera su strutture di dati; la più semplice di tali strutture è il vettore numerico, che consiste in un insieme ordinato di numeri; ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{7.0}\NormalTok{, }\FloatTok{10.2}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{2.9}\NormalTok{, }\FloatTok{21.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Nell'istruzione precedente, \texttt{c()} è una funzione. In R gli argomenti sono passati alle funzioni inserendoli all'interno delle parentesi tonde. Si noti che gli argomenti (in questo caso, i numeri \(7.0, 10.2, -2.9, 21.4\)) sono separati a virgole. La funzione \texttt{c()} può prendere un numero arbitrario di argomenti e genera un vettore concatenando i suoi argomenti. L'operatore \texttt{\textless{}-} assegna un nome al vettore che è stato creato. Nel caso presente, digitando \texttt{x} possiamo visualizzare il vettore che abbiamo creato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{\#\textgreater{} [1]  7.0 10.2 {-}2.9 21.4}
\end{Highlighting}
\end{Shaded}

Se invece eseguiamo l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FloatTok{7.0}\NormalTok{, }\FloatTok{10.2}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{2.9}\NormalTok{, }\FloatTok{21.4}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  7.0 10.2 {-}2.9 21.4}
\end{Highlighting}
\end{Shaded}

senza assegnazione, il valore dell'espressione sarà visualizzato nella console, ma il vettore non potrà essere utilizzato in nessun altro modo.

\hypertarget{operazioni-vettorializzate}{%
\subsection{Operazioni vettorializzate}\label{operazioni-vettorializzate}}

Molte operazioni in \texttt{R} sono vettorializzate, il che significa che esse sono eseguite in parallelo in determinati oggetti. Ciò consente di scrivere codice che sia efficiente, conciso e più facile da leggere rispetto al codice che contiene istruzioni non vettorializzate.

\hypertarget{vettori-aritmetici}{%
\subsection{Vettori aritmetici}\label{vettori-aritmetici}}

L'esempio più semplice che illustra come si svolgono le operazioni vettorializzate riguarda le operazioni algebriche applicate ai vettori. I vettori, infatti, possono essere utilizzati in espressioni numeriche nelle quali le operazioni algebriche vengono eseguite ``elemento per elemento''.

Per illustrare questo concetto, definiamo il vettore \texttt{die} che contiene i possibili risultati del lancio di un dado:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{die}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

Supponiamo di volere sommare \(10\) a ciascun elemento del vettore \texttt{die}. Dato che le operazioni sui vettori sono eseguite elemento per elemento, per ottenere questo risultato è sufficiente eseguire l'istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{+} \DecValTok{10}
\CommentTok{\#\textgreater{} [1] 11 12 13 14 15 16}
\end{Highlighting}
\end{Shaded}

Si noti come la costante \(10\) sia stata sommata a ciascun elemento del vettore. In maniera corrispondente, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{{-}} \DecValTok{1}
\CommentTok{\#\textgreater{} [1] 0 1 2 3 4 5}
\end{Highlighting}
\end{Shaded}

sottrarrà un'unità da ciascuno degli elementi del vettore \texttt{die}.

Se l'operazione aritmetica coinvolge due o più vettori, R allinea i vettori ed esegue una sequenza di operazioni elemento per elemento. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{*}\NormalTok{ die}
\CommentTok{\#\textgreater{} [1]  1  4  9 16 25 36}
\end{Highlighting}
\end{Shaded}

fa sì che i due vettori vengano disposti l'uno di fianco all'altro per poi moltiplicare gli elementi corrispondenti: il primo elemento del primo vettore per il primo elemento del secondo vettore e così via. Il vettore risultante avrà la stessa dimensione dei due vettori che sono stati moltiplicati, come indicato qui sotto:

\[
\begin{array}{ccccc}
1 & \times & 1 & \to & 1 \\
2 & \times & 2 & \to & 4 \\
3 & \times & 3 & \to & 9 \\
4 & \times & 4 & \to & 16 \\
5 & \times & 5 & \to & 25 \\
6 & \times & 6 & \to & 36 \\
\hline
\verb+die+ & * & \verb+die+ & = & 
\end{array}
\]

Oltre agli operatori aritmetici elementari \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, e \texttt{\^{}} per l'elevamento a potenza, sono disponibili le più comuni funzioni matematiche: \texttt{log()}, \texttt{exp()}, \texttt{sin()}, \texttt{cos()}, \texttt{tan()}, \texttt{sqrt()}, \texttt{max()}, \texttt{min()} e così via. Altre funzioni di uso comune sono: \texttt{range()} che restituisce un vettore \texttt{c(min(x),\ max(x))}; \texttt{sort()} che restituisce un vettore ordinato; \texttt{length(x)} che restituisce il numero di elementi di \texttt{x}; \texttt{sum(x)} che dà la somma degli elementi di \texttt{x}, mentre \texttt{prod(x)} dà il loro prodotto. Due funzioni statistiche di uso comune sono \texttt{mean(x)}, la media aritmetica, e \texttt{var(x)}, la varianza.

\hypertarget{generazione-di-sequenze-regolari}{%
\subsection{Generazione di sequenze regolari}\label{generazione-di-sequenze-regolari}}

\texttt{R} possiede un ampio numero di funzioni per generare sequenze di numeri. Ad esempio, \texttt{c(1:10)} è il vettore \texttt{c(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10)}. L'espressione \texttt{c(30:1)} può essere utilizzata per generare una sequenza all'indietro.

La funzione \texttt{seq()} genera un vettore che contiene una sequenza regolare di numeri, generata in base a determinate regole. Può avere 5 argomenti: i primi due rappresentano l'inizio (\texttt{from}) e la fine (\texttt{to}) della sequenza, il terzo specifica l'ampiezza del passo (\texttt{by}), il quarto la lunghezza della sequenza (\texttt{length.out}) e infine il quinto (\texttt{along.with}), che se utilizzato deve essere l'unico parametro presente, è il nome di un vettore, ad esempio \texttt{x}, creando in tal modo la sequenza 1, 2, \ldots, \texttt{length(x)}. Esempi di utilizzo della funzione \texttt{seq()} sono i seguenti:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10}
\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{, }\AttributeTok{by =} \FloatTok{2.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] {-}5.0 {-}2.5  0.0  2.5  5.0}
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{7}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{4}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1 3 5 7}
\FunctionTok{seq}\NormalTok{(}\AttributeTok{along.with =}\NormalTok{ die)}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

Altra funzione utilizzata per generare sequenze è \texttt{rep()} che può essere utilizzata per replicare un oggetto in vari modi. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die3 }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(die, }\AttributeTok{times =} \DecValTok{3}\NormalTok{)}
\NormalTok{die3}
\CommentTok{\#\textgreater{}  [1] 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

metterà tre copie di \texttt{die} nell'oggetto \texttt{die3}.

\hypertarget{generazione-di-numeri-casuali}{%
\subsection{Generazione di numeri casuali}\label{generazione-di-numeri-casuali}}

La funzione \texttt{sample()} è una delle tante funzioni che possono essere usate per generare numeri casuali. Per esempio, la seguente istruzione simula dieci lanci di un dado a sei facce:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{roll}
\CommentTok{\#\textgreater{}  [1] 1 3 3 6 3 1 2 2 6 6}
\end{Highlighting}
\end{Shaded}

Il primo argomento di \texttt{sample()} è il vettore da cui la funzione estrarrà degli elementi a caso; il secondo argomento specifica che dovranno essere effettuate 10 estrazioni casuali; il terzo argomento specifica che le estrazioni sono con rimessa (cioè, lo stesso elemento può essere estratto più di una volta).

Scegliere un elemento a caso dal vettore \(\{1, 2, 3, 4, 5, 6\}\) è equivalente a lanciare un dado e osservare la faccia che si presenta. L'istruzione precedente corrisponde dunque alla simulazione di dieci lanci di un dado a sei facce.

\hypertarget{vettori-logici}{%
\subsection{Vettori logici}\label{vettori-logici}}

Quando si manipolano i vettori, talvolta si vogliono trovare gli elementi che soddisfano determinate condizioni logiche. Per esempio, in dieci lanci di un dado, quante volte è uscito \(5\)? Per rispondere a questa domanda si possono usare gli operatori logici \texttt{\textless{}}, \texttt{\textgreater{}} e \texttt{==} per le operazioni di ``minore di,'' ``maggiore di'' e ``uguale a''. Se scriviamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\SpecialCharTok{==} \DecValTok{5}
\CommentTok{\#\textgreater{}  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\CommentTok{\#\textgreater{}  [9] FALSE FALSE}
\end{Highlighting}
\end{Shaded}

creiamo un vettore costituito da elementi \texttt{TRUE/FALSE} i quali identificano gli elementi del vettore che soddisfano la condizione logica specificata.

Possiamo trattare tale vettore come se fosse costituito da elementi di valore \(0\) e \(1\). Sommando gli elementi di tale vettore, infatti, possiamo contare il numero di ``5'':

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(roll }\SpecialCharTok{==} \DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

\hypertarget{dati-mancanti}{%
\subsection{Dati mancanti}\label{dati-mancanti}}

Quando si è in presenza di un dato mancante, R assegna il valore speciale \texttt{NA}, che sta per \emph{Not Available}. In generale, un'operazione su un \texttt{NA} dà come risultato un \texttt{NA}. Nell'uso delle funzioni che operano sui dati sarà dunque necessario specificare che, qualunque operazione venga effettuata, gli \texttt{NA} devono essere esclusi.

\hypertarget{vettori-di-caratteri-e-fattori}{%
\subsection{Vettori di caratteri e fattori}\label{vettori-di-caratteri-e-fattori}}

I vettori di caratteri si creano formando una sequenza di caratteri delimitati da doppie virgolette e possono essere concatenati in un vettore attraverso la funzione \texttt{c()}. Successivamente, si può applicare la funzione \texttt{factor()}, che definisce automaticamente le modalità della variabile categoriale. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{soc\_status }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(}\StringTok{"low"}\NormalTok{, }\StringTok{"high"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{, }\StringTok{"low"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{)}
\NormalTok{)}
\FunctionTok{levels}\NormalTok{(soc\_status)}
\CommentTok{\#\textgreater{} [1] "high"   "low"    "medium"}
\end{Highlighting}
\end{Shaded}

Talvolta l'ordine dei livelli del fattore non importa, mentre altre volte l'ordine è importante, per esempio, quando una variable categoriale viene rappresentata in un grafico. Per specificare l'ordine dei livelli del fattore si usa la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{soc\_status }\OtherTok{\textless{}{-}} 
  \FunctionTok{factor}\NormalTok{(soc\_status, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"low"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{))}
\FunctionTok{levels}\NormalTok{(soc\_status)}
\CommentTok{\#\textgreater{} [1] "low"    "medium" "high"}
\end{Highlighting}
\end{Shaded}

\hypertarget{funzioni}{%
\subsection{Funzioni}\label{funzioni}}

\texttt{R} offre la possibilità di utilizzare un'enorme libreria di funzioni che permettono di svolgere operazioni complicate, quali ad esempio, il campionamento casuale. Esaminiamo ora con più attenzione le proprietà delle funzioni di \texttt{R} utilizzando ancora l'esempio del lancio di un dado. Abbiamo visto in precedenza come il lancio di un dado possa essere simulato da R con la funzione \texttt{sample()}. La funzione \texttt{sample()} prende tre argomenti: il nome di un vettore, un numero chiamato \texttt{size} e un argomento chiamato \texttt{replace}. La funzione \texttt{sample()} ritorna un numero di elementi del vettore pari a \texttt{size}. Ad esempio

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3 4}
\end{Highlighting}
\end{Shaded}

Assegnando \texttt{TRUE} all'argomento \texttt{replace} specifichiamo che vogliamo un campionamento con rimessa.

Se volgiamo eseguire una serie di lanci indipendenti di un dado, eseguiamo ripetutamente la funzione \texttt{sample()} ponendo \texttt{size} uguale a 1:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3}
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2}
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 5}
\end{Highlighting}
\end{Shaded}

Come si fa a sapere quanti e quali argomenti sono richiesti da una funzione? Tale informazione viene fornita dalla funzione \texttt{args()}. Nel nostro caso

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(sample)}
\CommentTok{\#\textgreater{} function (x, size, replace = FALSE, prob = NULL) }
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

ci informa che il primo argomento è un vettore chiamato \texttt{x}, il secondo argomento è chiamato \texttt{size} ed ha il significato descritto sopra, il terzo argomento, \texttt{replace}, specifica se il campionamento è eseguito con o senza reimmissione, e il quarto argomento, \texttt{prob}, assegna delle probabilità agli elementi del vettore. Il significato degli argomenti viene spiegato nel file di help della funzione. Si noti che agli ultimi due argomenti sono stati assegnati dei valori, detti di default. Ciò significa che, se l'utilizzatore non li cambia, verranno usati da . La specificazione \texttt{replace\ =\ FALSE} significa che il campionamento viene eseguito senza reimmissione. Se desideriamo un campionamento con reimmissione, basta specificare \texttt{replace\ =\ TRUE} (nel caso di una singola estrazione è ovviamente irrilevante). Ad esempio, l'istruzione seguente simula i risultati di 10 lanci indipendenti di un dado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{10}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1] 3 6 1 3 3 4 3 6 3 4}
\end{Highlighting}
\end{Shaded}

Infine, \texttt{prob\ =\ NULL} specifica che non viene alterata la probabilità di estrazione degli elementi del vettore. In generale, gli argomenti di una funzione possono essere oggetti come vettori, matrici, altre funzioni, parametri o operatori logici.

\texttt{R} ha un sistema di help interno in formato HTML che si richiama con \texttt{help.start()}. Per avere informazioni su qualche funzione specifica, per esempio la funzione \texttt{sample()}, il comando da utilizzare è \texttt{help(sample)} oppure \texttt{?sample}.

\hypertarget{scrivere-proprie-funzioni}{%
\subsection{Scrivere proprie funzioni}\label{scrivere-proprie-funzioni}}

Abbiamo visto in precedenza come sia possibile simulare i risultati prodotti da dieci lanci di un dado o, in maniera equivalente, dal singolo lancio di dieci dadi. Possiamo replicare questo processo digitando ripetutamente le stesse istruzioni nella console. Otterremo ogni volta risultati diversi perché, ad ogni ripetizione, il generatore di numeri pseudo-casuali di R dipende dal valore ottenuto dal clock interno della macchina. La funzione \texttt{set.seed()} ci permette di replicare esattamente i risultati della generazione di numeri casuali. Per ottenere questo risultato, basta assegnare al seed un numero arbitrario, es. \texttt{set.seed(12345)}. Tuttavia, questa procedura è praticamente difficile da perseguire se il numero di ripetizioni è alto. In tal caso è vantaggioso scrivere una funzione contenente il codice che specifica il numero di ripetizioni. In questo modo, per trovare il risultato cercato basterà chiamare la funzione una sola volta.

Le funzioni utilizzate da \texttt{R} sono costituite da tre elementi: il nome, il blocco del codice e una serie di argomenti. Per creare una funzione è necessario immagazzinare in R questi tre elementi e \texttt{function()} consente di ottenere tale risultato usando la sintassi seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome\_funzione }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(arg1, arg2, ...) \{}
\NormalTok{  espressione1}
\NormalTok{  espressione2}
  \FunctionTok{return}\NormalTok{(risultato)}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

Una chiamata di funzione è poi eseguita nel seguente modo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nome\_funzione}\NormalTok{(arg1, arg2, ...)}
\end{Highlighting}
\end{Shaded}

Per potere essere utilizzata, una funzione deve essere presente nella memoria di lavoro di \texttt{R}. Le funzioni salvate in un file possono essere richiamate utilizzando la funzione \texttt{source()}, ad esempio, \texttt{source("file\_funzioni.R")}.

Consideriamo ora la funzione \texttt{two\_rolls()} che ritorna la somma dei punti prodotti dal lancio di due dadi non truccati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{two\_rolls }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  res }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  sum\_res }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(res)}
  \FunctionTok{return}\NormalTok{(sum\_res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{two\_rolls()} inizia con il creare il vettore \texttt{die} che contiene sei elementi: i numeri da \(1\) a \(6\). Viene poi utilizzata la funzione \texttt{sample()} con gli gli argomenti, \texttt{die}, \texttt{size\ =\ 2} e \texttt{replace\ =\ TRUE}. Tale funzione restituisce il risultato del lancio di due dadi. Il risultato fornito da \texttt{sample(die,\ size\ =\ 2,\ replace\ =\ TRUE)} viene assegnato all'oggetto \texttt{res}. L'oggetto \texttt{res} corrisponde dunque ad un vettore di due elementi. L'istruzione \texttt{sum(res)} somma gli elementi del vettore \texttt{res} e attribuisce il risultato di questa operazione a \texttt{sum\_res}. Infine, la funzione \texttt{return()} ritorna il contenuto dell'oggetto \texttt{sum\_res}. Invocando la funzione \texttt{two\_rolls()} si ottiene dunque la somma del lancio di due dadi. In generale, la funzione \texttt{two\_rolls()} produrrà un risultato diverso ogni volta che viene usata:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{two\_rolls}\NormalTok{()   }
\CommentTok{\#\textgreater{} [1] 9}
\FunctionTok{two\_rolls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 4}
\FunctionTok{two\_rolls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 7}
\end{Highlighting}
\end{Shaded}

La formattazione del codice mediante l'uso di spazi e rientri non è necessaria ma è altamente raccomandata per minimizzare la probabilità di compiere errori.

\hypertarget{pacchetti}{%
\subsection{Pacchetti}\label{pacchetti}}

Le funzioni di \texttt{R} sono organizzate in pacchetti, i più importanti dei quali sono già disponibili quando si accede al programma.

\hypertarget{istallazione-e-upgrade-dei-pacchetti}{%
\subsection{Istallazione e upgrade dei pacchetti}\label{istallazione-e-upgrade-dei-pacchetti}}

Alcuni pacchetti non sono presenti nella release di base di \texttt{R}. Per installare un pacchetto non presente è sufficiente scrivere nella console:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"nome\_pacchetto"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La prima volta che si usa questa funzione durante una sessione di lavoro si dovrà anche selezionare da una lista il sito \emph{mirror} da cui scaricare il pacchetto.

Gli autori dei pacchetti periodicamente rilasciano nuove versioni dei loro pacchetti che contengono miglioramenti di varia natura. Per eseguire l'upgrade dei pacchetti \texttt{ggplot2} e \texttt{dplyr}, ad esempio, si usa la seguente istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{update.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{, }\StringTok{"dplyr"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Per eseguire l'upgrade di tutti i pacchetti l'istruzione è

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{update.packages}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{caricare-un-pacchetto-in-r}{%
\subsection{Caricare un pacchetto in R}\label{caricare-un-pacchetto-in-r}}

L'istallazione dei pacchetti non rende immediatamente disponibili le funzioni in essi contenute. L'istallazione di un pacchetto semplicemente copia il codice sul disco rigido della macchina in uso. Per potere usare le funzioni contenute in un pacchetto installato è necessario caricare il pacchetto in . Ciò si ottiene con il comando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

se si vuole caricare il pacchetto \texttt{ggplot2}. A questo punto diventa possibile usare le funzioni contenute in \texttt{ggplot2}. Queste operazioni si possono anche eseguire usando dal menu a tendina di RStudio.

Per sapere quali sono i pacchetti già presenti nella release di \texttt{R} con cui si sta lavorando, basta scrivere:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{chapter-strutture-dati}{%
\section{Strutture di dati}\label{chapter-strutture-dati}}

Solitamente gli psicologi raccolgono grandi quantità di dati. Tali dati vengono codificati in \texttt{R} all'interno di oggetti aventi proprietà diverse. Intuitivamente, in \texttt{R} un oggetto è qualsiasi cosa a cui è possibile assegnare un valore. I dati possono essere di tipo numerico o alfanumerico. Di conseguenza, \texttt{R}distingue tra oggetti aventi \emph{modi} diversi. Inoltre, i dati possono essere organizzati in righe e colonne in base a diversi tipi di strutture che \texttt{R} chiama \emph{classi}.

\hypertarget{classi-e-modi-degli-oggetti}{%
\subsection{Classi e modi degli oggetti}\label{classi-e-modi-degli-oggetti}}

Gli oggetti \texttt{R} si distinguono a seconda della loro classe (\emph{class}) e del loro modo (\emph{mode}). La classe definisce il tipo di oggetto. In \texttt{R}, vengono utilizzate cinque strutture di dati che corrispondono a cinque classi differenti: \texttt{vector}, \texttt{matrix}, \texttt{array}, \texttt{list} e \texttt{data.frame}. Un'altra classe di oggetti \texttt{R} è \texttt{function} (ad essa appartengono le funzioni).

La classe di appartenenza di un oggetto si stabilisce usando le funzioni \texttt{class()}, oppure \texttt{is.list()}, \texttt{is.function()}, \texttt{is.logical()}, e così via. Queste funzioni restituisco \texttt{TRUE} e \texttt{FALSE} in base all'appartenenza o meno dell'argomento a quella determinata classe.

Gli oggetti \texttt{R} possono anche essere classificati in base al loro `modo'. I modi `atomici' degli oggetti sono: \texttt{numeric}, \texttt{complex}, \texttt{character} e \texttt{logical}. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\FunctionTok{mode}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\NormalTok{cards }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"9 of clubs"}\NormalTok{, }\StringTok{"10 of hearts"}\NormalTok{, }\StringTok{"jack of hearts"}\NormalTok{) }
\FunctionTok{mode}\NormalTok{(cards)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

Nel seguito verranno esaminate le cinque strutture di dati utilizzate da \texttt{R}.

\hypertarget{vettori}{%
\subsection{Vettori}\label{vettori}}

I vettori sono la classe di oggetto più importante in \texttt{R}. Un vettore può essere creato usando la funzione \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{y}
\CommentTok{\#\textgreater{} [1]  2  1  6 {-}3  9}
\end{Highlighting}
\end{Shaded}

Le dimensioni di un vettore presente nella memoria di lavoro possono essere trovare con la funzione \texttt{length()}; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 5}
\end{Highlighting}
\end{Shaded}

ci dice che \texttt{y} è un vettore costituito da cinque elementi. La somma, il minimo e il massimo degli elementi contenuti in un vettore si trovano con le seguenti istruzioni:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 15}
\FunctionTok{min}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] {-}3}
\FunctionTok{max}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 9}
\end{Highlighting}
\end{Shaded}

Mentre ci sono sei `tipi' di vettori `atomici' in \texttt{R}, noi ci focalizzeremo sui tipi seguenti: `numeric' (`integer': \emph{e.g.}, 5; `double': \emph{e.g.}, 5.5), `character' (\emph{e.g.}, `pippo') e `logical' (\emph{e.g.}, \texttt{TRUE}, \texttt{FALSE}). Usiamo la funzione \texttt{typeof()} per determinare il `tipo' di un vettore atomico. Tutti gli elementi di un vettore atomico devono essere dello stesso tipo. La funzione \texttt{str()} rende visibile in maniera compatta la struttura interna di un oggetto.

\hypertarget{matrici}{%
\subsection{Matrici}\label{matrici}}

Una matrice è una collezione di vettori. Il comando per generare una matrice è \texttt{matrix()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{4}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{X}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    5    9   13   17}
\CommentTok{\#\textgreater{} [2,]    2    6   10   14   18}
\CommentTok{\#\textgreater{} [3,]    3    7   11   15   19}
\CommentTok{\#\textgreater{} [4,]    4    8   12   16   20}
\end{Highlighting}
\end{Shaded}

Il primo argomento è il vettore i cui elementi andranno a disporsi all'interno della matrice. È poi necessario specificare le dimensioni della matrice e il modo in cui \texttt{R} dovrà riempire la matrice. Date le dimensioni del vettore, la specificazione del numero di righe (secondo argomento) è sufficiente per determinare le dimensioni della matrice. L'argomento \texttt{byrow\ =\ FALSE} è il default. In tal caso, \texttt{R} riempie la matrice per colonne. Se vogliamo che \texttt{R} riempia la matrice per righe, usiamo \texttt{byrow\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Y }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{4}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{Y}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    2    3    4    5}
\CommentTok{\#\textgreater{} [2,]    6    7    8    9   10}
\CommentTok{\#\textgreater{} [3,]   11   12   13   14   15}
\CommentTok{\#\textgreater{} [4,]   16   17   18   19   20}
\end{Highlighting}
\end{Shaded}

Le dimensioni di una matrice presente nella memoria di lavoro possono essere trovare con la funzione \texttt{dim()}; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(Y)}
\CommentTok{\#\textgreater{} [1] 4 5}
\end{Highlighting}
\end{Shaded}

ci dice che \texttt{Y} è una matrice con quattro righe e cinque colonne.

\hypertarget{array}{%
\subsection{Array}\label{array}}

Un array è una collezione di matrici (si veda la Figura \protect\hyperlink{fig:R_data_structures}{1.1}). Per costruire un array con la funzione \texttt{array()} è necessario specificare un vettore come primo argomento e un vettore di dimensioni, chiamato \texttt{dim}, quale secondo argomento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ar }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(}\DecValTok{11}\SpecialCharTok{:}\DecValTok{14}\NormalTok{, }\DecValTok{21}\SpecialCharTok{:}\DecValTok{24}\NormalTok{, }\DecValTok{31}\SpecialCharTok{:}\DecValTok{34}\NormalTok{), }
  \AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Un sottoinsieme di questi dati può essere selezionato, per esempio, nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ar[, , }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]   31   33}
\CommentTok{\#\textgreater{} [2,]   32   34}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-vettori-matrici-e-array}{%
\subsection{Operazioni aritmetiche su vettori, matrici e array}\label{operazioni-aritmetiche-su-vettori-matrici-e-array}}

\hypertarget{operazioni-aritmetiche-su-vettori}{%
\subsubsection{Operazioni aritmetiche su vettori}\label{operazioni-aritmetiche-su-vettori}}

I vettori e le matrici (o gli array) possono essere utilizzati in espressioni aritmetiche. Il risultato è un vettore o una matrice (o un array) formato dalle operazioni fatte elemento per elemento sui vettori o sulle matrici. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\SpecialCharTok{+} \DecValTok{3}
\CommentTok{\#\textgreater{} [1]  5  4  9  0 12}
\end{Highlighting}
\end{Shaded}

restituisce un vettore di dimensioni uguali alle dimensioni di \texttt{y}, i cui elementi sono dati dalla somma tra ciascuno degli elementi originari di \texttt{y} e la costante ``3''.

Ovviamente, ad un vettore possono essere applicate tutte le altre operazioni algebriche, sempre elemento per elemento. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  6  3 18 {-}9 27}
\end{Highlighting}
\end{Shaded}

restituisce un vettore i cui elementi sono uguali agli elementi di \texttt{y} moltiplicati per 3.

Se sono costituiti dallo stesso numero di elementi, due vettori possono essere sommati, sottratti, moltiplicati e divisi, laddove queste operazioni algebriche vengono eseguite elemento per elemento. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{+}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  3  2  8  4 12}
\NormalTok{x }\SpecialCharTok{{-}}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1] {-}1  0 {-}4 {-}2 {-}6}
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  2  1 12  3 27}
\NormalTok{x }\SpecialCharTok{/}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1] 0.5000 1.0000 0.3333 0.3333 0.3333}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-matrici}{%
\subsubsection{Operazioni aritmetiche su matrici}\label{operazioni-aritmetiche-su-matrici}}

Le operazioni algebriche elemento per elemento si possono estendere al caso delle matrici. Per esempio, se \texttt{X}, \texttt{Y} sono entrambe matrici di dimensioni \(4 \times 5\), allora la seguente operazione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M }\OtherTok{\textless{}{-}} \DecValTok{2} \SpecialCharTok{*}\NormalTok{ (X }\SpecialCharTok{+}\NormalTok{ Y) }\SpecialCharTok{{-}} \DecValTok{3} 
\end{Highlighting}
\end{Shaded}

crea una matrice \texttt{D} anch'essa di dimensioni \(4 \times 5\) i cui elementi sono ottenuti dalle operazioni fatte elemento per elemento sulle matrici e sugli scalari:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1   11   21   31   41}
\CommentTok{\#\textgreater{} [2,]   13   23   33   43   53}
\CommentTok{\#\textgreater{} [3,]   25   35   45   55   65}
\CommentTok{\#\textgreater{} [4,]   37   47   57   67   77}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-array}{%
\subsubsection{Operazioni aritmetiche su array}\label{operazioni-aritmetiche-su-array}}

Le stesse considerazioni si estendono al caso degli array.

\hypertarget{liste}{%
\subsection{Liste}\label{liste}}

Le liste assomigliano ai vettori perché raggruppano i dati in un insieme unidimensionale. Tuttavia, le liste non raggruppano elementi individuali ma bensì oggetti di \texttt{R}, quali vettori e altre liste. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1 }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\FunctionTok{list}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{), }\DecValTok{20}\SpecialCharTok{:}\DecValTok{24}\NormalTok{)}
\NormalTok{list1}
\CommentTok{\#\textgreater{} [[1]]}
\CommentTok{\#\textgreater{} [1] "R"}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]]}
\CommentTok{\#\textgreater{} [[2]][[1]]}
\CommentTok{\#\textgreater{} [1] TRUE}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]][[2]]}
\CommentTok{\#\textgreater{} [1] FALSE}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[3]]}
\CommentTok{\#\textgreater{} [1] 20 21 22 23 24}
\end{Highlighting}
\end{Shaded}

Le doppie parentesi quadre identificano l'elemento della lista a cui vogliamo fare riferimento. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[[}\DecValTok{3}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 20 21 22 23 24}
\NormalTok{list1[[}\DecValTok{3}\NormalTok{]][}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 21}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-frame}{%
\subsection{Data frame}\label{data-frame}}

I data.frame sono strutture tipo matrice, in cui le colonne possono essere vettori di tipi differenti. La funzione usata per generare un data frame è \texttt{data.frame()}, che permette di unire più vettori di uguale lunghezza come colonne del data frame, ognuno dei quali si riferisce ad una diversa variabile. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"six"}\NormalTok{),}
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{), }
  \AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{)}
\NormalTok{df}
\CommentTok{\#\textgreater{}   face  suit value}
\CommentTok{\#\textgreater{} 1  ace clubs     1}
\CommentTok{\#\textgreater{} 2  two clubs     2}
\CommentTok{\#\textgreater{} 3  six clubs     3}
\end{Highlighting}
\end{Shaded}

L'estrazione di dati da un data.frame può essere effettuata in maniera simile a quanto avviene per i vettori. Ad esempio, per estrarre la variabile \texttt{value} dal data.frame \texttt{df} si può indicare l'indice della terza colonna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[, }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Dal momento che le colonne sono delle variabili, è possibile estrarle anche indicando nome della variabile, scrivendo \texttt{nome\_data\_frame\$nome\_variabile}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{value}
\CommentTok{\#\textgreater{} [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Per fare un esempio, creiamo un data.frame che contenga tutte le informazioni di un mazzo di carte da poker \citep{grolemund2014hands}. In tale data.frame, ciascuna riga corrisponde ad una carta -- in un mazzo da poker ci sono 52 carte, perciò il data.frame avrà 52 righe. Il vettore \texttt{face} indica con una stringa di caratteri il valore di ciascuna carta, il vettore \texttt{suit} indica il seme e il vettore \texttt{value} indica con un numero intero il valore di ciascuna carta. Quindi, il data.frame avrà 3 colonne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{,}
  \StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }
  \StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }
  \StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }
  \StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }
  \StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }
  \StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }
  \StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{), }
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }
  \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }
  \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }
  \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }
  \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }
  \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }
  \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }
  \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }
  \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }
  \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }
  \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{), }
  \AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Avendo salvato tutte queste informazioni nell'oggetto \texttt{deck}, possiamo stamparle sullo schermo semplicemente digitando il nome dell'oggetto che le contiene:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 1   king   spades    13}
\CommentTok{\#\textgreater{} 2  queen   spades    12}
\CommentTok{\#\textgreater{} 3   jack   spades    11}
\CommentTok{\#\textgreater{} 4    ten   spades    10}
\CommentTok{\#\textgreater{} 5   nine   spades     9}
\CommentTok{\#\textgreater{} 6  eight   spades     8}
\CommentTok{\#\textgreater{} 7  seven   spades     7}
\CommentTok{\#\textgreater{} 8    six   spades     6}
\CommentTok{\#\textgreater{} 9   five   spades     5}
\CommentTok{\#\textgreater{} 10  four   spades     4}
\CommentTok{\#\textgreater{} 11 three   spades     3}
\CommentTok{\#\textgreater{} 12   two   spades     2}
\CommentTok{\#\textgreater{} 13   ace   spades     1}
\CommentTok{\#\textgreater{} 14  king    clubs    13}
\CommentTok{\#\textgreater{} 15 queen    clubs    12}
\CommentTok{\#\textgreater{} 16  jack    clubs    11}
\CommentTok{\#\textgreater{} 17   ten    clubs    10}
\CommentTok{\#\textgreater{} 18  nine    clubs     9}
\CommentTok{\#\textgreater{} 19 eight    clubs     8}
\CommentTok{\#\textgreater{} 20 seven    clubs     7}
\CommentTok{\#\textgreater{} 21   six    clubs     6}
\CommentTok{\#\textgreater{} 22  five    clubs     5}
\CommentTok{\#\textgreater{} 23  four    clubs     4}
\CommentTok{\#\textgreater{} 24 three    clubs     3}
\CommentTok{\#\textgreater{} 25   two    clubs     2}
\CommentTok{\#\textgreater{} 26   ace    clubs     1}
\CommentTok{\#\textgreater{} 27  king diamonds    13}
\CommentTok{\#\textgreater{} 28 queen diamonds    12}
\CommentTok{\#\textgreater{} 29  jack diamonds    11}
\CommentTok{\#\textgreater{} 30   ten diamonds    10}
\CommentTok{\#\textgreater{} 31  nine diamonds     9}
\CommentTok{\#\textgreater{} 32 eight diamonds     8}
\CommentTok{\#\textgreater{} 33 seven diamonds     7}
\CommentTok{\#\textgreater{} 34   six diamonds     6}
\CommentTok{\#\textgreater{} 35  five diamonds     5}
\CommentTok{\#\textgreater{} 36  four diamonds     4}
\CommentTok{\#\textgreater{} 37 three diamonds     3}
\CommentTok{\#\textgreater{} 38   two diamonds     2}
\CommentTok{\#\textgreater{} 39   ace diamonds     1}
\CommentTok{\#\textgreater{} 40  king   hearts    13}
\CommentTok{\#\textgreater{} 41 queen   hearts    12}
\CommentTok{\#\textgreater{} 42  jack   hearts    11}
\CommentTok{\#\textgreater{} 43   ten   hearts    10}
\CommentTok{\#\textgreater{} 44  nine   hearts     9}
\CommentTok{\#\textgreater{} 45 eight   hearts     8}
\CommentTok{\#\textgreater{} 46 seven   hearts     7}
\CommentTok{\#\textgreater{} 47   six   hearts     6}
\CommentTok{\#\textgreater{} 48  five   hearts     5}
\CommentTok{\#\textgreater{} 49  four   hearts     4}
\CommentTok{\#\textgreater{} 50 three   hearts     3}
\CommentTok{\#\textgreater{} 51   two   hearts     2}
\CommentTok{\#\textgreater{} 52   ace   hearts     1}
\end{Highlighting}
\end{Shaded}

Si noti che, a schermo, \texttt{R} stampa un numero progressivo che corrisponde al numero della riga.

\hypertarget{selezione-di-elementi}{%
\subsubsection{Selezione di elementi}\label{selezione-di-elementi}}

Una volta creato un data.frame, ad esempio quello che contiene un mazzo virtuale di carte (si veda l'esempio~\protect\hyperlink{exmp:deck_of_cards}{\[exmp:deck_of_cards\]}), è necessario sapere come manipolarlo. La funzione \texttt{head()} mostra le prime sei righe del data.frame:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck)}
\CommentTok{\#\textgreater{}    face   suit value}
\CommentTok{\#\textgreater{} 1  king spades    13}
\CommentTok{\#\textgreater{} 2 queen spades    12}
\CommentTok{\#\textgreater{} 3  jack spades    11}
\CommentTok{\#\textgreater{} 4   ten spades    10}
\CommentTok{\#\textgreater{} 5  nine spades     9}
\CommentTok{\#\textgreater{} 6 eight spades     8}
\end{Highlighting}
\end{Shaded}

Poniamoci ora il problema di mescolare il mazzo di carte e di estrarre alcune carte dal mazzo. Queste operazioni possono essere eseguite usando il sistema notazionale di \texttt{R}.

Il sistema di notazione di \texttt{R} consente di estrarre singoli elementi dagli oggetti definiti da \texttt{R}. Per estrarre un valore da un data.frame, per esempio, dobbiamo scrivere il nome del data.frame seguito da una coppia di parentesi quadre:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[, ]}
\end{Highlighting}
\end{Shaded}

All'interno delle parentesi quadre ci sono due indici separati da una virgola. \texttt{R} usa il primo indice per selezionare un sottoinsieme di righe del data.frame e il secondo indice per selezionare un sottoinsieme di colonne. L'indice è il numero d'ordine che etichetta progressivamente ognuno dei valori del vettore. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "spades"}
\end{Highlighting}
\end{Shaded}

restituisce l'elemento che si trova nella nella nona riga della seconda colonna di \texttt{deck}.

In \texttt{R} ci sono sei modi diversi per specificare gli indici di un oggetto: interi positivi, interi negativi, zero, spazi vuoti, valori logici e nomi. Esaminiamoli qui di seguito.

\hypertarget{interi-positivi}{%
\subsubsection{Interi positivi}\label{interi-positivi}}

Gli indici \(i, j\) possono essere degli interi positivi che identificano l'elemento nella \(i\)-esima riga e nella \(j\)-esima colonna del data.frame. Per l'esempio relativo al mazzo di carte, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "king"}
\end{Highlighting}
\end{Shaded}

ritorna il valore nella prima riga e nella prima colonna. Per estrarre più di un valore, usiamo un vettore di interi positivi. Per esempio, la prima riga di \texttt{deck} si trova con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\end{Highlighting}
\end{Shaded}

Tale sistema notazionale non si applica solo ai data.frame ma può essere usato anche per gli altri oggetti di \texttt{R}.

L'indice usato da \texttt{R} inizia da 1. In altri linguaggi di programmazione, per esempio \texttt{C}, inizia da 0.

\hypertarget{interi-negativi}{%
\subsubsection{Interi negativi}\label{interi-negativi}}

Gli interi negativi fanno l'esatto contrario degli interi positivi: R ritornerà tutti gli elementi tranne quelli specificati dagli interi negativi. Per esempio, la prima riga del data.frame può essere specificata nel modo seguente

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{2}\SpecialCharTok{:}\DecValTok{52}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\end{Highlighting}
\end{Shaded}

ovvero, escludendo tutte le righe seguenti.

\hypertarget{zero}{%
\subsubsection{Zero}\label{zero}}

Quando lo zero viene usato come indice, \texttt{R} non ritorna nulla dalla dimensione a cui lo zero si riferisce. L'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\CommentTok{\#\textgreater{} data frame con 0 colonne e 0 righe}
\end{Highlighting}
\end{Shaded}

ritorna un data.frame vuoto. Non molto utile.

\hypertarget{spazio}{%
\subsubsection{\texorpdfstring{Spazio \texttt{’\ ’}}{Spazio ' '}}\label{spazio}}

Uno spazio viene usato quale indice per comunicare a \texttt{R} di estrarre tutti i valori in quella dimensione. Questo è utile per estrarre intere colonne o intere righe da un data.frame. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{3}\NormalTok{, ]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 3 jack spades    11}
\end{Highlighting}
\end{Shaded}

ritorna la terza riga del data.frame \texttt{deck}.

\hypertarget{valori-booleani}{%
\subsubsection{Valori booleani}\label{valori-booleani}}

Se viene fornito un vettore di stringhe \texttt{TRUE}, \texttt{FALSE}, \texttt{R} selezionerà gli elementi riga o colonna corrispondenti ai valori booleani \texttt{TRUE} usati quali indici. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit}
\CommentTok{\#\textgreater{} 3 jack spades}
\end{Highlighting}
\end{Shaded}

ritorna i valori delle prime due colonne della terza riga di \texttt{deck}.

\hypertarget{nomi}{%
\subsubsection{Nomi}\label{nomi}}

È possibile selezionare gli elementi del data.frame usando i loro nomi. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"face"}\NormalTok{, }\StringTok{"suit"}\NormalTok{, }\StringTok{"value"}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\NormalTok{deck[, }\StringTok{"value"}\NormalTok{]}
\CommentTok{\#\textgreater{}  [1] 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10}
\CommentTok{\#\textgreater{} [18]  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6}
\CommentTok{\#\textgreater{} [35]  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2}
\CommentTok{\#\textgreater{} [52]  1}
\end{Highlighting}
\end{Shaded}

\hypertarget{giochi-di-carte}{%
\subsection{Giochi di carte}\label{giochi-di-carte}}

Avendo presentato le nozioni base del sistema di notazione di \texttt{R}, utilizziamo tali conoscenze per manipolare il data.frame. L'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

ritorna tutte le righe e tutte e le colonne del data.frame \texttt{deck}. Le righe sono identificate dal primo indice, che va da 1 a 52. Permutare in modo casuale l'indice delle righe equivale a mescolare il mazzo di carte. Per fare questo, utilizziamo la funzione \texttt{sample()} ponendo \texttt{replace=FALSE} e \texttt{size} uguale alla dimensione del vettore che contiene gli indici da 1 a 52:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{random}
\CommentTok{\#\textgreater{}  [1] 41 35 51 22  3 10  2 15 11 16 46 21  7 19 43 17 27}
\CommentTok{\#\textgreater{} [18] 50 39 44 14 18 40 47 31 30 52 37 20 33  6  9  5 49}
\CommentTok{\#\textgreater{} [35] 13  4  8 28 32 45 42 26 36  1 48 23 24 29 34 25 38}
\CommentTok{\#\textgreater{} [52] 12}
\end{Highlighting}
\end{Shaded}

Utilizzando il vettore \texttt{random} di indici permutati otteniamo il risultato cercato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled }\OtherTok{\textless{}{-}}\NormalTok{ deck[random, ]}
\FunctionTok{head}\NormalTok{(deck\_shuffled)}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 41 queen   hearts    12}
\CommentTok{\#\textgreater{} 35  five diamonds     5}
\CommentTok{\#\textgreater{} 51   two   hearts     2}
\CommentTok{\#\textgreater{} 22  five    clubs     5}
\CommentTok{\#\textgreater{} 3   jack   spades    11}
\CommentTok{\#\textgreater{} 10  four   spades     4}
\end{Highlighting}
\end{Shaded}

Possiamo ora scrivere una funzione che include le precedenti istruzioni:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shuffle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{}
\NormalTok{  random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{FALSE}\NormalTok{) }
  \FunctionTok{return}\NormalTok{(cards[random, ])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Invocando la funzione \texttt{shuffle()} possiamo generare un data.frame che rappresenta un mazzo di carte mescolato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled }\OtherTok{\textless{}{-}} \FunctionTok{shuffle}\NormalTok{(deck)}
\end{Highlighting}
\end{Shaded}

Se immaginiamo di distribuire le carte di questo mazzo a due giocatori di poker, per il primo giocatore avremo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{), ]}
\CommentTok{\#\textgreater{}    face     suit value}
\CommentTok{\#\textgreater{} 26  ace    clubs     1}
\CommentTok{\#\textgreater{} 44 nine   hearts     9}
\CommentTok{\#\textgreater{} 29 jack diamonds    11}
\CommentTok{\#\textgreater{} 42 jack   hearts    11}
\CommentTok{\#\textgreater{} 22 five    clubs     5}
\end{Highlighting}
\end{Shaded}

e per il secondo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{10}\NormalTok{), ]}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 24 three    clubs     3}
\CommentTok{\#\textgreater{} 47   six   hearts     6}
\CommentTok{\#\textgreater{} 34   six diamonds     6}
\CommentTok{\#\textgreater{} 51   two   hearts     2}
\CommentTok{\#\textgreater{} 17   ten    clubs    10}
\end{Highlighting}
\end{Shaded}

\hypertarget{variabili-locali}{%
\subsection{Variabili locali}\label{variabili-locali}}

Si noti che, nell'esempio precedente, abbiamo passato l'argomento \texttt{deck} alla funzione \texttt{shuffle()}, perché questo è il nome del data.frame che volevamo manipolare. Nella definizione della funzione \texttt{shuffle()}, però, l'argomento della funzione era chiamato \texttt{cards}. Il nome degli argomenti è diverso nei due casi. Allora perché l'istruzione \texttt{shuffle(deck)} non dà un messaggio d'errore?

La risposta a questa domanda è che nelle funzioni le variabili nascono quando la funzione entra in esecuzione e muoiono al termine dell'esecuzione della funzione. Per questa ragione, sono dette `locali'. La variabile \texttt{cards}, in questo esempio, esiste soltanto all'interno della funzione. Dunque non deve (necessariamente) avere lo stesso nome di un altro oggetto che esiste al di fuori della funzione, nello spazio di lavoro di R (anzi, è meglio se il nome degli oggetti usati all'interno delle funzioni è diverso da quello degli oggetti che esistono fuori dalle funzioni). R sa che l'oggetto \texttt{deck} passato a \texttt{shuffle()} corrisponde a \texttt{cards} all'interno della funzione perché assegna il nome \texttt{cards} a qualunque oggetto venga passato alla funzione \texttt{shuffle()} come primo (e, in questo caso, unico) argomento.

\hypertarget{chapter-strut-contr}{%
\section{Strutture di controllo}\label{chapter-strut-contr}}

In \texttt{R} il flusso della computazione segue l'ordine di lettura delle espressioni. I controlli di flusso sono quei costrutti sintattici che possono modificare quest'ordine di computazione. Ad esempio, un ciclo \texttt{for} ripete le istruzioni annidate al suo interno per un certo numero di volte, e quindi procede sequenzialmente da lì in avanti, mentre un condizionale \texttt{if} valuta una condizione rispetto alla quale il flusso di informazioni si biforca (se è vero / se è falso). Ci limitiamo qui ad introdurre il ciclo \texttt{for}.

\hypertarget{il-ciclo-for}{%
\subsection{\texorpdfstring{Il ciclo \texttt{for}}{Il ciclo for}}\label{il-ciclo-for}}

Il ciclo \texttt{for} è una struttura di controllo iterativa che determina l'esecuzione di una porzione di codice ripetuta per un certo numero noto di volte. Il linguaggio \texttt{R} usa la seguente sintassi per il ciclo \texttt{for}:

\texttt{for} (\texttt{indice} in \texttt{valori\_indice}) \{ \emph{operazioni} \}

il che significa ``esegui le operazioni \emph{operazioni} per i diversi valori di \texttt{indice} compresi nel vettore \texttt{valori\_indice}''. Per esempio, il seguente ciclo \texttt{for} non fa altro che stampare il valore della variabile contatore in ciascuna esecuzione del ciclo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] 1}
\CommentTok{\#\textgreater{} [1] 2}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Un esempio (leggermente) più complicato è il seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_list }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\AttributeTok{by =} \DecValTok{2}\NormalTok{)}
\NormalTok{x\_list}
\CommentTok{\#\textgreater{} [1] 1 3 5 7 9}
\NormalTok{sum\_x }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ x\_list) \{}
\NormalTok{  sum\_x }\OtherTok{\textless{}{-}}\NormalTok{ sum\_x }\SpecialCharTok{+}\NormalTok{ x}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"L\textquotesingle{}indice corrente e\textquotesingle{}"}\NormalTok{, x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"La frequenza cumulata e\textquotesingle{}"}\NormalTok{, sum\_x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }
\NormalTok{\}}
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 1 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 1 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 3 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 4 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 5 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 9 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 7 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 16 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 9 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 25}
\end{Highlighting}
\end{Shaded}

Per esempio, quanti numeri pari sono contenuti in un vettore? La risposta a questa domanda viene fornita dalla funzione \texttt{countEvenNumbers()} che possiamo definire come indicato qui sotto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countEvenNumbers }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  count }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(x)) \{}
    \ControlFlowTok{if}\NormalTok{ (x[i] }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)  }
\NormalTok{      count }\OtherTok{=}\NormalTok{ count }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{  \}}
\NormalTok{  count}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Nella funzione \texttt{countEvenNumbers()} abbiamo inizializzato la variabile \texttt{count} a zero. Prima dell'esecuzione del ciclo \texttt{for}, dunque, \texttt{count} vale zero. Il ciclo \texttt{for} viene eseguito tante volte quanti sono gli elementi che costituiscono il vettore \texttt{x}. L'indice \texttt{i} dunque assume valori compresi tra 1 e il valore che corrisponde al numero di elementi di \texttt{x}. L'operazione modulo, indicato con \texttt{\%\%} dà come risultato il resto della divisione euclidea del primo numero per il secondo. Per esempio, \texttt{9\ \%\%\ 2} dà come risultato \(1\) perché questo è il resto della divisione \(9/2\). L'operazione modulo dà come risultato \(0\) per tutti i numeri pari. In ciascuna esecuzione del ciclo \texttt{for} l'operazione modulo viene eseguita, successivamente, su uno degli elementi di \texttt{x}. Se l'operazione modulo dà \(0\) come risultato, ovvero se il valore considerato è un numero pari, allora la variabile \texttt{count} viene incrementata di un'unità. L'istruzione \texttt{return()} ritorna il numero di valori pari contenuti nel vettore di input alla funzione. Si noti che è necessario usare \texttt{return()}: la funzione ritornerà qualunque cosa sia stampato nell'ultima riga della funzione stessa.

Facciamo un esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\FunctionTok{countEvenNumbers}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

\hypertarget{chapter-input-output}{%
\section{Input/Output}\label{chapter-input-output}}

I dati raccolti dallo psicologo sono contenuti in file aventi formati diversi: solo testo, CSV, Excel, eccetera. \texttt{R} prevede diverse funzioni di importazione dei dati. Esamineremo qui la funzione \texttt{read.table()} per l'importazione di dati in formato solo testo, ma funzioni analoghe possono essere usate per molti altri formati possibili.

\hypertarget{la-funzione-read.table}{%
\subsection{\texorpdfstring{La funzione \texttt{read.table()}}{La funzione read.table()}}\label{la-funzione-read.table}}

Ci sono tanti modi per importare un file dal nostro computer. \texttt{R} permette di utilizzare delle funzioni che sono già nella libreria di base, oppure possiamo utilizzare delle funzioni specifiche, a seconda del tipo di file da importare, che sono contenute in pacchetti aggiuntivi. Per leggere i dati da file in \texttt{R} è conveniente preliminarmente generare un file di dati in formato ASCII, disponendoli come si farebbe in una matrice di dati, e mettere questo file nella cartella di lavoro corrente. Fatto questo, si può utilizzare la funzione \texttt{read.table()} presente nella libreria di base per leggere l'intero dataset. Se la prima riga del file contiene l'intestazione delle variabili, allora \texttt{read.table("my\_file.txt",\ header\ =\ TRUE)} interpreterà la prima riga del file come una riga dove sono contenuti i nomi delle variabili, assegnando ciascun nome alle variabili del data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydata }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"my\_file.txt"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In alternativa, si può impiegare la funzione \texttt{read.csv()}, che è adatta a leggere dati salvati in \texttt{.csv}. Utilizzando altre funzioni, si possono leggere in \texttt{R} i dati contenuti in file aventi formati diversi da quelli considerati qui, quali Excel, SPSS, ecc.

\hypertarget{file-di-dati-forniti-da-r}{%
\subsection{File di dati forniti da R}\label{file-di-dati-forniti-da-r}}

In \texttt{R} esistono comunque oltre 50 insiemi di dati contenuti nel package \texttt{base} e altri sono disponibili in altri packages. Per vedere l'elenco degli insiemi di dati disponibili nel package \texttt{base} basta usare l'istruzione \texttt{data()}; per caricare un particolare insieme di dati, ad esempio \texttt{cars}, basta utilizzare l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(cars)}
\end{Highlighting}
\end{Shaded}

Nella maggior parte dei casi questo corrisponde a caricare un oggetto, solitamente un data.frame dello stesso nome: per l'esempio considerato si avrebbe un data frame di nome \texttt{cars}.

\hypertarget{esportazione-di-un-file}{%
\subsection{Esportazione di un file}\label{esportazione-di-un-file}}

Per esportare un data.frame in formato \texttt{.csv} possiamo scrivere il seguente codice

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(df\_esempio, }\AttributeTok{file =} \StringTok{"esempio.csv"}\NormalTok{, }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

dove \texttt{df\_esempio} è il data.frame da salvare e \texttt{esempio.csv} è il file che verrà salvato all'interno della nostra cartellla di lavoro.

\hypertarget{pacchetto-rio}{%
\subsection{\texorpdfstring{Pacchetto \texttt{rio}}{Pacchetto rio}}\label{pacchetto-rio}}

Un'alternativa più semplice è fornita dalle funzioni fornite dal pacchetto \texttt{rio}. Per importare i dati da un file in qualsiasi formato si usa

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_data\_frame }\OtherTok{\textless{}{-}}\NormalTok{ rio}\SpecialCharTok{::}\FunctionTok{import}\NormalTok{(}\StringTok{"my\_file.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Per esportare i dati in un file avente qualsiasi formato si usa invece

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rio}\SpecialCharTok{::}\FunctionTok{export}\NormalTok{(my\_data\_frame, }\StringTok{"my\_file.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dove-sono-i-miei-file}{%
\subsection{Dove sono i miei file?}\label{dove-sono-i-miei-file}}

Quello che abbiamo detto finora, a proposito dell'importazione ed esportazione dei file, si riferisce a file che si trovano nella cartella di lavoro (\emph{working directory}). Ma non sempre ci troviamo in questa situazione, il che è una buona cosa, perché se dobbiamo gestire un progetto anche leggermente complesso è sempre una buona idea salvare i file che usiamo in cartelle diverse. Per esempio, possiamo usare una cartella chiamata \texttt{psicometria} dove salviamo tutto il materiale di questo insegnamento. Nella cartella \texttt{psicometria} ci potrà essere una cartella chiamata \texttt{scripts} dove salveremo gli script con il codice R utilizzato per i vari esercizi, e una cartella chiamata \texttt{data} dove possiamo salvare i dati. Questa organizzazione minimale ci pone, però, difronte ad un problema: i dati che vogliamo caricare in R non si trovano nella cartella dove sono contenuti gli script. Quando importiamo un file di dati dobbiamo dunque specificare il percorso che identifica la posizione del file sul nostro computer.

Questo problema può essere risolto in due modi: speficicando l'indirizzo assoluto del file, o l'indirizzo relativo. Specificare l'indirizzo assoluto di un file comporta una serie di svantaggi. Il più grande è che non sarà possibile utilizzare quell'istruzione su una macchina diversa. Dunque, è molto più conveniente specificare l'indirizzo dei file in modo relativo. Ma relativo rispetto a cosa? Rispetto alla \emph{working directory} che definirà l'origine del nostro percorso.

È ovvio che la \emph{working directory} cambia da progetto a progetto. Infatti, per ciascun progetto dobbiamo specificare una diversa \emph{working directory}. Per esempio, potremmo avere un progetto relativo all'insegnamento di Psicometria e un progetto relativo alla prova finale.

Per organizzaere il lavoro in questo modo, si procede come segue. Supponiamo di creare una cartella chiamata \texttt{psicometria} che contiene, al suo interno, le cartelle \texttt{scripts} e \texttt{data}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{psicometria}\SpecialCharTok{/}
\NormalTok{  ├── data}
\NormalTok{  ├── scripts}
\end{Highlighting}
\end{Shaded}

Supponiamo che queste cartelle contengano i file che ho specificato sopra. Chiudiamo RStudio, se è aperto, e lo riapriamo di nuovo. Dal menu selezioniamo \texttt{File\ -\textgreater{}\ New\ Project...} In questo modo si aprirà un menu che ci chiederà, tra le altre cose, se vogliamo creare un nuovo progetto (\texttt{New\ project}). Selezioniamo quell'opzione e navighiamo fino alla cartella \texttt{psicometria} e selezioniamo \texttt{open}. Questo creerà un file chiamato \texttt{psicometria.Rproj} nella cartella \texttt{psicometria}.

Chiudiamo ora RStudio. Se vogliamo accedere al progetto ``psicometria'', che abbiamo appena creato, dobbiamo semplicemente cliccare sul file \texttt{psicometria.Rproj}. Questo aprirà RStudio e farà in modo che la \emph{working directory} coincida con la cartalla \texttt{psicometria}. Ogni volta che vogliamo lavorare sui dati del progetto ``psicometria'' chiudiamo dunque RStudio (se è già aperto) e lo riapriamo cliccando sul file \texttt{psicometria.Rproj}.

A questo punto possiamo definire l'indirizzo dei file in modo relativo -- ovvero, relativo alla cartella \texttt{psicometria}. Per fare questo usiamo le funzionalità del pacchetto \texttt{here}. Supponiamo di volere caricare un file di dati che si chiama \texttt{dati\_depressione.txt} e si trova nella cartella \texttt{psicometria/data}. Per importare i dati (dopo avere caricato i pacchetti \texttt{rio} e \texttt{here}) useremo l'istruzione seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rio}\SpecialCharTok{::}\FunctionTok{import}\NormalTok{(}\FunctionTok{here}\NormalTok{(}\StringTok{"data"}\NormalTok{, }\StringTok{"dati\_depressione.txt"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

In altre parole, così facendo specifichiamo il percorso relativo del file \texttt{dati\_depressione.txt} (in quanto l'origine corrisponde alla cartella \texttt{psicometria}). L'istruzione precedente significa che, partendo dalla cartella che coincide con la \emph{working directory} (ovvero, \texttt{psicometria}) ci spostiamo nella cartella \texttt{data} e lì dentro troviamo il file chiamato \texttt{dati\_depressione.txt}.

\hypertarget{manipolazione-dei-dati}{%
\section{Manipolazione dei dati}\label{manipolazione-dei-dati}}

\hypertarget{motivazione}{%
\subsection{Motivazione}\label{motivazione}}

Si chiamano ``dati grezzi'' quelli che provengono dal mondo circostanze, i dati raccolti per mezzo degli strumenti usati negli esperimenti, per mezzo di interviste, di questionari, ecc. Questi dati (chiamati \emph{dataset}) raramente vengono forniti con una struttura logica precisa. Per potere elaborarli mediante dei software dobbiamo prima trasformarli in maniera tale che abbiano una struttura logica organizzata. La struttura che solitamente si utilizza è quella tabellare (matrice dei dati), ovvero si dispongono i dati in una tabella nella quale a ciascuna riga corrisponde ad un'osservazione e ciascuna colonna corrisponde ad una variabile rilevata. In \texttt{R} una tale struttura è chiamata \emph{data frame}.

Utilizzando i pacchetti del \texttt{tidyverse} (\texttt{tidyverse} è un insieme, o \emph{bundle}, di pacchetti \texttt{R}), le operazioni di trasformazione dei dati risultano molto semplificate. Nel \texttt{tidyverse} i data frame vengono leggermente modificati e si chiamano \texttt{tibble}. Per la manipolazione dei dati vengono usati i seguenti pacchetti del \texttt{tidyverse}:

\begin{itemize}
\tightlist
\item
  \texttt{dplyr}
\item
  \texttt{tidyr} (tibbles, dataframe e tabelle)
\item
  \texttt{stringr} (stringhe)
\end{itemize}

Il pacchetto \texttt{dplyr} (al momento uno dei pacchetti più famosi e utilizzati per la gestione dei dati) offre una serie di funzionalità che consentono di eseguire le operazioni più comuni di manipolazione dei dati in maniera più semplice rispetto a quanto succeda quando usiamo le funzioni base di \texttt{R}.

\hypertarget{trattamento-dei-dati-con-dplyr}{%
\subsection{\texorpdfstring{Trattamento dei dati con \texttt{dplyr}}{Trattamento dei dati con dplyr}}\label{trattamento-dei-dati-con-dplyr}}

Il pacchetto \texttt{dplyr} include sei funzioni base: \texttt{filter()}, \texttt{select()}, \texttt{mutate()}, \texttt{arrange()}, \texttt{group\_by()} e \texttt{summarise()}. Queste sei funzioni costituiscono i \emph{verbi} del linguaggio di manipolazione dei dati. A questi sei verbi si aggiunge il pipe \texttt{\%\textgreater{}\%} che serve a concatenare più operazioni. In particolare, considerando una matrice osservazioni per variabili, \texttt{select()} e \texttt{mutate()} si occupano di organizzare le variabili, \texttt{filter()} e \texttt{arrange()} i casi, e \texttt{group\_by()} e \texttt{summarise()} i gruppi.

Per introdurre le funzionalità di \texttt{dplyr}, utilizzeremo i dati \texttt{msleep} forniti dal pacchetto \texttt{ggplot2}. Tali dati descrivono le ore di sonno medie di 83 specie di mammiferi \citep{savage2007scaling}. Carichiamo il \emph{boundle} \texttt{tidyverse} (che contiene \texttt{ggplot2}) e leggiamo nella memoria di lavoro l'oggetto \texttt{msleep}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\FunctionTok{data}\NormalTok{(msleep)}
\FunctionTok{dim}\NormalTok{(msleep)}
\CommentTok{\#\textgreater{} [1] 83 11}
\end{Highlighting}
\end{Shaded}

\hypertarget{operatore-pipe}{%
\subsubsection{Operatore pipe}\label{operatore-pipe}}

Prima di presentare le funzionalità di \texttt{dplyr}, introduciamo l'operatore pipe \texttt{\%\textgreater{}\%} del pacchetto \texttt{magrittr} -- ma ora presente anche in base \texttt{R} nella versione \texttt{\textbar{}\textgreater{}}. L'operatore pipe, \texttt{\%\textgreater{}\%} o \texttt{\textbar{}\textgreater{}}, serve a concatenare varie funzioni insieme, in modo da inserire un'operazione dietro l'altra. Una spiegazione intuitiva dell'operatore pipe è stata fornita in un tweet di \texttt{@andrewheiss}. Consideriamo la seguente istruzione in pseudo-codice \texttt{R}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{leave\_house}\NormalTok{(}
  \FunctionTok{get\_dressed}\NormalTok{(}
    \FunctionTok{get\_out\_of\_bed}\NormalTok{(}
      \FunctionTok{wake\_up}\NormalTok{(me, }\AttributeTok{time =} \StringTok{"8:00"}\NormalTok{), }
      \AttributeTok{side =} \StringTok{"correct"}\NormalTok{), }
    \AttributeTok{pants =} \ConstantTok{TRUE}\NormalTok{, }
    \AttributeTok{shirt =} \ConstantTok{TRUE}\NormalTok{), }
  \AttributeTok{car =} \ConstantTok{TRUE}\NormalTok{, }
  \AttributeTok{bike =} \ConstantTok{FALSE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il listato precedente descrive una serie di (pseudo) funzioni concatenate, le quali costituiscono gli argomenti di altre funzioni. Scritto così, il codice è molto difficile da capire. Possiamo però ottenere lo stesso risultato utilizzando l'operatore pipe che facilita enormememnte la leggibilità del codice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{me }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{wake\_up}\NormalTok{(}\AttributeTok{time =} \StringTok{"8:00"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{get\_out\_of\_bed}\NormalTok{(}\AttributeTok{side =} \StringTok{"correct"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{get\_dressed}\NormalTok{(}\AttributeTok{pants =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{shirt =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{leave\_house}\NormalTok{(}\AttributeTok{car =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{bike =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In questa seconda versione del (pseudo) codice \texttt{R} si capisce molto meglio ciò che vogliamo fare. Il \texttt{tibble} \texttt{me} viene passato alla funzione \texttt{wake\_up()}. La funzione \texttt{wake\_up()} ha come argomento l'ora del giorno: \texttt{time\ =\ "8:00"}. Una volta ``svegliati'' (wake up) dobbiamo scendere dal letto. Quindi l'output di \texttt{wake\_up()} viene passato alla funzione \texttt{get\_out\_of\_bed()} la quale ha come argomento \texttt{side\ =\ "correct"} perché vogliamo scendere dal letto dalla parte giusta. E così via.

Questo pseudo-codice chiarisce il significato dell'operatore pipe. L'operatore \texttt{\%\textgreater{}\%} è ``syntactic sugar'' per una serie di chiamate di funzioni concatenate, ovvero, detto in altre parole, consente di definire la relazione tra una serie di funzioni nelle quali il risultato (output) di una funzione viene utilizzato come l'input di una funzione successiva.

\hypertarget{estrarre-una-singola-colonna-con-pull}{%
\subsubsection{\texorpdfstring{Estrarre una singola colonna con \texttt{pull()}}{Estrarre una singola colonna con pull()}}\label{estrarre-una-singola-colonna-con-pull}}

Ritorniamo ora all'esempio precedente. Iniziamo a trasformare il data frame \texttt{msleep} in un \texttt{tibble} (che è identico ad un data frame ma viene stampato sulla console in un modo diverso):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(msleep)}
\end{Highlighting}
\end{Shaded}

\noindent  Estraiamo da \texttt{msleep} la variabile \texttt{sleep\_total} usando il verbo \texttt{pull()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pull}\NormalTok{(sleep\_total)}
\CommentTok{\#\textgreater{}  [1] 12.1 17.0 14.4 14.9  4.0 14.4  8.7  7.0 10.1  3.0}
\CommentTok{\#\textgreater{} [11]  5.3  9.4 10.0 12.5 10.3  8.3  9.1 17.4  5.3 18.0}
\CommentTok{\#\textgreater{} [21]  3.9 19.7  2.9  3.1 10.1 10.9 14.9 12.5  9.8  1.9}
\CommentTok{\#\textgreater{} [31]  2.7  6.2  6.3  8.0  9.5  3.3 19.4 10.1 14.2 14.3}
\CommentTok{\#\textgreater{} [41] 12.8 12.5 19.9 14.6 11.0  7.7 14.5  8.4  3.8  9.7}
\CommentTok{\#\textgreater{} [51] 15.8 10.4 13.5  9.4 10.3 11.0 11.5 13.7  3.5  5.6}
\CommentTok{\#\textgreater{} [61] 11.1 18.1  5.4 13.0  8.7  9.6  8.4 11.3 10.6 16.6}
\CommentTok{\#\textgreater{} [71] 13.8 15.9 12.8  9.1  8.6 15.8  4.4 15.6  8.9  5.2}
\CommentTok{\#\textgreater{} [81]  6.3 12.5  9.8}
\end{Highlighting}
\end{Shaded}

\hypertarget{selezionare-piuxf9-colonne-con-select}{%
\subsubsection{\texorpdfstring{Selezionare più colonne con \texttt{select()}}{Selezionare più colonne con select()}}\label{selezionare-piuxf9-colonne-con-select}}

Se vogliamo selezionare da \texttt{msleep} un insieme di variabili, ad esempio \texttt{name}, \texttt{vore} e \texttt{sleep\_total}, possiamo usare il verbo \texttt{select()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{select}\NormalTok{(name, vore, sleep\_total)}
\NormalTok{dt}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 3}
\CommentTok{\#\textgreater{}   name                       vore  sleep\_total}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                      \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Cheetah                    carni        12.1}
\CommentTok{\#\textgreater{} 2 Owl monkey                 omni         17  }
\CommentTok{\#\textgreater{} 3 Mountain beaver            herbi        14.4}
\CommentTok{\#\textgreater{} 4 Greater short{-}tailed shrew omni         14.9}
\CommentTok{\#\textgreater{} 5 Cow                        herbi         4  }
\CommentTok{\#\textgreater{} 6 Three{-}toed sloth           herbi        14.4}
\CommentTok{\#\textgreater{} 7 Northern fur seal          carni         8.7}
\CommentTok{\#\textgreater{} 8 Vesper mouse               \textless{}NA\textgreater{}          7  }
\CommentTok{\#\textgreater{} \# ... with 75 more rows}
\end{Highlighting}
\end{Shaded}

\noindent laddove la sequenza di istruzioni precedenti significa che abbiamo passato \texttt{msleep} alla funzione \texttt{select()} contenuta nel pacchetto \texttt{dplyr} e l'output di \texttt{select()} è stato salvato (usando l'operatore di assegnazione, \texttt{\textless{}-}) nell'oggetto \texttt{dt}. Alla funzione \texttt{select()} abbiamo passato gli argomenti \texttt{name}, \texttt{vore} e \texttt{sleep\_total}.

\hypertarget{filtrare-le-osservazioni-righe-con-filter}{%
\subsubsection{\texorpdfstring{Filtrare le osservazioni (righe) con \texttt{filter()}}{Filtrare le osservazioni (righe) con filter()}}\label{filtrare-le-osservazioni-righe-con-filter}}

Il verbo \texttt{filter()} consente di selezionare da un \texttt{tibble} un sottoinsieme di righe (osservazioni). Per esempio, possiamo selezionare tutte le osservazioni nella variabile \texttt{vore} contrassegnate come \texttt{carni} (ovvero, tutti i carnivori):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{filter}\NormalTok{(vore }\SpecialCharTok{==} \StringTok{"carni"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 19 x 3}
\CommentTok{\#\textgreater{}   name                 vore  sleep\_total}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Cheetah              carni        12.1}
\CommentTok{\#\textgreater{} 2 Northern fur seal    carni         8.7}
\CommentTok{\#\textgreater{} 3 Dog                  carni        10.1}
\CommentTok{\#\textgreater{} 4 Long{-}nosed armadillo carni        17.4}
\CommentTok{\#\textgreater{} 5 Domestic cat         carni        12.5}
\CommentTok{\#\textgreater{} 6 Pilot whale          carni         2.7}
\CommentTok{\#\textgreater{} 7 Gray seal            carni         6.2}
\CommentTok{\#\textgreater{} 8 Thick{-}tailed opposum carni        19.4}
\CommentTok{\#\textgreater{} \# ... with 11 more rows}
\end{Highlighting}
\end{Shaded}

Per utilizzare il verbo \texttt{filter()} in modo efficace è neccessario usare gli operatori relazionali (Tabella \ref{tab:oprelazionali}) e gli operatori logici (Tabella \ref{tab:oplogici}) di \texttt{R}. Per un approfondimento, si veda il Capitolo \href{https://r4ds.had.co.nz/transform.html}{Comparisons} di \emph{R for Data Science}.

\begin{table}[h!]
  \begin{center}
    \caption{Operatori relazionali.}
    \label{tab:oprelazionali}
    \begin{tabular}{l c} 
      \toprule
      uguale             &  == \\
      diverso            &  !=  \\
      minore             &  <  \\
      maggiore           &  >  \\
      minore o uguale      & <=  \\
      maggiore o uguale  & >=  \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h!]
  \begin{center}
    \caption{Operatori logici.}
    \label{tab:oplogici}
    \begin{tabular}{l c} 
      \toprule
      AND      &  \&    \\
      OR       &  | \\
      NOT      &  !   \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\hypertarget{creare-una-nuova-variabile-con-mutate}{%
\subsubsection{\texorpdfstring{Creare una nuova variabile con \texttt{mutate()}}{Creare una nuova variabile con mutate()}}\label{creare-una-nuova-variabile-con-mutate}}

Talvolta vogliamo creare una nuova variabile, per esempio, sommando o dividendo due variabili, oppure calcolandone la media. A questo scopo si usa il verbo \texttt{mutate()}. Per esempio, se vogliamo esprimere i valori di \texttt{sleep\_total} in minuti, moltiplichiamo per 60:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}
    \AttributeTok{sleep\_minutes =}\NormalTok{ sleep\_total }\SpecialCharTok{*} \DecValTok{60}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{select}\NormalTok{(sleep\_total, sleep\_minutes)}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 2}
\CommentTok{\#\textgreater{}   sleep\_total sleep\_minutes}
\CommentTok{\#\textgreater{}         \textless{}dbl\textgreater{}         \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1        12.1           726}
\CommentTok{\#\textgreater{} 2        17            1020}
\CommentTok{\#\textgreater{} 3        14.4           864}
\CommentTok{\#\textgreater{} 4        14.9           894}
\CommentTok{\#\textgreater{} 5         4             240}
\CommentTok{\#\textgreater{} 6        14.4           864}
\CommentTok{\#\textgreater{} 7         8.7           522}
\CommentTok{\#\textgreater{} 8         7             420}
\CommentTok{\#\textgreater{} \# ... with 75 more rows}
\end{Highlighting}
\end{Shaded}

\hypertarget{ordinare-i-dati-con-arrange}{%
\subsubsection{\texorpdfstring{Ordinare i dati con \texttt{arrange()}}{Ordinare i dati con arrange()}}\label{ordinare-i-dati-con-arrange}}

Il verbo \texttt{arrange()} ordina i dati in base ai valori di una o più variabili. Per esempio, possiamo ordinare la variabile \texttt{sleep\_total} dal valore più alto al più basso in questo modo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{arrange}\NormalTok{(}
    \FunctionTok{desc}\NormalTok{(sleep\_total)}
\NormalTok{  )}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 3}
\CommentTok{\#\textgreater{}   name                   vore    sleep\_total}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                  \textless{}chr\textgreater{}         \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Little brown bat       insecti        19.9}
\CommentTok{\#\textgreater{} 2 Big brown bat          insecti        19.7}
\CommentTok{\#\textgreater{} 3 Thick{-}tailed opposum   carni          19.4}
\CommentTok{\#\textgreater{} 4 Giant armadillo        insecti        18.1}
\CommentTok{\#\textgreater{} 5 North American Opossum omni           18  }
\CommentTok{\#\textgreater{} 6 Long{-}nosed armadillo   carni          17.4}
\CommentTok{\#\textgreater{} 7 Owl monkey             omni           17  }
\CommentTok{\#\textgreater{} 8 Arctic ground squirrel herbi          16.6}
\CommentTok{\#\textgreater{} \# ... with 75 more rows}
\end{Highlighting}
\end{Shaded}

\hypertarget{raggruppare-i-dati-con-group_by}{%
\subsubsection{\texorpdfstring{Raggruppare i dati con \texttt{group\_by()}}{Raggruppare i dati con group\_by()}}\label{raggruppare-i-dati-con-group_by}}

Il verbo \texttt{group\_by()} raggruppa insieme i valori in base a una o più variabili. Lo vedremo in uso in seguito insieme a \texttt{summarise()}.

Nota: con \texttt{dplyr()}, le operazioni raggruppate vengono iniziate con la funzione \texttt{group\_by()}. È una buona norma utilizzare \texttt{ungroup()} alla fine di una serie di operazioni raggruppate, altrimenti i raggruppamenti verranno mantenuti nelle analisi successiva, il che non è sempre auspicabile.

\hypertarget{sommario-dei-dati-con-summarise}{%
\subsubsection{\texorpdfstring{Sommario dei dati con \texttt{summarise()}}{Sommario dei dati con summarise()}}\label{sommario-dei-dati-con-summarise}}

Il verbo \texttt{summarise()} collassa il dataset in una singola riga dove viene riportato il risultato della statistica richiesta. Per esempio, la media del tempo totale del sonno è

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{m\_sleep =} \FunctionTok{mean}\NormalTok{(sleep\_total, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  ) }
\CommentTok{\#\textgreater{} \# A tibble: 1 x 1}
\CommentTok{\#\textgreater{}   m\_sleep}
\CommentTok{\#\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1    10.4}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-raggruppate}{%
\subsubsection{Operazioni raggruppate}\label{operazioni-raggruppate}}

Sopra abbiamo visto come i mammiferi considerati dormano, in media, 10.4 ore al giorno. Troviamo ora il sonno medio in funzione di \texttt{vore}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(vore) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{m\_sleep =} \FunctionTok{mean}\NormalTok{(sleep\_total, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{), }
    \AttributeTok{n =} \FunctionTok{n}\NormalTok{()}
\NormalTok{  )}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 3}
\CommentTok{\#\textgreater{}   vore    m\_sleep     n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}     \textless{}dbl\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 carni     10.4     19}
\CommentTok{\#\textgreater{} 2 herbi      9.51    32}
\CommentTok{\#\textgreater{} 3 insecti   14.9      5}
\CommentTok{\#\textgreater{} 4 omni      10.9     20}
\CommentTok{\#\textgreater{} 5 \textless{}NA\textgreater{}      10.2      7}
\end{Highlighting}
\end{Shaded}

\noindent Si noti che, nel caso di 7 osservazioni, il valore di \texttt{vore} non era specificato. Per tali osservazioni, dunque, la classe di appartenenza è \texttt{NA}.

\hypertarget{applicare-una-funzione-su-piuxf9-colonne-across}{%
\subsubsection{\texorpdfstring{Applicare una funzione su più colonne: \texttt{across()}}{Applicare una funzione su più colonne: across()}}\label{applicare-una-funzione-su-piuxf9-colonne-across}}

È spesso utile eseguire la stessa operazione su più colonne, ma copiare e incollare è sia noioso che soggetto a errori:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(g1, g2) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{a =} \FunctionTok{mean}\NormalTok{(a),}
    \AttributeTok{b =} \FunctionTok{mean}\NormalTok{(b),}
    \AttributeTok{c =} \FunctionTok{mean}\NormalTok{(c),}
    \AttributeTok{d =} \FunctionTok{mean}\NormalTok{(d)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\noindent In tali circostanze è possibile usare la funzione \texttt{across()} che consente di riscrivere il codice precedente in modo più succinto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(g1, g2) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarise}\NormalTok{(}\FunctionTok{across}\NormalTok{(a}\SpecialCharTok{:}\NormalTok{d, mean))}
\end{Highlighting}
\end{Shaded}

\noindent Per i dati presenti, ad esempio, possiamo avere:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(vore) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise}\NormalTok{(}\FunctionTok{across}\NormalTok{(}\FunctionTok{starts\_with}\NormalTok{(}\StringTok{"sleep"}\NormalTok{), }\SpecialCharTok{\textasciitilde{}} \FunctionTok{mean}\NormalTok{(.x, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)))}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 4}
\CommentTok{\#\textgreater{}   vore    sleep\_total sleep\_rem sleep\_cycle}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}         \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 carni         10.4       2.29       0.373}
\CommentTok{\#\textgreater{} 2 herbi          9.51      1.37       0.418}
\CommentTok{\#\textgreater{} 3 insecti       14.9       3.52       0.161}
\CommentTok{\#\textgreater{} 4 omni          10.9       1.96       0.592}
\CommentTok{\#\textgreater{} 5 \textless{}NA\textgreater{}          10.2       1.88       0.183}
\end{Highlighting}
\end{Shaded}

\hypertarget{dati-categoriali-in-r}{%
\subsection{\texorpdfstring{Dati categoriali in \texttt{R}}{Dati categoriali in R}}\label{dati-categoriali-in-r}}

Consideriamo una variabile che descrive il genere e include le categorie \texttt{male}, \texttt{female} e \texttt{non-conforming}. In \texttt{R}, ci sono due modi per memorizzare queste informazioni. Uno è usare la classe \emph{character strings} e l'altro è usare la classe \emph{factor}. Non ci addentrimo qui nelle sottigliezze di questa distinzione, motivata in gran parte per le necessità della programmazione con le funzioni di \texttt{tidyverse}. Per gli scopi di questo insegnamento sarà sufficiente codificare le variabili qualitative usando la classe \emph{factor}. Una volta codificati i dati qualitativi utilizzando la classe \emph{factor}, si pongono spesso due problemi:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  modificare le etichette dei livelli (ovvero, le modalità) di un fattore,
\item
  riordinare i livelli di un fattore.
\end{enumerate}

\hypertarget{modificare-le-etichette-dei-livelli-di-un-fattore}{%
\subsubsection{Modificare le etichette dei livelli di un fattore}\label{modificare-le-etichette-dei-livelli-di-un-fattore}}

Esaminiamo l'esempio seguente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"old\_3"}\NormalTok{, }\StringTok{"old\_4"}\NormalTok{, }\StringTok{"old\_1"}\NormalTok{, }\StringTok{"old\_1"}\NormalTok{, }\StringTok{"old\_2"}\NormalTok{)}
\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(f\_1)}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(f\_1, y)}
\NormalTok{df}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 2}
\CommentTok{\#\textgreater{}   f\_1       y}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 old\_3     1}
\CommentTok{\#\textgreater{} 2 old\_4     2}
\CommentTok{\#\textgreater{} 3 old\_1     3}
\CommentTok{\#\textgreater{} 4 old\_1     4}
\CommentTok{\#\textgreater{} 5 old\_2     5}
\end{Highlighting}
\end{Shaded}

\noindent Supponiamo ora di volere che i livelli del fattore \texttt{f\_1} abbiano le etichette \texttt{new\_1}, \texttt{new\_2}, ecc. Per ottenere questo risultato usiamo la funzione \texttt{forcats::fct\_recode()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}}\NormalTok{ df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{f\_1 =}
\NormalTok{    forcats}\SpecialCharTok{::}\FunctionTok{fct\_recode}\NormalTok{(}
\NormalTok{      f\_1, }
      \StringTok{"new\_poco"} \OtherTok{=} \StringTok{"old\_1"}\NormalTok{, }
      \StringTok{"new\_medio"} \OtherTok{=} \StringTok{"old\_2"}\NormalTok{, }
      \StringTok{"new\_tanto"} \OtherTok{=} \StringTok{"old\_3"}\NormalTok{, }
      \StringTok{"new\_massimo"} \OtherTok{=} \StringTok{"old\_4"}
\NormalTok{      )}
\NormalTok{   )}
\NormalTok{df}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 2}
\CommentTok{\#\textgreater{}   f\_1             y}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}       \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 new\_tanto       1}
\CommentTok{\#\textgreater{} 2 new\_massimo     2}
\CommentTok{\#\textgreater{} 3 new\_poco        3}
\CommentTok{\#\textgreater{} 4 new\_poco        4}
\CommentTok{\#\textgreater{} 5 new\_medio       5}
\end{Highlighting}
\end{Shaded}

\hypertarget{riordinare-i-livelli-di-un-fattore}{%
\subsubsection{Riordinare i livelli di un fattore}\label{riordinare-i-livelli-di-un-fattore}}

Spesso i livelli dei fattori hanno un ordinamento naturale. Quindi, gli utenti devono avere un modo per imporre l'ordine desiderato sulla codifica delle loro variabili qualitative. Se per qualche motivo vogliamo ordinare i livelli \texttt{f\_1} in ordine inverso, ad esempio, possiamo procedere nel modo seguente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{f\_1,}
  \AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}
    \StringTok{"new\_massimo"}\NormalTok{, }\StringTok{"new\_tanto"}\NormalTok{, }\StringTok{"new\_medio"}\NormalTok{, }\StringTok{"new\_poco"} 
\NormalTok{  )}
\NormalTok{)}
\FunctionTok{summary}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{f\_1)}
\CommentTok{\#\textgreater{} new\_massimo   new\_tanto   new\_medio    new\_poco }
\CommentTok{\#\textgreater{}           1           1           1           2}
\end{Highlighting}
\end{Shaded}

\noindent Per approfondire le problematiche della manipolazione di variabili qualitative in \texttt{R}, si veda \citet{mcnamara2018wrangling}.

\hypertarget{creare-grafici-con-ggplot2}{%
\subsection{\texorpdfstring{Creare grafici con \texttt{ggplot2()}}{Creare grafici con ggplot2()}}\label{creare-grafici-con-ggplot2}}

Il pacchetto \texttt{ggplot2()} è un potente strumento per rappresentare graficamente i dati. Le iniziali del nome, \texttt{gg}, si riferiscono alla ``Grammar of Graphics'', che è un modo di pensare le figure come una serie di layer stratificati. Originariamente descritta da \citet{wilkinson2012grammar}, la grammatica dei grafici è stata aggiornata e applicata in \texttt{R} da Hadley Wickham, il creatore del pacchetto.

La funzione da cui si parte per inizializzare un grafico è \texttt{ggplot()}. La funzione \texttt{ggplot()} richiede due argomenti. Il primo è l'oggetto di tipo data.frame che contiene i dati da visualizzare -- in alternativa al primo argomento, un dataframe può essere passato a \texttt{ggplot()} mediante l'operatore pipe. Il secondo è una particolare lista che viene generata dalla funzione \texttt{aes()}, la quale determina l'aspetto (\emph{aesthetic}) del grafico. La funzione \texttt{aes()} richiede necessariamente di specificare ``x'' e ``y'', ovvero i nomi delle colonne del data.frame che è stato utilizzato quale primo argomento di \texttt{ggplot()} (o che è stato passato da pipe), le quali rappresentano le variabili da porre rispettivamente sugli assi orizzontale e verticale.

La definizione della tipologia di grafico e i vari parametri sono poi definiti successivamente, aggiungendo all'oggetto creato da \texttt{ggplot()} tutte le componenti necessarie. Saranno quindi altre funzioni, come \texttt{geom\_bar()}, \texttt{geom\_line()} o \texttt{geom\_point()} a occuparsi di aggiungere al livello di base barre, linee, punti, e così via. Infine, tramite altre funzioni, ad esempio \texttt{labs()}, sarà possibile definire i dettagli più fini.

Gli elementi grafici (bare, punti, segmenti, \ldots) usati da \texttt{ggplot2} sono chiamati \texttt{geoms}. Mediante queste funzioni è possibile costruire diverse tipologie di grafici:

\begin{itemize}
\item
  \texttt{geom\_bar()}: crea un layer con delle barre;
\item
  \texttt{geom\_point()}: crea un layer con dei punti (diagramma a dispersione);
\item
  \texttt{geom\_line()}: crea un layer con una linea retta;
\item
  \texttt{geom\_histogram()}: crea un layer con un istogramma;
\item
  \texttt{geom\_boxplot()}: crea un layer con un box-plot;
\item
  \texttt{geom\_errorbar()}: crea un layer con barre che rappresentano intervalli di confidenza;
\item
  \texttt{geom\_hline()} e \texttt{geom\_vline()} : crea un layer con una linea orizzontale o verticale definita dall'utente.
\end{itemize}

Un comando generico ha la seguente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_graph }\OtherTok{\textless{}{-}}\NormalTok{ my\_data }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_var, y\_var)) }\SpecialCharTok{+}
  \FunctionTok{geom\_...}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

La prima volta che si usa il pacchetto \texttt{ggplot2} è necessario installarlo. Per fare questo possiamo installare \texttt{tidyverse} che, oltre a caricare \texttt{ggplot2}, carica anche altre utili funzioni per l'analisi dei dati. Ogni volta che si inizia una sessione R è necessario attivare i pacchetti che si vogliono usare, ma non è necessario istallarli una nuova volta. Se è necessario specificare il pacchetto nel quale è contenuta la funzione che vogliamo utilizzare, usiamo la sintassi \texttt{package::function()}. Per esempio, l'istruzione \texttt{ggplot2::ggplot()} rende esplicito che stiamo usando la funzione \texttt{ggplot()} contenuta nel pacchetto \texttt{ggplot2}.

\hypertarget{diagramma-a-dispersione}{%
\subsection{Diagramma a dispersione}\label{diagramma-a-dispersione}}

Consideriamo nuovamenti i dati contenuti nel \texttt{tibble} \texttt{msleep} e poniamoci il problema di rappresentare graficamente la relazione tra il numero medio di ore di sonno giornaliero (\texttt{sleep\_total}) e il peso dell'animale (\texttt{bodywt}). Usando le impostazioni di default di \texttt{ggplot2}, con le istruzioni seguenti, otteniamo il grafico fornito dalla figura seguente.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"msleep"}\NormalTok{)}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bodywt, }\AttributeTok{y =}\NormalTok{ sleep\_total)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-210-1} \end{center}

Coloriamo ora in maniera diversa i punti che rappresentano animali carnivori, erbivori, ecc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bodywt, }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-211-1} \end{center}

È chiaro, senza fare alcuna analisi statistica, che la relazione tra le due variabili non è lineare. Trasformando in maniera logaritmica i valori dell'asse \(x\) la relazione si linearizza.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =} \FunctionTok{log}\NormalTok{(bodywt), }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-212-1} \end{center}

Infine, aggiustiamo il ``tema'' del grafico (si noti l'utilizzo di una tavolozza di colori adatta ai daltonici mediante il pacchetto \texttt{viridis}), aggiungiamo le etichette sugli assi e il titolo.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"viridis"}\NormalTok{)}
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =} \FunctionTok{log}\NormalTok{(bodywt), }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{8}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Peso corporeo (log)"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Ore di sonno"}\NormalTok{,}
    \AttributeTok{title =} \StringTok{"Il sonno in 83 specie di mammiferi"}\NormalTok{,}
    \AttributeTok{subtitle =} \StringTok{"Un esempio di visualizzazione con ggplot()"}\NormalTok{,}
    \AttributeTok{caption =} \StringTok{"Fonte: Savage e West (2007)"}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_viridis}\NormalTok{(}\AttributeTok{discrete =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{option =} \StringTok{"viridis"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme\_minimal}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.title =} \FunctionTok{element\_blank}\NormalTok{()) }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-213-1} \end{center}

La visualizzazione può essere migliorata cambiando le etichette della legenda del grafico. Per fare questo è necessario intervenire sui dati prima di usare \texttt{ggplot()} -- per esempio, come abbiamo fatto in precedenza con la funzione \texttt{forcats::fct\_recode()}.

\hypertarget{istogramma}{%
\subsubsection{Istogramma}\label{istogramma}}

Creiamo ora un istogramma che rappresenta la distribuzione del (logaritmo del) peso medio del cervello delle 83 specie di mammiferi considerate da \citet{savage2007quantitative}. L'argomento \texttt{aes(y\ =\ ..density..)} in \texttt{geom\_histogram()} produce le frequenze relative. L'opzione di default (senza questo argomento) porta \texttt{ggplot()} a rappresentare le frequenze assolute.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\FunctionTok{log}\NormalTok{(brainwt))}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..)) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Peso del cervello (log)"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Frequenza relativa"}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.title =} \FunctionTok{element\_blank}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{ds4psy_files/figure-latex/unnamed-chunk-214-1} \end{center}

\hypertarget{scrivere-il-codice-r-con-stile}{%
\subsection{\texorpdfstring{Scrivere il codice \texttt{R} con stile}{Scrivere il codice R con stile}}\label{scrivere-il-codice-r-con-stile}}

Uno stile di programmazione è un insieme di regole per la gestione dell'indentazione dei blocchi di codice, per la creazione dei nomi dei file e delle variabili e per le convenzioni tipografiche che vengono usate. Scrivere il codice in \texttt{R} con stile consente di creare listati più leggibili e semplici da modificare, minimizza la possibilità di errore, e consente correzioni e modifiche più rapide. Vi sono molteplici stili di programmazione che possono essere utilizzati dall'utente, anche se è bene attenersi a quelle che sono le convenzioni maggiormente diffuse, allo scopo di favorire la comunicazione. In ogni caso, l'importante è di essere coerenti, ovvero di adottare le stesse convenzioni in tutte le parti del codice che si scrive. Ad esempio, se si sceglie di usare lo stile \texttt{snake\_case} per il nome composto di una variabile (es., \texttt{personality\_trait}), non è appropriato usare lo stile \emph{lower Camel case} per un'altra variabile (es., \texttt{socialStatus}). Dato che questo argomento è stato trattato ampiamente in varie sedi, mi limito qui a rimandare ad uno \href{http://style.tidyverse.org/}{stile di programmazione} molto popolare, quello proposto da Hadley Wickham, il creatore di \texttt{tidyverse}. La soluzione più semplice è quella installare \texttt{stiler}, che è uno RStudio Addin, e formattare il codice in maniera automatica utilizzando lo stile proposto da Hadley Wickham. Si possono ottenere informazioni su \texttt{stiler} seguendo questo \href{https://github.com/r-lib/styler}{link}.

\hypertarget{ottenere-informazioni-sulle-funzioni-r}{%
\section{\texorpdfstring{Ottenere informazioni sulle funzioni \(\R\)}{Ottenere informazioni sulle funzioni \textbackslash R}}\label{ottenere-informazioni-sulle-funzioni-r}}

Oltre a \texttt{?help\ \textless{}funzione\textgreater{}}, è possibile ricorrere al pacchetto \texttt{introverse}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{remotes}\SpecialCharTok{::}\FunctionTok{install\_github}\NormalTok{(}\StringTok{"spielmanlab/introverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\noindent Il pacchetto \texttt{introverse} fornisce documentazione alternativa per funzioni e concetti comunemente usati in Base \(\R\) e nel \texttt{tidyverse}. Istruzioni relative all'uso delle funzioni disponibili vengono fornite quando si carica il pacchetto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"introverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Welcome to the \{introverse\}}\SpecialCharTok{!}

\NormalTok{Not sure where to start? You can...}

\SpecialCharTok{{-}}\NormalTok{ Run }\FunctionTok{show\_topics}\NormalTok{() to see all the different functions }
\NormalTok{  and topics you can ask }\ControlFlowTok{for}\NormalTok{ help with.}
  
\SpecialCharTok{{-}}\NormalTok{ Run }\FunctionTok{show\_topics}\NormalTok{(}\StringTok{"library or category of interest"}\NormalTok{) to see }
\NormalTok{  all the different functions within a certain library}\SpecialCharTok{/}\NormalTok{category }
\NormalTok{  of interest. For example, to see all help topics }\ControlFlowTok{for}\NormalTok{ \{dplyr\}}
\NormalTok{  functions, run}\SpecialCharTok{:} \FunctionTok{show\_topics}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{).}

\SpecialCharTok{{-}}\NormalTok{ Run }\FunctionTok{get\_help}\NormalTok{(}\StringTok{"carnivores"}\NormalTok{) and }\FunctionTok{get\_help}\NormalTok{(}\StringTok{"msleep"}\NormalTok{) to learn }
\NormalTok{  about the datasets used }\ControlFlowTok{in}\NormalTok{ examples.}
    
\SpecialCharTok{{-}}\NormalTok{ Run the }\ControlFlowTok{function} \FunctionTok{get\_help}\NormalTok{() to see the \{introverse\} docs}
  \ControlFlowTok{for}\NormalTok{ a }\ControlFlowTok{function}\NormalTok{ or topic. For example, to get help using }
\NormalTok{  the }\StringTok{\textasciigrave{}}\AttributeTok{length()}\StringTok{\textasciigrave{}} \ControlFlowTok{function}\NormalTok{, run}\SpecialCharTok{:} \FunctionTok{get\_help}\NormalTok{(}\StringTok{"length"}\NormalTok{).}
\NormalTok{  Don}\StringTok{\textquotesingle{}t forget quotation marks around the argument to get\_help()!}
\end{Highlighting}
\end{Shaded}

\hypertarget{flusso-di-lavoro-riproducibile}{%
\section{Flusso di lavoro riproducibile}\label{flusso-di-lavoro-riproducibile}}

\hypertarget{la-crisi-della-riproducibilituxe0}{%
\subsection{La crisi della riproducibilità}\label{la-crisi-della-riproducibilituxe0}}

\emph{``Per il metodo scientifico è essenziale che gli esperimenti siano riproducibili. Vale a dire che una persona diversa dallo sperimentatore originale deve essere in grado di ottenere gli stessi risultati seguendo lo stesso protocollo sperimentale (Gilbert Chin).''} Ma in psicologia (e non solo) la riproducibilità è inferiore a quanto previsto o desiderato. In un famoso studio pubblicato su \emph{Science}, un ampio gruppo di ricercatori \citep{open2015estimating} è riuscito a replicare solo il 40 per cento circa dei risultati di 100 studi di psicologia cognitiva e sociale pubblicati in precedenza. I risultati di questo studio, e di molti altri pubblicati in seguito, sono stati interpretati in modi diversi. La preoccupazione sulla riproducibilità della ricerca è stata espressa mediante l'affermare secondo la quale ``la maggior parte dei risultati della ricerca sono falsi'' \citep{ioannidis2005most} oppure mediante l'affermazione secondo cui ``dobbiamo apportare modifiche sostanziali al modo in cui conduciamo la ricerca'' \citep{cumming2014new}. Alcuni ricercatori sono arrivati a definire la presente situazione come una ``crisi della riproducibilità dei risultati della ricerca''.

Il termine ``riproducibilità'' (o ``replicabilità'') è stato definito in vari modi. Consideriamo la definizione fornita da \citet{goodman2016does}:

\begin{itemize}
\item
  la riproducibilità dei metodi ``si riferisce al fatto che il ricercatore fornisce dettagli sufficienti sulle procedure e sui dati dello studio in modo che le stesse procedure possano \ldots{} essere replicate esattamente'' (pag. 2) con gli stessi dati;
\item
  la riproducibilità dei risultati ``si riferisce all'ottenimento degli stessi risultati dalla conduzione di uno studio indipendente le cui procedure replicano il più esattamente possibile quelle dell'esperimento originale'' (pag. 2-3) con dati indipendenti;
\item
  la riproducibilità inferenziale ``si riferisce alla possibilità di trarre conclusioni qualitativamente simili da una replica indipendente di uno studio o da una nuova analisi dello studio originale'' (pag. 4).
\end{itemize}

Per gli scopi presenti, ci focalizzeremo qui sulla riproducibilità dei metodi. Cioè, discuteremo di come \texttt{R} può aiutarci a migliorare questo aspetto della riproducibilità. In questo capitolo mostreremo come R possa essere utilizzato all'interno di un flusso di lavoro (\emph{workflow}) riproducibile che integra (1) il codice di analisi dei dati, (2) i dati medesimi e (3) il testo della relazione che comunica i risultati dello studio. A tal fine utilizzeremo due pacchetti R: \texttt{rmarkdown} e \texttt{knitr}. Questi pacchetti consentono di unire il codice R ad un linguaggio di marcatura (o di markup) chiamato Markdown. Il linguaggio di markup Markdown sta diventando sempre più popolare e viene usato, oltre che per creare \href{https://avehtari.github.io/ROS-Examples/Simplest/simplest.html}{reports} di analisi di dati, anche per creare \href{https://alison.rbind.io}{siti web}, \href{https://djnavarro.net}{blog}, \href{https://r4ds.had.co.nz}{libri}, \href{https://osf.io/9te8p/}{articoli accademici}, \href{https://github.com/mitchelloharawild/vitae}{curriculum vitae}, \href{https://rmarkdown.rstudio.com/lesson-11.html}{slide}, \href{https://github.com/ismayc/thesisdown}{tesi di laurea}. Per esempio, il presente sito web è stato scritto usando R-markdown.

\hypertarget{r-markdown}{%
\subsection{R-markdown}\label{r-markdown}}

Un linguaggio di markup permette di aggiungere mediante marcatori (tag) informazioni sulla struttura e sulla formattazione da applicare ad un documento. Un'introduzione al linguaggio Markdown può essere trovata, per esempio, \href{https://rmarkdown.rstudio.com/authoring_pandoc_markdown.html}{qui} oppure \href{https://experienceleague.adobe.com/docs/contributor/contributor-guide/writing-essentials/markdown.html?lang=it\#estensioni-personalizzate-markdown}{qui}.

In questo capitolo ci focalizzeremo però sugli aspetti più importanti di R-markdown che permette di costruire documenti in cui combinare testo formattato (quindi non solo commenti ma anche formule, titoli etc) e istruzioni codice (\texttt{R} e non solo) con i corrispettivi output. Informazioni dettagliate su R-markdown sono disponibili \href{https://bookdown.org/yihui/rmarkdown/}{qui} e \href{https://bookdown.org/yihui/rmarkdown-cookbook/}{qui}.

Un file R-markdown è composto da tre tipi di oggetti:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  header in formato \texttt{YAML} delimitato da \texttt{-\/-\/-},
\item
  testo in formato \texttt{markdown},
\item
  blocchi (``chunks'') di codice \texttt{R}, delimitati da tre apici.
\end{enumerate}

\hypertarget{header}{%
\subsubsection{Header}\label{header}}

L'intestazione di un documento \texttt{.Rmd} (R-markdown) corrisponde al cosiddetto \emph{YAML header} (un acronimo che significa \emph{Yet Another Markup Language}). Lo YAML header controlla le caratteristiche generali del documento, incluso il tipo di documento che viene prodotto (un documento HTML che può essere visualizzato su tutti i principali browser, un documento Microsoft Word o un PDF se abbiamo installato LaTeX sul nostro computer), la dimensione del carattere, lo stile, il titolo, l'autore, ecc. Nello YAML header (a differenza del codice \texttt{R}) è necessario rispettare la spaziatura prestabilita delle istruzioni che vengono elencate. Gli elementi principali sono \texttt{title:}, \texttt{author:}, \texttt{output:}.

L'argomento di \texttt{output:} è dove diciamo a R-markdown quale tipo di file vogliamo che venga prodotto. Il tipo più flessibile, che non richiede alcuna configurazione, è \texttt{html\_document}.

\hypertarget{testo}{%
\subsubsection{Testo}\label{testo}}

Alla conclusione dello YAML header inizia il documento R-markdown. Da questo punto in poi possiamo utilizzare testo normale, codice \texttt{R} e sintassi Markdown per controllare cosa viene mostrato e come.

\hypertarget{formattazione}{%
\subsubsection{Formattazione}\label{formattazione}}

È possibile contrassegnare intestazioni, grassetto e corsivo come indicato di seguito.

\begin{verbatim}
# Intestazione 1
## Intestazione 2
### Intestazione 3
#### Intestazione 4
##### Intestazione 5
###### Intestazione 6

Questo è un testo normale.
Possiamo scrivere in **grassetto** il testo usando due asterischi.
Possiamo scrivere in *corsivo* usando un asterisco.

>Questa è un’**area rientrata**.

Questa riga invece non è più rientrata.
\end{verbatim}

\hypertarget{elenchi}{%
\subsubsection{Elenchi}\label{elenchi}}

Per creare un elenco puntato si utilizza il segno più, il trattino o l'asterisco. Tutte le tre soluzioni portano allo stesso risultato.

\begin{verbatim}
- Punto 1 della lista
- Punto 2 della lista
- Punto 3 della lista
\end{verbatim}

Un elenco numerato, invece, si crea con un numero seguito da un punto.

\begin{verbatim}
1. Punto 1 della lista
2. Punto 2 della lista
3. Punto 3 della lista
\end{verbatim}

\hypertarget{hyperlink}{%
\subsubsection{Hyperlink}\label{hyperlink}}

Per inserire un hyperlink ci sono due metodi:

\begin{itemize}
\tightlist
\item
  specificare solo il percorso \texttt{\textless{}http://rmarkdown.rstudio.com\textgreater{}}, \url{http://rmarkdown.rstudio.com}\\
\item
  creare un \href{http://rmarkdown.rstudio.com}{link} con \texttt{{[}link{]}(http://rmarkdown.rstudio.com)}\\
\end{itemize}

\hypertarget{immagini}{%
\subsubsection{Immagini}\label{immagini}}

Per inserire un'immagine la sintassi è molto simile: \texttt{!{[}Esempio\ di\ immagine\ inserita\ in\ un\ documento\ R-markdown.{]}(images/hex-rmarkdown.png)\{width=20\%\}}:

\begin{figure}
\centering
\includegraphics[width=0.2\textwidth,height=\textheight]{images/hex-rmarkdown.png}
\caption{Esempio di immagine inserita in un documento R-markdown.}
\end{figure}

\hypertarget{codice-inline}{%
\subsubsection{Codice inline}\label{codice-inline}}

Per contrassegnare un'area di testo come codice, markdown utilizza il cosiddetto backtick, noto anche come gravis o accento grave, da non confondere con la virgoletta singola. La marcatura prevede un accento all'inizio e uno alla fine dell'area di testo corrispondente.

\begin{verbatim}
Questo è `codice`.
\end{verbatim}

\hypertarget{equazioni}{%
\subsubsection{Equazioni}\label{equazioni}}

Equazioni possono essere inserite in un documento R-markdown usando la sintassi \LaTeX. Qualsiasi cosa all'interno del segno di dollaro \$ viene trattata come un'equazione ``inline''. Qualunque cosa all'interno di due segni di dollaro \$\$ viene trattata come un'equazione a sé stante.

Per esempio, questa è la formula della distribuzione Normale espressa in notazione LaTeX e riprodotta all'interno di un documento R-markdown:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(x) }\OtherTok{=}\NormalTok{ \textbackslash{}frac\{}\DecValTok{1}\NormalTok{\}\{\textbackslash{}sigma\textbackslash{}sqrt\{}\DecValTok{2}\NormalTok{\textbackslash{}pi\}\}}
\NormalTok{  \textbackslash{}exp\textbackslash{}}\FunctionTok{left}\NormalTok{( }\SpecialCharTok{{-}}\NormalTok{\textbackslash{}frac\{}\DecValTok{1}\NormalTok{\}\{}\DecValTok{2}\NormalTok{\}\textbackslash{}}\FunctionTok{left}\NormalTok{(\textbackslash{}frac\{x}\SpecialCharTok{{-}}\NormalTok{\textbackslash{}mu\}\{\textbackslash{}sigma\}\textbackslash{}right)}\SpecialCharTok{\^{}}\NormalTok{\{\textbackslash{}}\SpecialCharTok{!}\DecValTok{2}\NormalTok{\}\textbackslash{},\textbackslash{}right)}
\end{Highlighting}
\end{Shaded}

\[
f(x) = \frac{1}{\sigma\sqrt{2\pi}}
  \exp\left( -\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{\!2}\,\right)
\]

\hypertarget{codice-r}{%
\subsubsection{Codice R}\label{codice-r}}

In un documento R-markdown istruzioni di codice vengono inserite in blocchi delimitati da tre apici. Ciò consente di valutare il codice all'interno del documento e di produrre un output che verrà stampato nel documento stesso. Possiamo dunque stampare tabelle e figure prodotti direttamente dal codice \texttt{R}. Ciò significa inoltre, che se qualcosa cambia nei dati o nelle analisi dei dati, le tabelle e le figure si aggiorneranno automaticamente.

Un chunk \texttt{R} viene valutato proprio come il normale codice \texttt{R}, quindi si applica tutto ciò che abbiamo imparato nei capitoli precedenti. Se il chunk \texttt{R} produce un output, questo output verrà visualizzato nel documento.

\hypertarget{compilare-la-presentazione-r-markdown}{%
\subsection{Compilare la presentazione R-markdown}\label{compilare-la-presentazione-r-markdown}}

Ma dove si trova questo magico documento che include il testo e l'output prodotto dal codice \texttt{R}? Ottima domanda. Siamo stati abituati ai programmi di videoscrittura (come Microsoft Word) che si conformano al cosiddetto stile ``WYSIWYG'' (What You See Is What You Get) -- cioè, si vede come apparirà il documento stampato mentre lo si digita. Questo può avere alcuni vantaggi ma può anche essere molto limitante. R-Markdown, d'altra parte, funziona in modo diverso. Ovvero, deve essere ``compilato'' (knitted) per passare dal file sorgente al documento formattato. In RStudio, tale operazione è semplice: c'è un pulsante in alto a sinistra nel pannello di scripting di un documento \texttt{.Rmd}. È sufficiente selezionare tale pulsante e il nostro documento verrà creato.

È importante notare che il codice del documento deve essere autonomo. Ciò significa che tutto ciò che vogliamo che venga eseguito deve essere incluso nel documento, indipendentemente da ciò che era già stato eseguito al di fuori di esso. Ad esempio, è perfettamente legittimo (e anche molto utile) testare il codice \texttt{R} al di fuori del documento \texttt{Rmd}. Tuttavia, quando compiliamo il documento \texttt{Rmd}, tutto ciò che è stato fatto al di fuori del documento \texttt{Rmd} viene dimenticato. Ciò consente di creare un documento autosufficiente che favorisce la riproducibilità dei metodi di analisi dei dati: utilizzando uno specifico documento \texttt{Rmd} con un campione di dati si giunge sempre allo stesso risultato e alla stessa interpretazione. Ciò non è invece vero se si utilizza un software con un interfaccia point-and-click.

\hypertarget{dati-mancanti-1}{%
\section{Dati mancanti}\label{dati-mancanti-1}}

\hypertarget{motivazione-1}{%
\subsection{Motivazione}\label{motivazione-1}}

La pulizia dei dati (\emph{data cleaning}) in \texttt{R} è fondamentale per effettuare qualsiasi analisi. Uno degli aspetti più importanti della pulizia dei dati è la gestione dei dati mancanti. I valori mancanti (\emph{missing values}) vengono indicati dal codice \texttt{NA}, che significa \emph{not available} --- non disponibile.

\hypertarget{trattamento-dei-dati-mancanti}{%
\subsection{Trattamento dei dati mancanti}\label{trattamento-dei-dati-mancanti}}

Se una variabile contiene valori mancanti, \texttt{R} non è in grado di applicare ad essa alcune Funzioni, come ad esempio la media. Per questa ragione, la gran parte delle funzioni di \texttt{R} prevedono modi specifici per trattare i valori mancanti.

Ci sono diversi tipi di dati ``mancanti'' in \texttt{R};

\begin{itemize}
\tightlist
\item
  \texttt{NA} - generico dato mancante;
\item
  \texttt{NaN} - il codice \texttt{NaN} (\emph{Not a Number}) indica i valori numerici impossibili, quali ad esempio un valore 0/0;
\item
  \texttt{Inf} e \texttt{-Inf} - Infinity, si verifca, ad esempio, quando si divide un numero per 0.
\end{itemize}

La funzione \texttt{is.na()} ritorna un output che indica con TRUE le celle che contengono NA o NaN.

Si noti che

\begin{itemize}
\tightlist
\item
  se \texttt{is.na(x)} è TRUE, allora \texttt{!is.na(x)} è FALSE;
\item
  \texttt{all(!is.na(x))} ritorna TRUE se tutti i valori \texttt{x} sono NOT NA;
\item
  \texttt{any(is.na(x))} risponde alla domanda: c'è qualche valore NA (almeno uno) in \texttt{x}?;
\item
  \texttt{complete.cases(x)} ritorna TRUE se ciascun elemento di \texttt{x} è is NOT NA; ritorna FALSE se almeno un elemento di \texttt{x} è NA;
\end{itemize}

Le funzioni \texttt{R} \texttt{is.nan()} e \texttt{is.infinite()} si applicano ai tipi di dati \texttt{NaN} e \texttt{Inf}.

Per esempio, consideriamo il seguente data.frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{w =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{), }
  \AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }
  \AttributeTok{y =} \DecValTok{1}\NormalTok{, }
  \AttributeTok{z =}\NormalTok{ x }\SpecialCharTok{\^{}} \DecValTok{2} \SpecialCharTok{+}\NormalTok{ y,}
  \AttributeTok{q =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{)}
\NormalTok{d}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2     2     2     1     5    NA}
\CommentTok{\#\textgreater{} 3    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 4     3     4     1    17     1}
\CommentTok{\#\textgreater{} 5    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{w)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE  TRUE FALSE  TRUE}
\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{x)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Per creare un nuovo Dataframe senza valori mancanti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_clean }\OtherTok{\textless{}{-}}\NormalTok{ d[}\FunctionTok{complete.cases}\NormalTok{(d), ]}
\NormalTok{d\_clean}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2     3     4     1    17     1}
\end{Highlighting}
\end{Shaded}

Oppure, se vogliamo eliminare le righe con NA solo in una variabile:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}}\NormalTok{ d[}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{q), ]}
\NormalTok{d1}
\CommentTok{\#\textgreater{} \# A tibble: 4 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 3     3     4     1    17     1}
\CommentTok{\#\textgreater{} 4    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

Se vogliamo esaminare le righe con i dati mancanti in qualunque colonna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_na }\OtherTok{\textless{}{-}}\NormalTok{ d[}\SpecialCharTok{!}\FunctionTok{complete.cases}\NormalTok{(d), ]}
\NormalTok{d\_na}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     2     2     1     5    NA}
\CommentTok{\#\textgreater{} 2    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 3    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

Spesso i valori mancanti vengono sostiuti con valori ``ragionevoli'', come ad esempio la media dei valori in quella colonna del Dataframe. Oppure, vengono considerati come ``ragionevoli'' i valori che vengono predetti conoscendo le altre variabili del Dataframe. Questa procedura si chiama \emph{imputazione multipla}. Questo è però un argomento avanzato che non verrà trattato in questo insegnamento. La cosa più semplice da fare, in presenza di dati mancanti, è semplicemente quella di escludere tutte le righe nelle quali ci sono degli NAs.

  \bibliography{refs.bib,book.bib,packages.bib}

\printindex

\end{document}
