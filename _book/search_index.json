[["ch:metropolis.html", "Capitolo 2 Approssimazione della distribuzione a posteriori", " Capitolo 2 Approssimazione della distribuzione a posteriori In generale, in un problema bayesiano i dati \\(y\\) provengono da una densità \\(p(y \\mid \\theta)\\) e al parametro \\(\\theta\\) viene assegnata una densità a priori \\(p(\\theta)\\). Dopo avere osservato i dati \\(Y = y\\), la funzione di verosimiglianza è uguale a \\(\\mathcal{L}(\\theta) = p(y \\mid \\theta)\\) e la densità a posteriori diventa \\[\\begin{equation} p(\\theta \\mid y) = \\frac{p(y \\mid \\theta) p(\\theta)}{\\int p(y \\mid \\theta) p(\\theta) \\,\\operatorname {d}\\! \\theta}. \\notag \\end{equation}\\] Se vogliamo trovare la distribuzione a posteriori con metodi analitici è necessario ricorrere all’impiego di distribuzioni a priori coniugate, come nello schema beta-binomiale. Per quanto “semplice” in termini formali, la scelta di distribuzioni a priori coniugate limita di molto le possibili scelte del ricercatore. Inoltre, non è sempre sensato, dal punto di vista teorico, utilizzare tali distribuzioni per la stima dei parametri di interesse. Il mancato ricorso all’impiego delle distribuzioni a priori coniugate richiede necessariamente il computo dell’espressione a denominatore della formula di Bayes che solo in rare occasioni può essere ottenuta per via analitica. In altre parole, è possibile ottenere analiticamenre la distribuzione a posteriori solo per alcune specifiche combinazioni di distribuzioni a priori e verosimiglianza, il che limita considerevolmente la flessibilità della modellizzazione. Inoltre, i sommari della distribuzione a posteriori sono espressi come rapporto di integrali. Ad esempio, la media a posteriori di \\(\\theta\\) è data da \\[\\begin{equation} \\mathbb{E}(\\theta \\mid y) = \\frac{\\int \\theta p(y \\mid \\theta) p(\\theta) \\,\\operatorname {d}\\! \\theta}{\\int p(y \\mid \\theta) p(\\theta) \\,\\operatorname {d}\\! \\theta}.\\notag \\end{equation}\\] Il calcolo del valore atteso a posteriori richiede dunque il computo di due integrali, quello a denominatore e quello a numeratore dell’espressione, ciascuno dei quali non esprimibile in forma chiusa. Per questa ragione, la strada principale che viene seguita nella modellistica bayesiana è quella che porta a determinare la distribuzione a posteriori non per via analitica, ma bensì mediante metodi numerici. La simulazione fornisce dunque la strategia generale del calcolo bayesiano. A questo fine vengono principalmente usati i metodi di campionamento Monte Carlo basati su Catena di Markov (MCMC). Tali metodi costituiscono una potente e praticabile alternativa per la costruzione della distribuzione a posteriori per modelli complessi e consentono di decidere quali distribuzioni a priori e quali distribuzioni di verosimiglianza usare sulla base di considerazioni teoriche soltanto, senza dovere preoccuparsi di altri vincoli. Dato che è basata su metodi computazionalmente intensivi, la stima numerica della funzione a posteriori può essere svolta soltanto mediante software. In anni recenti i metodi Bayesiani di analisi dei dati sono diventati sempre più popolari proprio perché la potenza di calcolo necessaria per svolgere tali calcoli è ora alla portata di tutti. Questo non era vero solo pochi decenni fa. In questo Capitolo verranno presentati due metodi di simulazione iterativa1 che consentono di generare dalle distribuzioni a posteriori campioni dei parametri del modello: metodi basati su griglia: dove, sebbene non sia disponibile alcuna formula algebrica in forma chiusa, le proprietà della distribuzione a posteriori possono essere calcolate con una precisione arbitraria; metodi Monte Carlo: dove, utilizzando appropriate funzioni di numeri casuali, viene generato un ampio campione di casi della variabile casuale per poi stimare empiricamente la proprietà di interesse in base al campione così otttenuto. Si veda anche l’Appendice ??.↩︎ "],["metodo-basato-su-griglia.html", "2.1 Metodo basato su griglia", " 2.1 Metodo basato su griglia Il metodo basato su griglia (grid-based) è un metodo numerico esatto basato su una griglia di punti uniformemente spaziati. Anche se la maggior parte dei parametri è continua (ovvero, in linea di principio ciascun parametro può assumere un numero infinito di valori), possiamo ottenere un’eccellente approssimazione della distribuzione a posteriori considerando solo una griglia finita di valori dei parametri. In un tale metodo, la densità di probabilità a posteriori può dunque essere approssimata tramite le densità di probabilità calcolate in ciascuna cella della griglia. Il metodo basato su griglia si sviluppa in quattro fasi: fissare una griglia discreta di possibili valori \\(\\theta\\); valutare la distribuzione a priori \\(p(\\theta)\\) e la funzione di verosimiglianza \\(p(y \\mid \\theta)\\) in corrispondenza di ciascun valore \\(\\theta\\) della griglia; ottenere un’approssimazione discreta della densità a posteriori: per ciascun valore \\(\\theta\\) della griglia, calcolare il prodotto \\(p(\\theta) p(y \\mid \\theta)\\); normalizzare i prodotti così ottenuti in modo tale che la loro somma sia 1; selezionare \\(N\\) valori casuali della griglia in modo tale da ottenere un campione casuale delle densità a posteriori normalizzate. Possiamo migliorare l’approssimazione aumentando il numero di punti della griglia. Infatti utilizzando un numero infinito di punti si otterrebbe la descrizione esatta della distribuzione a posteriori, dovendo però pagare il costo dell’utilizzo di infinite risorse di calcolo. Il limite maggiore dell’approccio basato su griglia è che, al crescere della dimensionalità \\(N\\) dello spazio dei parametri, i punti della griglia necessari per avere una buona stima crescerebbero esponenzialmente con \\(N\\), rendendo questo metodo inattuabile. 2.1.1 Modello Beta-Binomiale Per fare un esempio, consideriamo lo schema beta-binomiale di cui conosciamo la soluzione esatta. Utilizziamo nuovamente i dati di Zetsche, Bürkner, and Renneberg (2019): 23 “successi” in 30 prove Bernoulliane indipendenti.2 Imponiamo alla distribuzione a priori su \\(\\theta\\) (probabilità di successo in una singola prova, laddove per “successo” si intende una aspettativa distorta negativamente dell’umore futuro) una \\(\\mbox{Beta}(2, 10)\\) per descrivere la nostra incertezza sul parametro prima di avere osservato i dati. Dunque, il modello diventa: \\[\\begin{align} Y \\mid \\theta &amp; \\sim \\mbox{Bin}(n = 30, \\theta), \\notag\\\\ \\theta &amp; \\sim \\mbox{Beta}(2, 10).\\notag \\end{align}\\] In queste circostanze, l’aggiornamento bayesiano produce una distribuzione a posteriori Beta di parametri 25 (\\(y + \\alpha\\) = 23 + 2) e 17 (\\(n - y + \\beta\\) = 30 - 23 + 10): \\[\\begin{equation} \\theta \\mid (y = 23) \\sim \\mbox{Beta}(25, 17).\\notag \\end{equation}\\] Per approssimare la distribuzione a posteriori, fissiamo una griglia di \\(n = 11\\) valori equispaziati: \\(\\theta \\in \\{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1\\}\\): grid_data &lt;- tibble( theta_grid = seq(from = 0, to = 1, length.out = 11) ) grid_data #&gt; # A tibble: 11 × 1 #&gt; theta_grid #&gt; &lt;dbl&gt; #&gt; 1 0 #&gt; 2 0.1 #&gt; 3 0.2 #&gt; 4 0.3 #&gt; 5 0.4 #&gt; 6 0.5 #&gt; 7 0.6 #&gt; 8 0.7 #&gt; # … with 3 more rows In corrispondenza di ciascun valore della griglia, valutiamo la distribuzione a priori \\(\\mbox{Beta}(2, 10)\\) e la verosimiglianza \\(\\mbox{Bin}(y = 23, n = 30)\\). grid_data &lt;- grid_data %&gt;% mutate( prior = dbeta(theta_grid, 2, 10), likelihood = dbinom(23, 30, theta_grid) ) In ciascuna cella della griglia calcoliamo poi il prodotto della verosimiglianza e della distribuzione a priori. Troviamo così un’approssimazione discreta e non normalizzata della distribuzione a posteriori (unnormalized). Normalizziamo questa approssimazione dividendo ciascun valore unnormalized per la somma di tutti i valori del vettore: grid_data &lt;- grid_data %&gt;% mutate( unnormalized = likelihood * prior, posterior = unnormalized / sum(unnormalized) ) Verifichiamo: grid_data %&gt;% summarize( sum(unnormalized), sum(posterior) ) #&gt; # A tibble: 1 × 2 #&gt; `sum(unnormalized)` `sum(posterior)` #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.000869 1 Abbiamo dunque ottenuto la seguente distribuzione a posteriori discretizzata \\(p(\\theta \\mid y)\\): round(grid_data, 2) #&gt; # A tibble: 11 × 5 #&gt; theta_grid prior likelihood unnormalized posterior #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 0 0 #&gt; 2 0.1 4.26 0 0 0 #&gt; 3 0.2 2.95 0 0 0 #&gt; 4 0.3 1.33 0 0 0 #&gt; 5 0.4 0.44 0 0 0.02 #&gt; 6 0.5 0.11 0 0 0.23 #&gt; 7 0.6 0.02 0.03 0 0.52 #&gt; 8 0.7 0 0.12 0 0.21 #&gt; # … with 3 more rows La figura 2.1 mostra un grafico della distribuzione a posteriori discretizzata così ottenuta: grid_data %&gt;% ggplot( aes(x = theta_grid, y = posterior) ) + geom_point() + geom_segment( aes( x = theta_grid, xend = theta_grid, y = 0, yend = posterior ) ) FIGURA 2.1: Distribuzione a posteriori discretizzata ottenuta con il metodo grid-based per \\(y\\) = 23 successi in 30 prove Bernoulliane, con distribuzione a priori \\(\\mbox{Beta}(2, 10)\\). È stata utilizzata una griglia di solo \\(n\\) = 11 punti. L’ultimo passo della simulazione è il campionamento dalla distribuzione a posteriori discretizzata: set.seed(84735) post_sample &lt;- sample_n( grid_data, size = 1e5, weight = posterior, replace = TRUE ) La figura 2.2 mostra che, con una griglia così sparsa abbiamo ottenuto una versione approssimata della vera distribuzione a posteriori (all’istogramma è stata sovrapposta l’esatta distribuzione a posteriori \\(\\mbox{Beta}(25, 17)\\)). ggplot(post_sample, aes(x = theta_grid)) + geom_histogram(aes(y = ..density..), color = &quot;white&quot;) + stat_function(fun = dbeta, args = list(25, 17)) + lims(x = c(0, 1)) FIGURA 2.2: Campionamento dalla distribuzione a posteriori discretizzata ottenuta con il metodo grid-based per \\(y\\) = 23 successi in 30 prove Bernoulliane, con distribuzione a priori \\(\\mbox{Beta}(2, 10)\\). È stata utilizzata una griglia di solo \\(n\\) = 11 punti. Possiamo ottenere un risultato migliore con una griglia più fine, come indicato nella figura 2.3: grid_data &lt;- tibble( theta_grid = seq(from = 0, to = 1, length.out = 100) ) grid_data &lt;- grid_data %&gt;% mutate( prior = dbeta(theta_grid, 2, 10), likelihood = dbinom(23, 30, theta_grid) ) grid_data &lt;- grid_data %&gt;% mutate( unnormalized = likelihood * prior, posterior = unnormalized / sum(unnormalized) ) grid_data %&gt;% ggplot( aes(x = theta_grid, y = posterior) ) + geom_point() + geom_segment( aes( x = theta_grid, xend = theta_grid, y = 0, yend = posterior ) ) FIGURA 2.3: Distribuzione a posteriori discretizzata ottenuta con il metodo grid-based per \\(y\\) = 23 successi in 30 prove Bernoulliane, con distribuzione a priori \\(\\mbox{Beta}(2, 10)\\). È stata utilizzata una griglia di \\(n\\) = 100 punti. Campioniamo ora 10000 punti: # Set the seed set.seed(84735) post_sample &lt;- sample_n( grid_data, size = 1e4, weight = posterior, replace = TRUE ) Con il campionamento dalla distribuzione a posteriori discretizzata costruita mediante una griglia più densa (\\(n = 100\\)) otteniamo un risultato soddisfacente (figura 2.4): ora la distribuzione dei valori prodotti dalla simulazione approssima molto bene la corretta distribuzione a posteriori \\(p(\\theta \\mid y) = \\mbox{Beta}(25, 17)\\). post_sample %&gt;% ggplot(aes(x = theta_grid)) + geom_histogram( aes(y = ..density..), color = &quot;white&quot;, bins = 50 ) + stat_function(fun = dbeta, args = list(25, 17)) + lims(x = c(0, 1)) FIGURA 2.4: Campionamento dalla distribuzione a posteriori discretizzata ottenuta con il metodo grid-based per \\(y\\) = 23 successi in 30 prove Bernoulliane, con distribuzione a priori \\(\\mbox{Beta}(2, 10)\\). È stata utilizzata una griglia di \\(n\\) = 100 punti. All’istogramma è stata sovrapposta la corretta distribuzione a posteriori, ovvero la densità \\(\\mbox{Beta}(25, 17)\\). In conclusione, il metodo basato su griglia è molto intuitivo e non richiede particolari competenze di programmazione per essere implementato. Inoltre, fornisce un risultato che, per tutti gli scopi pratici, può essere considerato come un campione casuale estratto da \\(p(\\theta \\mid y)\\). Tuttavia, anche se tale metodo fornisce risultati accuratissimi, esso ha un uso limitato. A causa della maledizione della dimensionalità3, tale metodo può solo essere solo nel caso di semplici modelli statistici, con non più di due parametri. Nella pratica concreta tale metodo viene dunque sostituito da altre tecniche più efficienti in quanto, anche nei più comuni modelli utilizzati in psicologia, vengono solitamente stimati centinaia se non migliaia di parametri. References "],["chapter-simulazioneMC.html", "2.2 Metodo Monte Carlo", " 2.2 Metodo Monte Carlo I metodi più ampiamente adottati nell’analisi bayesiana per la costruzione della distribuzione a posteriori per modelli complessi sono i metodi di campionamento MCMC. Tali metodi consentono al ricercatore di decidere quali distribuzioni a priori e quali distribuzioni di verosimiglianza usare sulla base di considerazioni teoriche soltanto, senza doversi preoccupare di altri vincoli. Dato che è basata su metodi computazionalmente intensivi, la stima numerica MCMC della funzione a posteriori può essere svolta soltanto mediante software. In anni recenti i metodi Bayesiani di analisi dei dati sono diventati sempre più popolari proprio perché la potenza di calcolo necessaria per svolgere tali calcoli è ora alla portata di tutti. Questo non era vero solo pochi decenni fa. 2.2.1 Integrazione di Monte Carlo Il termine Monte Carlo si riferisce al fatto che la computazione fa ricorso ad un ripetuto campionamento casuale attraverso la generazione di sequenze di numeri casuali. Una delle sue applicazioni più potenti è il calcolo degli integrali mediante simulazione numerica. Supponiamo di essere in grado di estrarre campioni casuali dalla distribuzione continua \\(p(\\theta \\mid y)\\) di media \\(\\mu\\). Se possiamo ottenere una sequenza di realizzazioni indipendenti \\[ \\theta^{(1)}, \\theta^{(2)},\\dots, \\theta^{(T)} \\overset{\\text{iid}}{\\sim} p(\\theta \\mid y) \\] allora diventa possibile calcolare \\[ \\E(\\theta \\mid y) = \\int \\theta p(\\theta \\mid y) \\,\\operatorname {d}\\!\\theta \\approx \\frac{1}{T} \\sum_{i=1}^T \\theta^{(t)}. \\] In altre parole, l’aspettazione teorica di \\(\\theta\\) può essere approssimata dalla media campionaria di un insieme di realizzazioni indipendenti ricavate da \\(p(\\theta \\mid y)\\). Per la Legge Forte dei Grandi Numeri, l’approssimazione diventa arbitrariamente esatta per \\(T \\rightarrow \\infty\\).4 Quello che è stato detto sopra non è altro che un modo sofisticato per dire che, se vogliamo calcolare un’approssimazione del valore atteso di una variabile casuale, non dobbiamo fare altro che la media aritmetica di un grande numero di realizzazioni indipendenti della variabile casuale. Come è facile intuire, l’approssimazione migliora al crescere del numero di dati che abbiamo a disposizione. Un’altra importante funzione di \\(\\theta\\) è la funzione indicatore, \\(I(l &lt; \\theta &lt; u)\\), che assume valore 1 se \\(\\theta\\) giace nell’intervallo \\((l, u)\\) e 0 altrimenti. Il valore di aspettazione di \\(I(l &lt; \\theta &lt; u)\\) rispetto a \\(p(\\theta)\\) dà la probabilità che \\(\\theta\\) rientri nell’intervallo specificato, \\(Pr(l &lt; \\theta &lt; u)\\), e può essere approssimato usando l’integrazione Monte Carlo, ovvero prendendo la media campionaria del valore della funzione indicatore per ogni realizzazione \\(\\theta^{(t)}\\). È semplice vedere come \\[ Pr(l &lt; \\theta &lt; u) \\approx \\frac{\\text{numero di realizzazioni } \\theta^{(t)} \\in (l, u)}{T}. \\] Presentiamo qui l’integrazione di Monte Carlo perché, nell’analisi bayesiana, il metodo Monte Carlo viene usato per ottenere un’approssimazione della distribuzione a posteriori, quando tale distribuzione non può essere calcolata con metodi analitici. In altre parole, il metodo Monte Carlo consente di ottenere un gran numero di valori \\(\\theta\\) che, nelle circostanze ideali, avrà una distribuzione identica alla distribuzione a posteriori \\(p(\\theta \\mid y)\\). 2.2.2 Descrizione intuitiva Se la funzione di densità \\(p(\\theta \\mid y)\\) è conosciuta, è facile ottenere una sequenza di realizzazioni iid della variabile casuale, per esempio, usando \\(\\textsf{R}\\). Ma ora supponiamo di non conoscere \\(p(\\theta \\mid y)\\). Quello che vogliamo fare è ottenere comunque una sequenza di valori \\(\\theta\\). Anche se tali valori non saranno iid, per qualunque coppia di valori \\(\\theta_a\\) e \\(\\theta_b\\) nella sequenza vogliamo che sia soddisfatto il seguente vincolo: \\[ \\frac{\\#\\theta&#39;\\text{ nella sequenza} = \\theta_a}{\\#\\theta&#39;\\text{ nella sequenza} = \\theta_b} \\approx \\frac{p(\\theta_a \\mid y)}{p(\\theta_b \\mid y)}. \\] L’algoritmo di Metropolis ci consente di ottenere una tale sequenza di valori, la cui distribuzione sarà dunque uguale a \\(p(\\theta \\mid y)\\). In forma intuitiva, l’algoritmo di Metropolis può essere descritto come indicato di seguito. Data una sequenza di valori \\(\\{\\theta^{(1)}, \\theta^{(2)},\\dots, \\theta^{(t)}\\}\\), ci poniamo il problema di aggiungere un nuovo valore \\(\\theta^{t+1}\\) alla sequenza. Consideriamo un valore \\(\\theta^*\\) simile a \\(\\theta^{(t)}\\); ci chiediamo se dobbiamo inserire un tale valore nella sequenza oppure no. Se \\(p(\\theta^* \\mid y) &gt; p(\\theta^{(t)} \\mid y)\\), allora sicuramente lo dobbiamo aggiungere alla sequenza perché, nella sequenza, il numero di valori \\(\\theta^*\\) deve essere maggiore del numero dei valori \\(\\theta^{(t)}\\). Se invece \\(p(\\theta^* \\mid y) &lt; p(\\theta^{(t)} \\mid y)\\), allora non dobbiamo necessariamente aggiungere \\(\\theta^*\\) alla sequenza. La decisione di aggiungere o no \\(\\theta^*\\) alla sequenza dipenderà dal confronto tra \\(p(\\theta^* \\mid y)\\) e \\(p(\\theta^{(t)} \\mid y)\\). Calcoliamo il rapporto \\[ r = \\frac{p(\\theta^* \\mid y)}{p(\\theta^{(t)} \\mid y)} = \\frac{p(y \\mid \\theta^*) p(\\theta^*)}{p(y \\mid p(\\theta^{(t)}) p(p(\\theta^{(t)})}. \\] Se \\(r &gt; 1\\), accettiamo \\(\\theta^*\\) e lo aggiungiamo alla sequenza: \\(\\theta^{(t+1)} = \\theta^*\\), in quanto \\(\\theta^{(t)}\\) è già presente nella sequenza e \\(\\theta^*\\) ha una probabilità maggiore di \\(\\theta^{(t)}\\). Se \\(r &lt; 1\\), per ciasuna istanza di \\(\\theta^{(t)}\\), accettiamo \\(\\theta^*\\) solo una frazione di volte uguale a \\[\\frac{p(\\theta^* \\mid y)}{p(\\theta^{(t)} \\mid y)}\\] in quanto la frequenza relativa dei valori \\(\\theta^{(t)}\\) e \\(\\theta^*\\) nella sequenza deve essere uguale al rapporto precedente. Per ottenere questo risultato, poniamo \\(\\theta^{(t+1)}\\) uguale a \\(\\theta^*\\) o \\(\\theta^{(t)}\\) con probabilità rispettivamente uguali a \\(r\\) o \\(1 - r\\). Questa è l’intuizione che sta alla base dell’algoritmo di Metropolis et al. (1953). 2.2.3 Un’applicazione empirica Poniamoci ora il problema di usare l’algoritmo di Metropolis per calcolare la distribuzione a posteriori di una proporzione \\(\\theta\\). Usiamo nuovamente i dati di Zetsche, Bürkner, and Renneberg (2019) (ovvero, 23 “successi” in 30 prove Bernoulliane) e, per rendere il problema più interessante, assumiamo per \\(\\theta\\) una distribuzione a priori \\(\\mbox{Beta}(2, 10)\\). Sappiamo che, in tali circostanze, la distribuzione a posteriori può essere ottenuta analiticamente tramite lo schema beta-binomiale ed è una \\(\\mbox{Beta}(25, 17)\\). Se vogliamo il valore della media a posteriori di \\(\\theta\\), il risultato esatto è dunque \\[ \\bar{\\theta}_{post} = \\frac{\\alpha}{\\alpha + \\beta} = \\frac{25}{25 + 17} \\approx 0.5952. \\] È anche possibile ottenere il valore della media a posteriori per via numerica. Sapendo che la distribuzione a posteriori è una \\(\\mbox{Beta}(25, 17)\\), possiamo estrarre un campione di osservazioni da una tale distribuzione e calcolare la media. Con poche osservazioni (diciamo 10) otteniamo un risultato molto approssimato set.seed(84735) print(mean(rbeta(1e2, shape1 = 25, shape2 = 17)), 6) #&gt; [1] 0.584251 ma, per la legge dei grandi numeri, l’approssimazione migliora all’aumentare del numero di osservazioni: print(mean(rbeta(1e4, shape1 = 25, shape2 = 17)), 6) #&gt; [1] 0.595492 print(mean(rbeta(1e6, shape1 = 25, shape2 = 17)), 6) #&gt; [1] 0.595192 Lo stesso si può dire delle altre statistiche descrittive: moda, varianza, eccetera. Nel presente esempio, la simulazione Monte Carlo produce il risultato desiderato perché sappiamo che la distribuzione a posteriori è una \\(\\mbox{Beta}(25, 17)\\), è possibile usare le funzioni \\(\\R\\) per estrarre campioni casuali da una tale distribuzione. Tuttavia, capita raramente di usare una distribuzione a priori coniugata alla verosimiglianza. Quindi, in generale, le due condizioni descritte sopra non si applicano. Ad esempio, nel caso di una verosimiglianza binomiale e di una distribuzione a priori gaussiana, la distribuzione a posteriori di \\(\\theta\\) è \\[ p(\\theta \\mid y) = \\frac{\\mathrm{e}^{-(\\theta - 1 / 2)^2} \\theta^y (1 - \\theta)^{n - y}} {\\int_0^1 \\mathrm{e}^{-(t - 1 / 2)^2} t^y (1 - t)^{n - y} dt}. \\] Una tale distribuzione non è implementata in \\(\\R\\) e dunque non possiamo ottenere dei campioni casuali da una tale distribuzione. In tali circostanze, però, è ancora possibile ottenere ottenere un campione causale dalla distribuzione a posteriori in un altro modo. Questo risultato si ottiene utilizzando i metodi Monte Carlo basati su Catena di Markov (MCMC). I metodi MCMC, di cui l’algoritmo di Metropolis è un caso particolare e ne rappresenta il primo esempio, sono una classe di algoritmi che consentono di ottenere campioni casuali da una distribuzione a posteriori senza dovere conoscere la rappresentazione analitica di una tale distribuzione.5 Le tecniche MCMC sono il metodo computazionale maggiormente usato per risolvere i problemi dell’inferenza bayesiana. 2.2.4 Una passeggiata casuale sui numeri naturali Prima di applicare l’algoritmo di Metropolis ai dati di Zetsche, Bürkner, and Renneberg (2019), consideriamo un caso più semplice. In questo esempio preliminare useremo l’algoritmo di Metropolis per ottenere un campione casuale da una distribuzione di massa di probabilità; esamineremo il caso continuo in seguito.6 Definiamo la distribuzione di probabilità discreta della variabile casuale \\(X\\) che assume valori nell’insieme dei numeri naturali \\(1, 2, \\dots, K\\). Scriviamo in \\(\\R\\) la funzione pd() che assegna a \\(X = \\{1, 2, \\dots, 8\\}\\) valori di probabilità proporzionali agli interi 5, 10, 4, 4, 20, 20, 12 e 5: pd &lt;- function(x) { values &lt;- c(5, 10, 4, 4, 20, 20, 12, 5) ifelse( x %in% 1:length(values), values[x] / sum(values), 0 ) } prob_dist &lt;- tibble( x = 1:8, prob = pd(1:8) ) La figura 2.5 illustra la distribuzione di massa di probabilità che è stata generata in questo modo. x &lt;- 1:8 prob_dist %&gt;% ggplot(aes(x = x, y = prob)) + geom_bar(stat = &quot;identity&quot;, width = 0.06) + scale_x_continuous(&quot;x&quot;, labels = as.character(x), breaks = x) + labs( y = &quot;Probabilità&quot;, x = &quot;X&quot; ) FIGURA 2.5: Distribuzione di massa di probabilità della variabile casuale discreta \\(X\\) avente supporto \\(\\{1, 2, ..., 8\\}\\). Per i dati di questo esempio, l’algoritmo di Metropolis corrisponde alla seguente passeggiata aleatoria.7 L’algoritmo inizia con un valore iniziale qualsiasi da 1 a \\(K=8\\) della variabile casuale. Per simulare il valore successivo della sequenza, lanciamo una moneta equilibrata. Se esce testa, consideriamo come valore candidato il valore immediatamente precedente al valore corrente nella sequenza; se esce croce, il candidato è il valore nella sequenza immediatamente successivo a quello corrente. Si calcola il rapporto \\(r\\) tra la probabilità del valore candidato e la probabilità del valore corrente: \\[ r = \\frac{pd(\\text{valore candidato})}{pd(\\text{valore corrente})}. \\] Si estrae un numero a caso \\(\\in [0, 1]\\). Se tale valore è minore di \\(r\\) si accetta il valore candidato come valore successivo della catena markoviana; altrimenti il valore successivo della catena rimane il valore corrente. In termini tecnici (si veda l’Appendice ??), i passi da 1 a 4 definiscono una catena di Markov irriducibile e aperiodica sui valori di stato \\(\\{1, 2,\\dots, 8\\}\\), dove il passo 1 fornisce il valore iniziale della catena e i passi da 2 a 4 definiscono la matrice di transizione \\(P\\). Il campionamento dalla distribuzione di massa pd corrisponde ad una passeggiata aleatoria che inizia da una posizione qualsiasi e che ripete le fasi 2, 3 e 4 dell’algoritmo di Metropolis. Dopo un gran numero di passi, la distribuzione dei valori della catena markoviana approssimerà la distribuzione di probabilità pd. La funzione random_walk() implementa l’algoritmo di Metropolis. Tale funzione prende in input la distribuzione di probabilità pd, la posizione di partenza start e il numero di passi dell’algoritmo num_steps. random_walk &lt;- function(pd, start, num_steps) { y &lt;- rep(0, num_steps) current &lt;- start for (j in 1:num_steps) { candidate &lt;- current + sample(c(-1, 1), 1) prob &lt;- pd(candidate) / pd(current) if (runif(1) &lt; prob) { current &lt;- candidate } y[j] &lt;- current } return(y) } Implementiamo ora l’algoritmo di Metropolis utilizzando, quale valore iniziale, \\(X=4\\). Ripetiamo la simulazione 10,000 volte. out &lt;- random_walk(pd, 4, 1e4) S &lt;- tibble(out) %&gt;% group_by(out) %&gt;% summarize( N = n(), Prob = N / 10000 ) prob_dist2 &lt;- rbind( prob_dist, tibble( x = S$out, prob = S$Prob ) ) prob_dist2$Type &lt;- rep( c(&quot;Prob. corrette&quot;, &quot;Prob. simulate&quot;), each = 8 ) x &lt;- 1:8 prob_dist2 %&gt;% ggplot(aes(x = x, y = prob, fill = Type)) + geom_bar( stat = &quot;identity&quot;, width = 0.1, position = position_dodge(0.3) ) + scale_x_continuous( &quot;x&quot;, labels = as.character(x), breaks = x ) + scale_fill_manual(values = c(&quot;black&quot;, &quot;gray80&quot;)) + theme(legend.title = element_blank()) + labs( y = &quot;Probabilità&quot;, x = &quot;X&quot; ) FIGURA 2.6: L’istogramma confronta i valori prodotti dall’algoritmo di Metropolis con i valori corretti della distribuzione di massa di probabilità. La figura 2.6 confronta l’istogramma dei valori simulati dalla passeggiata aleatoria con l’effettiva distribuzione di probabilità pd. Si noti che le due distribuzioni sono molto simili. 2.2.5 L’algoritmo di Metropolis Dopo avere introdotto l’algoritmo di Metropolis con l’esempio proposto da Albert and Hu (2019), poniamoci ora il problema di descrivere tale algoritmo nel caso generale.8 Possiamo distinguere due fasi. Fase 1: scegliere un valore candidato \\(\\theta&#39;\\) del parametro mediante il campionamento da una distribuzione proposta. Fase 2: decidere se accettare il valore candidato \\(\\theta^{(m+1)} = \\theta&#39;\\) o se mantenere il valore corrente \\(\\theta^{(m+1)} = \\theta\\) mediante il seguente criterio: se \\(\\mathcal{L}(\\theta&#39; \\mid y)p(\\theta&#39;) &gt; \\mathcal{L}(\\theta \\mid y)p(\\theta)\\) il valore candidato viene sempre accettato; altrimenti il valore candidato viene accettato con una certa probabilità. In maggiori dettagli, l’algoritmo di Metropolis può essere descritto nel modo seguente. Si inizia con un punto arbitrario \\(\\theta^{(1)}\\); quindi il primo valore della catena di Markov \\(\\theta^{(1)}\\) può corrispondere semplicemente ad un valore a caso tra i valori possibili del parametro. Per ogni passo successivo della catena, \\(m + 1\\), si campiona un valore candidato \\(\\theta&#39;\\) da una distribuzione proposta: \\(\\theta&#39; \\sim \\Pi(\\theta)\\). La distribuzione proposta può essere qualunque distribuzione, anche se, idealmente, è meglio che sia simile alla distribuzione a posteriori. In pratica, però, la distribuzione a posteriori è sconosciuta e quindi il valore \\(\\theta&#39;\\) viene campionato da una qualche distribuzione simmetrica centrata sul valore corrente \\(\\theta^{(m)}\\) del parametro. Nell’esempio discusso qui di seguito, useremo la distribuzione gaussiana. Tale distribuzione sarà centrata sul valore corrente della catena e avrà una appropriata deviazione standard: \\(\\theta&#39; \\sim \\mathcal{N}(\\theta^{(m)}, \\sigma)\\). In pratica, questo significa che, se \\(\\sigma\\) è piccola, il candidato \\(\\theta&#39;\\) avrà un valore simile al valore corrente \\(\\theta^{(m)}\\). Una volta generato il valore candidato \\(\\theta&#39;\\) si calcola il rapporto tra la densità della distribuzione a posteriori non normalizzata nel punto \\(\\theta&#39;\\) [ovvero, il prodotto tra la verosimiglianza \\(\\mathcal{L}(y \\mid \\theta&#39;)\\) nel punto \\(\\theta&#39;\\) e la densità della distribuzione a priori nel punto \\(\\theta&#39;\\)] e la densità della distribuzione a posteriori non normalizzata nel punto \\(\\theta^{(m)}\\) [ovvero, il prodotto tra la verosimiglianza \\(\\mathcal{L}(y \\mid \\theta^{(m)})\\) nel punto \\(\\theta^{(m)}\\) e la densità della distribuzione a priori nel punto \\(\\theta^{(m)}\\)]: \\[\\begin{equation} \\alpha = \\frac{p(y \\mid \\theta&#39;) p(\\theta&#39;)}{p(y \\mid \\theta^{(m)}) p(\\theta^{(m)})}. \\tag{2.1} \\end{equation}\\] Si noti che, essendo un rapporto, la (2.1) cancella la costante di normalizzazione. Il rapporto \\(\\alpha\\) viene utilizzato per decidere se accettare il valore candidato \\(\\theta&#39;\\), oppure se campionare un diverso candidato. Possiamo pensare al rapporto \\(\\alpha\\) come alla risposta alla seguente domanda: alla luce dei dati, è più plausibile il valore candidato del parametro o il valore corrente? Se \\(\\alpha\\) è maggiore di 1 ciò significa che il valore candidato è più plausibile del valore corrente; in tali circostanze il valore candidato viene sempre accettato. Altrimenti, si decide di accettare il valore candidato con una probabilità minore di 1, ovvero non sempre, ma soltanto con una probabilità uguale ad \\(\\alpha\\). Se \\(\\alpha\\) è uguale a 0.10, ad esempio, questo significa che la credibilità a posteriori del valore candidato è 10 volte più piccola della credibilità a posteriori del valore corrente. Dunque, il valore candidato verrà accettato solo nel 10% dei casi. Come conseguenza di questa strategia di scelta, l’algoritmo di Metropolis ottiene un campione casuale dalla distribuzione a posteriori, dato che la probabilità di accettare il valore candidato è proporzionale alla densità del candidato nella distribuzione a posteriori. Dal punto di vista algoritmico, la procedura descritta sopra viene implementata confrontando il rapporto \\(\\alpha\\) con un valore casuale estratto da una distribuzione uniforme \\(\\mbox{Unif}(0, 1)\\). Se \\(\\alpha &gt; u \\sim \\mbox{Unif}(0, 1)\\), allora il valore candidato \\(\\theta&#39;\\) viene accettato e la catena si muove in quella nuova posizione, ovvero \\(\\theta^{(m+1)} = \\theta&#39;\\). Altrimenti \\(\\theta^{(m+1)} = \\theta^{(m)}\\) e si campiona un nuovo valore candidato \\(\\theta&#39;\\). Il passaggio finale dell’algoritmo calcola l’accettanza in una specifica esecuzione dell’algoritmo, ovvero la proporzione dei valori candidati \\(\\theta&#39;\\) che sono stati accettati come valori successivi nella sequenza. L’algoritmo di Metropolis prende come input il numero \\(M\\) di passi da simulare, la deviazione standard \\(\\sigma\\) della distribuzione proposta e la densità a priori, e ritorna come output la sequenza \\(\\theta^{(1)}, \\theta^{(2)}, \\dots, \\theta^{(M)}\\). La chiave del successo dell’algoritmo di Metropolis è il numero di passi fino a che la catena approssima la stazionarietà. Tipicamente i primi da 1000 a 5000 elementi sono scartati. Dopo un certo periodo \\(k\\) (detto di burn-in), la catena di Markov converge ad una variabile casuale che è distribuita secondo la distribuzione a posteriori. In altre parole, i campioni del vettore \\(\\left(\\theta^{(k+1)}, \\theta^{(k+2)}, \\dots, \\theta^{(M)}\\right)\\) diventano campioni di \\(p(\\theta \\mid y)\\). 2.2.6 Un’applicazione empirica Consideriamo nuovamente i 30 pazienti esaminati da Zetsche, Bürkner, and Renneberg (2019). Di essi, 23 hanno manifestato aspettative distorte negativamente sul loro stato d’animo futuro. Utilizzando l’algoritmo di Metropolis, ci poniamo il problema di ottenere la stima a posteriori di \\(\\theta\\) (probabilità di manifestare un’aspettativa distorta negativamente), dati 23 “successi” in 30 prove, e imponendo su \\(\\theta\\) la stessa distribuzione a priori usata nel Capitolo ??, ovvero \\(\\mbox{Beta}(2, 10)\\).9 2.2.6.1 Funzioni Per calcolare la funzione di verosimiglianza definiamo la funzione likelihood() likelihood &lt;- function(param, x = 23, N = 30) { dbinom(x, N, param) } che, avendo fissato i dati di Zetsche, Bürkner, and Renneberg (2019), ritorna l’ordinata della verosimiglianza binomiale per ciascun valore param in input. La distribuzione a priori \\(\\mbox{Beta}(2, 10)\\) è implementata nella funzione prior(): prior &lt;- function(param, alpha = 2, beta = 10) { dbeta(param, alpha, beta) } Questa funzione ritorna l’ordinata della distribuzione a priori che è stata definita, per ciascun valore param in input. La funzione posterior() ritorna, per ciascun valore param in input, il prodotto della densità a priori e della verosimiglianza: posterior &lt;- function(param) { likelihood(param) * prior(param) } 2.2.6.2 Implementazione Per implementare l’algoritmo di Metropolis utilizzeremo una distribuzione proposta gaussiana. Il valore candidato sarà dunque un valore selezionato a caso da una gaussiana di parametri \\(\\mu\\) uguale al valore corrente nella catena e \\(\\sigma = 0.9\\). In questo esempio, la deviazione standard \\(\\sigma\\) è stata scelta empiricamente in modo tale da ottenere una accettanza adeguata. L’accettanza ottimale èpari a circa 0.20/0.30 — se l’accettanza è troppo grande, l’algoritmo esplora uno spazio troppo ristretto della distribuzione a posteriori.10 proposal_distribution &lt;- function(param) { while (1) { res &lt;- rnorm(1, mean = param, sd = 0.9) if (res &gt; 0 &amp; res &lt; 1) { break } } res } Nella presente implementazione del campionamento dalla distribuzione proposta è stato inserito un controllo che impone al valore candidato di essere incluso nell’intervallo [0, 1], com’è necessario per il valore di una proporzione.11 L’algoritmo di Metropolis viene implementato nella seguente funzione: run_metropolis_MCMC &lt;- function(startvalue, iterations) { chain &lt;- vector(length = iterations + 1) chain[1] &lt;- startvalue for (i in 1:iterations) { proposal &lt;- proposal_distribution(chain[i]) r &lt;- posterior(proposal) / posterior(chain[i]) if (runif(1) &lt; r) { chain[i + 1] &lt;- proposal } else { chain[i + 1] &lt;- chain[i] } } chain } Avendo definito le funzioni precedenti, possiamo ora generare una catena di valori \\(\\theta\\): set.seed(84735) startvalue &lt;- runif(1, 0, 1) niter &lt;- 1e4 chain &lt;- run_metropolis_MCMC(startvalue, niter) Mediante le istruzioni precedenti otteniamo una catena di Markov costituita da 10,001 valori. Escludiamo i primi 5,000 valori considerati come burn-in. Ci restano dunque con 5,001 valori che verranno considerati come un campione casuale estratto dalla distribuzione a posteriori \\(p(\\theta \\mid y)\\). L’accettanza è pari a burnIn &lt;- niter / 2 acceptance &lt;- 1 - mean(duplicated(chain[-(1:burnIn)])) acceptance #&gt; [1] 0.2585483 il che conferma la bontà della deviazione standard (\\(\\sigma\\) = 0.9) scelta per la distribuzione proposta. A questo punto è facile ottenere una stima a posteriori del parametro \\(\\theta\\). Per esempio, la stima della media a posteriori è: mean(chain[-(1:burnIn)]) #&gt; [1] 0.5956983 Una figura che mostra l’approssimazione di \\(p(\\theta \\mid y)\\) ottenuta con l’algoritmo di Metropolis, insieme ad un trace plot dei valori della catena di Markov, viene prodotta usando le seguenti istruzioni: p1 &lt;- tibble( x = chain[-(1:burnIn)] ) %&gt;% ggplot(aes(x)) + geom_histogram() + labs( x = expression(theta), y = &quot;Frequenza&quot;, title = &quot;Distribuzione a posteriori&quot; ) + geom_vline( xintercept = mean(chain[-(1:burnIn)]) ) + xlim(c(0.3, 0.85)) + coord_flip() p2 &lt;- tibble( x = 1:length(chain[-(1:burnIn)]), y = chain[-(1:burnIn)] ) %&gt;% ggplot(aes(x, y)) + geom_line() + labs( x = &quot;Numero di passi&quot;, y = expression(theta), title = &quot;Valori della catena&quot; ) + geom_hline( yintercept = mean(chain[-(1:burnIn)]), colour = &quot;gray&quot; ) + ylim(c(0.3, 0.85)) p1 + p2 FIGURA 2.7: Sinistra. Stima della distribuzione a posteriori della probabilità di una aspettativa futura distorta negativamente per i dati di Zetsche et al. (2019). Destra. Trace plot dei valori della catena di Markov escludendo il periodo di burn-in. 2.2.7 Input Negli esempi discussi in questo Capitolo abbiamo illustrato l’esecuzione di una singola catena in cui si parte un unico valore iniziale e si raccolgono i valori simulati da molte iterazioni. È possibile però che i valori di una catena siano influenzati dalla scelta del valore iniziale. Quindi una raccomandazione generale è di eseguire l’algoritmo di Metropolis più volte utilizzando diversi valori di partenza. In questo caso, si avranno più catene di Markov. Confrontando le proprietà delle diverse catene si esplora la sensibilità dell’inferenza alla scelta del valore di partenza. I software MCMC consentono sempre all’utente di specificare diversi valori di partenza e di generare molteplici catene di Markov. 2.2.8 Stazionarietà Un punto importante da verificare è se il campionatore ha raggiunto la sua distribuzione stazionaria. La convergenza di una catena di Markov alla distribuzione stazionaria viene detta “mixing”. 2.2.8.1 Autocorrelazione Informazioni sul “mixing” della catena di Markov sono fornite dall’autocorrelazione. L’autocorrelazione misura la correlazione tra i valori successivi di una catena di Markov. Il valore \\(m\\)-esimo della serie ordinata viene confrontato con un altro valore ritardato di una quantità \\(k\\) (dove \\(k\\) è l’entità del ritardo) per verificare quanto si correli al variare di \\(k\\). L’autocorrelazione di ordine 1 (lag 1) misura la correlazione tra valori successivi della catena di Markow (cioè, la correlazione tra \\(\\theta^{(m)}\\) e \\(\\theta^{(m-1)}\\)); l’autocorrelazione di ordine 2 (lag 2) misura la correlazione tra valori della catena di Markow separati da due “passi” (cioè, la correlazione tra \\(\\theta^{(m)}\\) e \\(\\theta^{(m-2)}\\)); e così via. L’autocorrelazione di ordine \\(k\\) è data da \\(\\rho_k\\) e può essere stimata come: \\[\\begin{align} \\rho_k &amp;= \\frac{\\Cov(\\theta_m, \\theta_{m+k})}{\\Var(\\theta_m)}\\notag\\\\ &amp;= \\frac{\\sum_{m=1}^{n-k}(\\theta_m - \\bar{\\theta})(\\theta_{m-k} - \\bar{\\theta})}{\\sum_{m=1}^{n-k}(\\theta_m - \\bar{\\theta})^2} \\qquad\\text{con }\\quad \\bar{\\theta} = \\frac{1}{n}\\sum_{m=1}^{n}\\theta_m. \\tag{2.2} \\end{align}\\] Per fare un esempio pratico, simuliamo dei dati autocorrelati con la funzione R colorednoise::colored_noise(): suppressPackageStartupMessages(library(&quot;colorednoise&quot;)) set.seed(34783859) rednoise &lt;- colored_noise( timesteps = 30, mean = 0.5, sd = 0.05, phi = 0.3 ) L’autocorrelazione di ordine 1 è semplicemente la correlazione tra ciascun elemento e quello successivo nella sequenza. Nell’esempio, il vettore rednoise è una sequenza temporale di 30 elementi. Il vettore rednoise[-length(rednoise)] include gli elementi con gli indici da 1 a 29 nella sequenza originaria, mentre il vettore rednoise[-1] include gli elementi 2:30. Gli elementi delle coppie ordinate dei due vettori avranno dunque gli indici \\((1, 2), (2, 3), \\dots (29, 30)\\) degli elementi della sequenza originaria. La correlazione di Pearson tra i vettori rednoise[-length(rednoise)] e rednoise[-1] corrisponde all’autocorrelazione di ordine 1 della serie temporale. cor(rednoise[-length(rednoise)], rednoise[-1]) #&gt; [1] 0.3967366 Il Correlogramma è uno strumento grafico usato per la valutazione della tendenza di una catena di Markov nel tempo. Il correlogramma si costruisce a partire dall’autocorrelazione \\(\\rho_k\\) di una catena di Markov in funzione del ritardo (lag) \\(k\\) con cui l’autocorrelazione è calcolata: nel grafico ogni barretta verticale riporta il valore dell’autocorrelazione (sull’asse delle ordinate) in funzione del ritardo (sull’asse delle ascisse). In \\(\\R\\), il correlogramma può essere prodotto con una chiamata a acf(): acf(rednoise) Nel correlogramma precedente vediamo che l’autocorrelazione di ordine 1 è circa pari a 0.4 e diminuisce per lag maggiori; per lag di 4, l’autocorrelazione diventa negativa e aumenta progressivamente fino ad un lag di 8; eccetera. In situazioni ottimali l’autocorrelazione diminuisce rapidamente ed è effettivamente pari a 0 per piccoli lag. Ciò indica che i valori della catena di Markov che si trovano a più di soli pochi passi di distanza gli uni dagli altri non risultano associati tra loro, il che fornisce una conferma del “mixing” della catena di Markov, ossia della convergenza alla distribuzione stazionaria. Nelle analisi bayesiane, una delle strategie che consentono di ridurre l’autocorrelazione è quella di assottigliare l’output immagazzinando solo ogni \\(m\\)-esimo punto dopo il periodo di burn-in. Una tale strategia va sotto il nome di thinning. 2.2.9 Test di convergenza Un test di convergenza può essere svolto in maniera grafica mediante le tracce delle serie temporali (trace plot), cioè il grafico dei valori simulati rispetto al numero di iterazioni. Se la catena è in uno stato stazionario le tracce mostrano assenza di periodicità nel tempo e ampiezza costante, senza tendenze visibili o andamenti degni di nota. Un esempio di trace plot è fornito nella figura 2.7 (destra). Ci sono inoltre alcuni test che permettono di verificare la stazionarietà del campionatore dopo un dato punto. Uno è il test di Geweke che suddivide il campione, dopo aver rimosso un periodo di burn in, in due parti. Se la catena è in uno stato stazionario, le medie dei due campioni dovrebbero essere uguali. Un test modificato, chiamato Geweke z-score, utilizza un test \\(z\\) per confrontare i due subcampioni ed il risultante test statistico, se ad esempio è più alto di 2, indica che la media della serie sta ancora muovendosi da un punto ad un altro e quindi è necessario un periodo di burn-in più lungo. References "],["commenti-e-considerazioni-finali-1.html", "Commenti e considerazioni finali", " Commenti e considerazioni finali In generale, la distribuzione a posteriori dei parametri di un modello statistico non può essere determinata per via analitica. Tale problema viene invece affrontato facendo ricorso ad una classe di algoritmi per il campionamento da distribuzioni di probabilità che sono estremamente onerosi dal punto di vista computazionale e che possono essere utilizzati nelle applicazioni pratiche solo grazie alla potenza di calcolo dei moderni computer. Lo sviluppo di software che rendono sempre più semplice l’uso dei metodi MCMC, insieme all’incremento della potenza di calcolo dei computer, ha contribuito a rendere sempre più popolare il metodo dell’inferenza bayesiana che, in questo modo, può essere estesa a problemi di qualunque grado di complessità. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
